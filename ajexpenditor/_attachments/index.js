!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);void 0!==c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1"], [], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
$__System.registerDynamic('2', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ARIADOMPropertyConfig = {
    Properties: {
      // Global States and Properties
      'aria-current': 0, // state
      'aria-details': 0,
      'aria-disabled': 0, // state
      'aria-hidden': 0, // state
      'aria-invalid': 0, // state
      'aria-keyshortcuts': 0,
      'aria-label': 0,
      'aria-roledescription': 0,
      // Widget Attributes
      'aria-autocomplete': 0,
      'aria-checked': 0,
      'aria-expanded': 0,
      'aria-haspopup': 0,
      'aria-level': 0,
      'aria-modal': 0,
      'aria-multiline': 0,
      'aria-multiselectable': 0,
      'aria-orientation': 0,
      'aria-placeholder': 0,
      'aria-pressed': 0,
      'aria-readonly': 0,
      'aria-required': 0,
      'aria-selected': 0,
      'aria-sort': 0,
      'aria-valuemax': 0,
      'aria-valuemin': 0,
      'aria-valuenow': 0,
      'aria-valuetext': 0,
      // Live Region Attributes
      'aria-atomic': 0,
      'aria-busy': 0,
      'aria-live': 0,
      'aria-relevant': 0,
      // Drag-and-Drop Attributes
      'aria-dropeffect': 0,
      'aria-grabbed': 0,
      // Relationship Attributes
      'aria-activedescendant': 0,
      'aria-colcount': 0,
      'aria-colindex': 0,
      'aria-colspan': 0,
      'aria-controls': 0,
      'aria-describedby': 0,
      'aria-errormessage': 0,
      'aria-flowto': 0,
      'aria-labelledby': 0,
      'aria-owns': 0,
      'aria-posinset': 0,
      'aria-rowcount': 0,
      'aria-rowindex': 0,
      'aria-rowspan': 0,
      'aria-setsize': 0
    },
    DOMAttributeNames: {},
    DOMPropertyNames: {}
  };

  module.exports = ARIADOMPropertyConfig;
});
$__System.registerDynamic('3', ['6', '4', '5'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var _assign = $__require('6');
  var PooledClass = $__require('4');
  var getTextContentAccessor = $__require('5');
  function FallbackCompositionState(root) {
    this._root = root;
    this._startText = this.getText();
    this._fallbackText = null;
  }
  _assign(FallbackCompositionState.prototype, {
    destructor: function () {
      this._root = null;
      this._startText = null;
      this._fallbackText = null;
    },
    getText: function () {
      if ('value' in this._root) {
        return this._root.value;
      }
      return this._root[getTextContentAccessor()];
    },
    getData: function () {
      if (this._fallbackText) {
        return this._fallbackText;
      }
      var start;
      var startValue = this._startText;
      var startLength = startValue.length;
      var end;
      var endValue = this.getText();
      var endLength = endValue.length;
      for (start = 0; start < startLength; start++) {
        if (startValue[start] !== endValue[start]) {
          break;
        }
      }
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd; end++) {
        if (startValue[startLength - end] !== endValue[endLength - end]) {
          break;
        }
      }
      var sliceTail = end > 1 ? 1 - end : undefined;
      this._fallbackText = endValue.slice(start, sliceTail);
      return this._fallbackText;
    }
  });
  PooledClass.addPoolingTo(FallbackCompositionState);
  module.exports = FallbackCompositionState;
});
$__System.registerDynamic('7', ['8'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('8');
  var CompositionEventInterface = { data: null };
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
  module.exports = SyntheticCompositionEvent;
});
$__System.registerDynamic('9', ['8'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('8');
  var InputEventInterface = { data: null };
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
  module.exports = SyntheticInputEvent;
});
$__System.registerDynamic('a', ['b', 'c', '3', '7', '9'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('b');
  var ExecutionEnvironment = $__require('c');
  var FallbackCompositionState = $__require('3');
  var SyntheticCompositionEvent = $__require('7');
  var SyntheticInputEvent = $__require('9');
  var END_KEYCODES = [9, 13, 27, 32];
  var START_KEYCODE = 229;
  var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }
  var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
  var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
  function isPresto() {
    var opera = window.opera;
    return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
  }
  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: 'onBeforeInput',
        captured: 'onBeforeInputCapture'
      },
      dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionEnd',
        captured: 'onCompositionEndCapture'
      },
      dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionStart',
        captured: 'onCompositionStartCapture'
      },
      dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionUpdate',
        captured: 'onCompositionUpdateCapture'
      },
      dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    }
  };
  var hasSpaceKeypress = false;
  function isKeypressCommand(nativeEvent) {
    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
  }
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case 'topCompositionStart':
        return eventTypes.compositionStart;
      case 'topCompositionEnd':
        return eventTypes.compositionEnd;
      case 'topCompositionUpdate':
        return eventTypes.compositionUpdate;
    }
  }
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
  }
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topKeyUp':
        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
      case 'topKeyDown':
        return nativeEvent.keyCode !== START_KEYCODE;
      case 'topKeyPress':
      case 'topMouseDown':
      case 'topBlur':
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }
  var currentComposition = null;
  function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var eventType;
    var fallbackData;
    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }
    if (!eventType) {
      return null;
    }
    if (useFallbackCompositionData) {
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          fallbackData = currentComposition.getData();
        }
      }
    }
    var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
    if (fallbackData) {
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topCompositionEnd':
        return getDataFromCustomEvent(nativeEvent);
      case 'topKeyPress':
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case 'topTextInput':
        var chars = nativeEvent.data;
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }
        return chars;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    if (currentComposition) {
      if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = currentComposition.getData();
        FallbackCompositionState.release(currentComposition);
        currentComposition = null;
        return chars;
      }
      return null;
    }
    switch (topLevelType) {
      case 'topPaste':
        return null;
      case 'topKeyPress':
        if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
          return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case 'topCompositionEnd':
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var chars;
    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }
    if (!chars) {
      return null;
    }
    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
    event.data = chars;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
    }
  };
  module.exports = BeforeInputEventPlugin;
});
$__System.registerDynamic('d', ['e', 'b', 'c', 'f', '10', '8', '11', '12', '13', '14', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var EventPluginHub = $__require('e');
    var EventPropagators = $__require('b');
    var ExecutionEnvironment = $__require('c');
    var ReactDOMComponentTree = $__require('f');
    var ReactUpdates = $__require('10');
    var SyntheticEvent = $__require('8');
    var inputValueTracking = $__require('11');
    var getEventTarget = $__require('12');
    var isEventSupported = $__require('13');
    var isTextInputElement = $__require('14');
    var eventTypes = { change: {
        phasedRegistrationNames: {
          bubbled: 'onChange',
          captured: 'onChangeCapture'
        },
        dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
      } };
    function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
      var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
      event.type = 'change';
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
    var activeElement = null;
    var activeElementInst = null;
    function shouldUseChangeEvent(elem) {
      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
    }
    var doesChangeEventBubble = false;
    if (ExecutionEnvironment.canUseDOM) {
      doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));
      ReactUpdates.batchedUpdates(runEventInBatch, event);
    }
    function runEventInBatch(event) {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue(false);
    }
    function startWatchingForChangeEventIE8(target, targetInst) {
      activeElement = target;
      activeElementInst = targetInst;
      activeElement.attachEvent('onchange', manualDispatchChangeEvent);
    }
    function stopWatchingForChangeEventIE8() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent('onchange', manualDispatchChangeEvent);
      activeElement = null;
      activeElementInst = null;
    }
    function getInstIfValueChanged(targetInst, nativeEvent) {
      var updated = inputValueTracking.updateValueIfChanged(targetInst);
      var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;
      if (updated || simulated) {
        return targetInst;
      }
    }
    function getTargetInstForChangeEvent(topLevelType, targetInst) {
      if (topLevelType === 'topChange') {
        return targetInst;
      }
    }
    function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
      if (topLevelType === 'topFocus') {
        stopWatchingForChangeEventIE8();
        startWatchingForChangeEventIE8(target, targetInst);
      } else if (topLevelType === 'topBlur') {
        stopWatchingForChangeEventIE8();
      }
    }
    var isInputEventSupported = false;
    if (ExecutionEnvironment.canUseDOM) {
      isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
    }
    function startWatchingForValueChange(target, targetInst) {
      activeElement = target;
      activeElementInst = targetInst;
      activeElement.attachEvent('onpropertychange', handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      if (!activeElement) {
        return;
      }
      activeElement.detachEvent('onpropertychange', handlePropertyChange);
      activeElement = null;
      activeElementInst = null;
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName !== 'value') {
        return;
      }
      if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
        manualDispatchChangeEvent(nativeEvent);
      }
    }
    function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
      if (topLevelType === 'topFocus') {
        stopWatchingForValueChange();
        startWatchingForValueChange(target, targetInst);
      } else if (topLevelType === 'topBlur') {
        stopWatchingForValueChange();
      }
    }
    function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
      if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
        return getInstIfValueChanged(activeElementInst, nativeEvent);
      }
    }
    function shouldUseClickEvent(elem) {
      var nodeName = elem.nodeName;
      return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
    }
    function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
      if (topLevelType === 'topClick') {
        return getInstIfValueChanged(targetInst, nativeEvent);
      }
    }
    function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
      if (topLevelType === 'topInput' || topLevelType === 'topChange') {
        return getInstIfValueChanged(targetInst, nativeEvent);
      }
    }
    function handleControlledInputBlur(inst, node) {
      if (inst == null) {
        return;
      }
      var state = inst._wrapperState || node._wrapperState;
      if (!state || !state.controlled || node.type !== 'number') {
        return;
      }
      var value = '' + node.value;
      if (node.getAttribute('value') !== value) {
        node.setAttribute('value', value);
      }
    }
    var ChangeEventPlugin = {
      eventTypes: eventTypes,
      _allowSimulatedPassThrough: true,
      _isInputEventSupported: isInputEventSupported,
      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) {
          if (doesChangeEventBubble) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else {
            handleEventFunc = handleEventsForChangeEventIE8;
          }
        } else if (isTextInputElement(targetNode)) {
          if (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          } else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } else if (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }
        if (getTargetInstFunc) {
          var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
          if (inst) {
            var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
            return event;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(topLevelType, targetNode, targetInst);
        }
        if (topLevelType === 'topBlur') {
          handleControlledInputBlur(targetInst, targetNode);
        }
      }
    };
    module.exports = ChangeEventPlugin;
  })($__require('15'));
});
$__System.registerDynamic('16', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Module that is injectable into `EventPluginHub`, that specifies a
   * deterministic ordering of `EventPlugin`s. A convenient way to reason about
   * plugins, without having to package every one of them. This is better than
   * having plugins be ordered in the same order that they are injected because
   * that ordering would be influenced by the packaging order.
   * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
   * preventing default on events is convenient in `SimpleEventPlugin` handlers.
   */

  var global = this || self,
      GLOBAL = global;
  var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

  module.exports = DefaultEventPluginOrder;
});
$__System.registerDynamic('17', ['b', 'f', '18'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('b');
  var ReactDOMComponentTree = $__require('f');
  var SyntheticMouseEvent = $__require('18');
  var eventTypes = {
    mouseEnter: {
      registrationName: 'onMouseEnter',
      dependencies: ['topMouseOut', 'topMouseOver']
    },
    mouseLeave: {
      registrationName: 'onMouseLeave',
      dependencies: ['topMouseOut', 'topMouseOver']
    }
  };
  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
        return null;
      }
      var win;
      if (nativeEventTarget.window === nativeEventTarget) {
        win = nativeEventTarget;
      } else {
        var doc = nativeEventTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }
      var from;
      var to;
      if (topLevelType === 'topMouseOut') {
        from = targetInst;
        var related = nativeEvent.relatedTarget || nativeEvent.toElement;
        to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
      } else {
        from = null;
        to = targetInst;
      }
      if (from === to) {
        return null;
      }
      var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
      var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
      var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
      leave.type = 'mouseleave';
      leave.target = fromNode;
      leave.relatedTarget = toNode;
      var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
      enter.type = 'mouseenter';
      enter.target = toNode;
      enter.relatedTarget = fromNode;
      EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
      return [leave, enter];
    }
  };
  module.exports = EnterLeaveEventPlugin;
});
$__System.registerDynamic('19', ['1a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('1a');
  var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
  var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var HTMLDOMPropertyConfig = {
    isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
    Properties: {
      accept: 0,
      acceptCharset: 0,
      accessKey: 0,
      action: 0,
      allowFullScreen: HAS_BOOLEAN_VALUE,
      allowTransparency: 0,
      alt: 0,
      as: 0,
      async: HAS_BOOLEAN_VALUE,
      autoComplete: 0,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: HAS_BOOLEAN_VALUE,
      cellPadding: 0,
      cellSpacing: 0,
      charSet: 0,
      challenge: 0,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      cite: 0,
      classID: 0,
      className: 0,
      cols: HAS_POSITIVE_NUMERIC_VALUE,
      colSpan: 0,
      content: 0,
      contentEditable: 0,
      contextMenu: 0,
      controls: HAS_BOOLEAN_VALUE,
      coords: 0,
      crossOrigin: 0,
      data: 0,
      dateTime: 0,
      'default': HAS_BOOLEAN_VALUE,
      defer: HAS_BOOLEAN_VALUE,
      dir: 0,
      disabled: HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: 0,
      encType: 0,
      form: 0,
      formAction: 0,
      formEncType: 0,
      formMethod: 0,
      formNoValidate: HAS_BOOLEAN_VALUE,
      formTarget: 0,
      frameBorder: 0,
      headers: 0,
      height: 0,
      hidden: HAS_BOOLEAN_VALUE,
      high: 0,
      href: 0,
      hrefLang: 0,
      htmlFor: 0,
      httpEquiv: 0,
      icon: 0,
      id: 0,
      inputMode: 0,
      integrity: 0,
      is: 0,
      keyParams: 0,
      keyType: 0,
      kind: 0,
      label: 0,
      lang: 0,
      list: 0,
      loop: HAS_BOOLEAN_VALUE,
      low: 0,
      manifest: 0,
      marginHeight: 0,
      marginWidth: 0,
      max: 0,
      maxLength: 0,
      media: 0,
      mediaGroup: 0,
      method: 0,
      min: 0,
      minLength: 0,
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      name: 0,
      nonce: 0,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      optimum: 0,
      pattern: 0,
      placeholder: 0,
      playsInline: HAS_BOOLEAN_VALUE,
      poster: 0,
      preload: 0,
      profile: 0,
      radioGroup: 0,
      readOnly: HAS_BOOLEAN_VALUE,
      referrerPolicy: 0,
      rel: 0,
      required: HAS_BOOLEAN_VALUE,
      reversed: HAS_BOOLEAN_VALUE,
      role: 0,
      rows: HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: HAS_NUMERIC_VALUE,
      sandbox: 0,
      scope: 0,
      scoped: HAS_BOOLEAN_VALUE,
      scrolling: 0,
      seamless: HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      shape: 0,
      size: HAS_POSITIVE_NUMERIC_VALUE,
      sizes: 0,
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: 0,
      src: 0,
      srcDoc: 0,
      srcLang: 0,
      srcSet: 0,
      start: HAS_NUMERIC_VALUE,
      step: 0,
      style: 0,
      summary: 0,
      tabIndex: 0,
      target: 0,
      title: 0,
      type: 0,
      useMap: 0,
      value: 0,
      width: 0,
      wmode: 0,
      wrap: 0,
      about: 0,
      datatype: 0,
      inlist: 0,
      prefix: 0,
      property: 0,
      resource: 0,
      'typeof': 0,
      vocab: 0,
      autoCapitalize: 0,
      autoCorrect: 0,
      autoSave: 0,
      color: 0,
      itemProp: 0,
      itemScope: HAS_BOOLEAN_VALUE,
      itemType: 0,
      itemID: 0,
      itemRef: 0,
      results: 0,
      security: 0,
      unselectable: 0
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMPropertyNames: {},
    DOMMutationMethods: { value: function (node, value) {
        if (value == null) {
          return node.removeAttribute('value');
        }
        if (node.type !== 'number' || node.hasAttribute('value') === false) {
          node.setAttribute('value', '' + value);
        } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
          node.setAttribute('value', '' + value);
        }
      } }
  };
  module.exports = HTMLDOMPropertyConfig;
});
$__System.registerDynamic('1b', ['1c', 'f', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMChildrenOperations = $__require('1c');
    var ReactDOMComponentTree = $__require('f');
    var ReactDOMIDOperations = { dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
        var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
        DOMChildrenOperations.processUpdates(node, updates);
      } };
    module.exports = ReactDOMIDOperations;
  })($__require('15'));
});
$__System.registerDynamic('1d', ['1c', '1b', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMChildrenOperations = $__require('1c');
    var ReactDOMIDOperations = $__require('1b');
    var ReactComponentBrowserEnvironment = {
      processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
      replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
    };
    module.exports = ReactComponentBrowserEnvironment;
  })($__require('15'));
});
$__System.registerDynamic('1e', ['f', '1f'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var ReactDOMComponentTree = $__require('f');
    var focusNode = $__require('1f');
    var AutoFocusUtils = { focusDOMComponent: function () {
            focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
        } };
    module.exports = AutoFocusUtils;
});
$__System.registerDynamic("20", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var global = this || self,
      GLOBAL = global;
  var _hyphenPattern = /-(.)/g;

  /**
   * Camelcases a hyphenated string, for example:
   *
   *   > camelize('background-color')
   *   < "backgroundColor"
   *
   * @param {string} string
   * @return {string}
   */
  function camelize(string) {
    return string.replace(_hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  }

  module.exports = camelize;
});
$__System.registerDynamic('21', ['20'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var camelize = $__require('20');
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }
  module.exports = camelizeStyleName;
});
$__System.registerDynamic('22', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * CSS properties which accept numbers but are not in units of "px".
   */

  var global = this || self,
      GLOBAL = global;
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,

    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };

  /**
   * @param {string} prefix vendor-specific prefix, eg: Webkit
   * @param {string} key style name, eg: transitionDuration
   * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
   * WebkitTransitionDuration
   */
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

  // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
  // infinite loop, because it iterates over the newly added props too.
  Object.keys(isUnitlessNumber).forEach(function (prop) {
    prefixes.forEach(function (prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });

  /**
   * Most style properties can be unset by doing .style[prop] = '' but IE8
   * doesn't like doing that with shorthand properties so for the properties that
   * IE8 breaks on, which are listed here, we instead unset each of the
   * individual properties. See http://bugs.jquery.com/ticket/12385.
   * The 4-value 'clock' properties like margin, padding, border-width seem to
   * behave without any problems. Curiously, list-style works too without any
   * special prodding.
   */
  var shorthandPropertyExpansions = {
    background: {
      backgroundAttachment: true,
      backgroundColor: true,
      backgroundImage: true,
      backgroundPositionX: true,
      backgroundPositionY: true,
      backgroundRepeat: true
    },
    backgroundPosition: {
      backgroundPositionX: true,
      backgroundPositionY: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    },
    outline: {
      outlineWidth: true,
      outlineStyle: true,
      outlineColor: true
    }
  };

  var CSSProperty = {
    isUnitlessNumber: isUnitlessNumber,
    shorthandPropertyExpansions: shorthandPropertyExpansions
  };

  module.exports = CSSProperty;
});
$__System.registerDynamic('23', ['22', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var CSSProperty = $__require('22');
    var warning = $__require('24');
    var isUnitlessNumber = CSSProperty.isUnitlessNumber;
    var styleWarnings = {};
    function dangerousStyleValue(name, value, component, isCustomProperty) {
      var isEmpty = value == null || typeof value === 'boolean' || value === '';
      if (isEmpty) {
        return '';
      }
      var isNonNumeric = isNaN(value);
      if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
        return '' + value;
      }
      if (typeof value === 'string') {
        if ('production' !== 'production') {
          if (component && value !== '0') {
            var owner = component._currentElement._owner;
            var ownerName = owner ? owner.getName() : null;
            if (ownerName && !styleWarnings[ownerName]) {
              styleWarnings[ownerName] = {};
            }
            var warned = false;
            if (ownerName) {
              var warnings = styleWarnings[ownerName];
              warned = warnings[name];
              if (!warned) {
                warnings[name] = true;
              }
            }
            if (!warned) {
              'production' !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
            }
          }
        }
        value = value.trim();
      }
      return value + 'px';
    }
    module.exports = dangerousStyleValue;
  })($__require('15'));
});
$__System.registerDynamic('25', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  var global = this || self,
      GLOBAL = global;
  var _uppercasePattern = /([A-Z])/g;

  /**
   * Hyphenates a camelcased string, for example:
   *
   *   > hyphenate('backgroundColor')
   *   < "background-color"
   *
   * For CSS style names, use `hyphenateStyleName` instead which works properly
   * with all vendor prefixes, including `ms`.
   *
   * @param {string} string
   * @return {string}
   */
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }

  module.exports = hyphenate;
});
$__System.registerDynamic('26', ['25'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var hyphenate = $__require('25');
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }
  module.exports = hyphenateStyleName;
});
$__System.registerDynamic('27', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   * @typechecks static-only
   */

  'use strict';

  /**
   * Memoizes the return value of a function that accepts one string argument.
   */

  var global = this || self,
      GLOBAL = global;
  function memoizeStringOnly(callback) {
    var cache = {};
    return function (string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }

  module.exports = memoizeStringOnly;
});
$__System.registerDynamic('28', ['22', 'c', '29', '21', '23', '26', '27', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var CSSProperty = $__require('22');
    var ExecutionEnvironment = $__require('c');
    var ReactInstrumentation = $__require('29');
    var camelizeStyleName = $__require('21');
    var dangerousStyleValue = $__require('23');
    var hyphenateStyleName = $__require('26');
    var memoizeStringOnly = $__require('27');
    var warning = $__require('24');
    var processStyleName = memoizeStringOnly(function (styleName) {
      return hyphenateStyleName(styleName);
    });
    var hasShorthandPropertyBug = false;
    var styleFloatAccessor = 'cssFloat';
    if (ExecutionEnvironment.canUseDOM) {
      var tempStyle = document.createElement('div').style;
      try {
        tempStyle.font = '';
      } catch (e) {
        hasShorthandPropertyBug = true;
      }
      if (document.documentElement.style.cssFloat === undefined) {
        styleFloatAccessor = 'styleFloat';
      }
    }
    if ('production' !== 'production') {
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
      var badStyleValueWithSemicolonPattern = /;\s*$/;
      var warnedStyleNames = {};
      var warnedStyleValues = {};
      var warnedForNaNValue = false;
      var warnHyphenatedStyleName = function (name, owner) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        'production' !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
      };
      var warnBadVendoredStyleName = function (name, owner) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
          return;
        }
        warnedStyleNames[name] = true;
        'production' !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
      };
      var warnStyleValueWithSemicolon = function (name, value, owner) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
          return;
        }
        warnedStyleValues[value] = true;
        'production' !== 'production' ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
      };
      var warnStyleValueIsNaN = function (name, value, owner) {
        if (warnedForNaNValue) {
          return;
        }
        warnedForNaNValue = true;
        'production' !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
      };
      var checkRenderMessage = function (owner) {
        if (owner) {
          var name = owner.getName();
          if (name) {
            return ' Check the render method of `' + name + '`.';
          }
        }
        return '';
      };
      var warnValidStyle = function (name, value, component) {
        var owner;
        if (component) {
          owner = component._currentElement._owner;
        }
        if (name.indexOf('-') > -1) {
          warnHyphenatedStyleName(name, owner);
        } else if (badVendoredStyleNamePattern.test(name)) {
          warnBadVendoredStyleName(name, owner);
        } else if (badStyleValueWithSemicolonPattern.test(value)) {
          warnStyleValueWithSemicolon(name, value, owner);
        }
        if (typeof value === 'number' && isNaN(value)) {
          warnStyleValueIsNaN(name, value, owner);
        }
      };
    }
    var CSSPropertyOperations = {
      createMarkupForStyles: function (styles, component) {
        var serialized = '';
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf('--') === 0;
          var styleValue = styles[styleName];
          if ('production' !== 'production') {
            if (!isCustomProperty) {
              warnValidStyle(styleName, styleValue, component);
            }
          }
          if (styleValue != null) {
            serialized += processStyleName(styleName) + ':';
            serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
          }
        }
        return serialized || null;
      },
      setValueForStyles: function (node, styles, component) {
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: component._debugID,
            type: 'update styles',
            payload: styles
          });
        }
        var style = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf('--') === 0;
          if ('production' !== 'production') {
            if (!isCustomProperty) {
              warnValidStyle(styleName, styles[styleName], component);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
          if (styleName === 'float' || styleName === 'cssFloat') {
            styleName = styleFloatAccessor;
          }
          if (isCustomProperty) {
            style.setProperty(styleName, styleValue);
          } else if (styleValue) {
            style[styleName] = styleValue;
          } else {
            var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
            if (expansion) {
              for (var individualStyleName in expansion) {
                style[individualStyleName] = '';
              }
            } else {
              style[styleName] = '';
            }
          }
        }
      }
    };
    module.exports = CSSPropertyOperations;
  })($__require('15'));
});
$__System.registerDynamic('2a', ['2b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var escapeTextContentForBrowser = $__require('2b');
  function quoteAttributeValueForBrowser(value) {
    return '"' + escapeTextContentForBrowser(value) + '"';
  }
  module.exports = quoteAttributeValueForBrowser;
});
$__System.registerDynamic('2c', ['1a', 'f', '29', '2a', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMProperty = $__require('1a');
    var ReactDOMComponentTree = $__require('f');
    var ReactInstrumentation = $__require('29');
    var quoteAttributeValueForBrowser = $__require('2a');
    var warning = $__require('24');
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
        return true;
      }
      if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
        return false;
      }
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
        validatedAttributeNameCache[attributeName] = true;
        return true;
      }
      illegalAttributeNameCache[attributeName] = true;
      'production' !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
      return false;
    }
    function shouldIgnoreValue(propertyInfo, value) {
      return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
    }
    var DOMPropertyOperations = {
      createMarkupForID: function (id) {
        return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
      },
      setAttributeForID: function (node, id) {
        node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
      },
      createMarkupForRoot: function () {
        return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
      },
      setAttributeForRoot: function (node) {
        node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
      },
      createMarkupForProperty: function (name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          if (shouldIgnoreValue(propertyInfo, value)) {
            return '';
          }
          var attributeName = propertyInfo.attributeName;
          if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
            return attributeName + '=""';
          }
          return attributeName + '=' + quoteAttributeValueForBrowser(value);
        } else if (DOMProperty.isCustomAttribute(name)) {
          if (value == null) {
            return '';
          }
          return name + '=' + quoteAttributeValueForBrowser(value);
        }
        return null;
      },
      createMarkupForCustomAttribute: function (name, value) {
        if (!isAttributeNameSafe(name) || value == null) {
          return '';
        }
        return name + '=' + quoteAttributeValueForBrowser(value);
      },
      setValueForProperty: function (node, name, value) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, value);
          } else if (shouldIgnoreValue(propertyInfo, value)) {
            this.deleteValueForProperty(node, name);
            return;
          } else if (propertyInfo.mustUseProperty) {
            node[propertyInfo.propertyName] = value;
          } else {
            var attributeName = propertyInfo.attributeName;
            var namespace = propertyInfo.attributeNamespace;
            if (namespace) {
              node.setAttributeNS(namespace, attributeName, '' + value);
            } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
              node.setAttribute(attributeName, '');
            } else {
              node.setAttribute(attributeName, '' + value);
            }
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          DOMPropertyOperations.setValueForAttribute(node, name, value);
          return;
        }
        if ('production' !== 'production') {
          var payload = {};
          payload[name] = value;
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'update attribute',
            payload: payload
          });
        }
      },
      setValueForAttribute: function (node, name, value) {
        if (!isAttributeNameSafe(name)) {
          return;
        }
        if (value == null) {
          node.removeAttribute(name);
        } else {
          node.setAttribute(name, '' + value);
        }
        if ('production' !== 'production') {
          var payload = {};
          payload[name] = value;
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'update attribute',
            payload: payload
          });
        }
      },
      deleteValueForAttribute: function (node, name) {
        node.removeAttribute(name);
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'remove attribute',
            payload: name
          });
        }
      },
      deleteValueForProperty: function (node, name) {
        var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
        if (propertyInfo) {
          var mutationMethod = propertyInfo.mutationMethod;
          if (mutationMethod) {
            mutationMethod(node, undefined);
          } else if (propertyInfo.mustUseProperty) {
            var propName = propertyInfo.propertyName;
            if (propertyInfo.hasBooleanValue) {
              node[propName] = false;
            } else {
              node[propName] = '';
            }
          } else {
            node.removeAttribute(propertyInfo.attributeName);
          }
        } else if (DOMProperty.isCustomAttribute(name)) {
          node.removeAttribute(name);
        }
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
            type: 'remove attribute',
            payload: name
          });
        }
      }
    };
    module.exports = DOMPropertyOperations;
  })($__require('15'));
});
$__System.registerDynamic('2d', ['2e', '6', '2c', '2f', 'f', '10', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e'),
        _assign = $__require('6');
    var DOMPropertyOperations = $__require('2c');
    var LinkedValueUtils = $__require('2f');
    var ReactDOMComponentTree = $__require('f');
    var ReactUpdates = $__require('10');
    var invariant = $__require('30');
    var warning = $__require('24');
    var didWarnValueLink = false;
    var didWarnCheckedLink = false;
    var didWarnValueDefaultValue = false;
    var didWarnCheckedDefaultChecked = false;
    var didWarnControlledToUncontrolled = false;
    var didWarnUncontrolledToControlled = false;
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMInput.updateWrapper(this);
      }
    }
    function isControlled(props) {
      var usesChecked = props.type === 'checkbox' || props.type === 'radio';
      return usesChecked ? props.checked != null : props.value != null;
    }
    var ReactDOMInput = {
      getHostProps: function (inst, props) {
        var value = LinkedValueUtils.getValue(props);
        var checked = LinkedValueUtils.getChecked(props);
        var hostProps = _assign({
          type: undefined,
          step: undefined,
          min: undefined,
          max: undefined
        }, props, {
          defaultChecked: undefined,
          defaultValue: undefined,
          value: value != null ? value : inst._wrapperState.initialValue,
          checked: checked != null ? checked : inst._wrapperState.initialChecked,
          onChange: inst._wrapperState.onChange
        });
        return hostProps;
      },
      mountWrapper: function (inst, props) {
        if ('production' !== 'production') {
          LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
          var owner = inst._currentElement._owner;
          if (props.valueLink !== undefined && !didWarnValueLink) {
            'production' !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
            didWarnValueLink = true;
          }
          if (props.checkedLink !== undefined && !didWarnCheckedLink) {
            'production' !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
            didWarnCheckedLink = true;
          }
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
            'production' !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnCheckedDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
            'production' !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnValueDefaultValue = true;
          }
        }
        var defaultValue = props.defaultValue;
        inst._wrapperState = {
          initialChecked: props.checked != null ? props.checked : props.defaultChecked,
          initialValue: props.value != null ? props.value : defaultValue,
          listeners: null,
          onChange: _handleChange.bind(inst),
          controlled: isControlled(props)
        };
      },
      updateWrapper: function (inst) {
        var props = inst._currentElement.props;
        if ('production' !== 'production') {
          var controlled = isControlled(props);
          var owner = inst._currentElement._owner;
          if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            'production' !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnUncontrolledToControlled = true;
          }
          if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            'production' !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
            didWarnControlledToUncontrolled = true;
          }
        }
        var checked = props.checked;
        if (checked != null) {
          DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
        }
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          if (value === 0 && node.value === '') {
            node.value = '0';
          } else if (props.type === 'number') {
            var valueAsNumber = parseFloat(node.value, 10) || 0;
            if (value != valueAsNumber || value == valueAsNumber && node.value != value) {
              node.value = '' + value;
            }
          } else if (node.value !== '' + value) {
            node.value = '' + value;
          }
        } else {
          if (props.value == null && props.defaultValue != null) {
            if (node.defaultValue !== '' + props.defaultValue) {
              node.defaultValue = '' + props.defaultValue;
            }
          }
          if (props.checked == null && props.defaultChecked != null) {
            node.defaultChecked = !!props.defaultChecked;
          }
        }
      },
      postMountWrapper: function (inst) {
        var props = inst._currentElement.props;
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        switch (props.type) {
          case 'submit':
          case 'reset':
            break;
          case 'color':
          case 'date':
          case 'datetime':
          case 'datetime-local':
          case 'month':
          case 'time':
          case 'week':
            node.value = '';
            node.value = node.defaultValue;
            break;
          default:
            node.value = node.value;
            break;
        }
        var name = node.name;
        if (name !== '') {
          node.name = '';
        }
        node.defaultChecked = !node.defaultChecked;
        node.defaultChecked = !node.defaultChecked;
        if (name !== '') {
          node.name = name;
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      var name = props.name;
      if (props.type === 'radio' && name != null) {
        var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
        var queryRoot = rootNode;
        while (queryRoot.parentNode) {
          queryRoot = queryRoot.parentNode;
        }
        var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
        for (var i = 0; i < group.length; i++) {
          var otherNode = group[i];
          if (otherNode === rootNode || otherNode.form !== rootNode.form) {
            continue;
          }
          var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
          !otherInstance ? 'production' !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
          ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
        }
      }
      return returnValue;
    }
    module.exports = ReactDOMInput;
  })($__require('15'));
});
$__System.registerDynamic('31', ['6', '33', 'f', '32', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var React = $__require('33');
    var ReactDOMComponentTree = $__require('f');
    var ReactDOMSelect = $__require('32');
    var warning = $__require('24');
    var didWarnInvalidOptionChildren = false;
    function flattenChildren(children) {
      var content = '';
      React.Children.forEach(children, function (child) {
        if (child == null) {
          return;
        }
        if (typeof child === 'string' || typeof child === 'number') {
          content += child;
        } else if (!didWarnInvalidOptionChildren) {
          didWarnInvalidOptionChildren = true;
          'production' !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
        }
      });
      return content;
    }
    var ReactDOMOption = {
      mountWrapper: function (inst, props, hostParent) {
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
        }
        var selectValue = null;
        if (hostParent != null) {
          var selectParent = hostParent;
          if (selectParent._tag === 'optgroup') {
            selectParent = selectParent._hostParent;
          }
          if (selectParent != null && selectParent._tag === 'select') {
            selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
          }
        }
        var selected = null;
        if (selectValue != null) {
          var value;
          if (props.value != null) {
            value = props.value + '';
          } else {
            value = flattenChildren(props.children);
          }
          selected = false;
          if (Array.isArray(selectValue)) {
            for (var i = 0; i < selectValue.length; i++) {
              if ('' + selectValue[i] === value) {
                selected = true;
                break;
              }
            }
          } else {
            selected = '' + selectValue === value;
          }
        }
        inst._wrapperState = { selected: selected };
      },
      postMountWrapper: function (inst) {
        var props = inst._currentElement.props;
        if (props.value != null) {
          var node = ReactDOMComponentTree.getNodeFromInstance(inst);
          node.setAttribute('value', props.value);
        }
      },
      getHostProps: function (inst, props) {
        var hostProps = _assign({
          selected: undefined,
          children: undefined
        }, props);
        if (inst._wrapperState.selected != null) {
          hostProps.selected = inst._wrapperState.selected;
        }
        var content = flattenChildren(props.children);
        if (content) {
          hostProps.children = content;
        }
        return hostProps;
      }
    };
    module.exports = ReactDOMOption;
  })($__require('15'));
});
$__System.registerDynamic('32', ['6', '2f', 'f', '10', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var LinkedValueUtils = $__require('2f');
    var ReactDOMComponentTree = $__require('f');
    var ReactUpdates = $__require('10');
    var warning = $__require('24');
    var didWarnValueLink = false;
    var didWarnValueDefaultValue = false;
    function updateOptionsIfPendingUpdateAndMounted() {
      if (this._rootNodeID && this._wrapperState.pendingUpdate) {
        this._wrapperState.pendingUpdate = false;
        var props = this._currentElement.props;
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          updateOptions(this, Boolean(props.multiple), value);
        }
      }
    }
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var valuePropNames = ['value', 'defaultValue'];
    function checkSelectPropTypes(inst, props) {
      var owner = inst._currentElement._owner;
      LinkedValueUtils.checkPropTypes('select', props, owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        'production' !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      for (var i = 0; i < valuePropNames.length; i++) {
        var propName = valuePropNames[i];
        if (props[propName] == null) {
          continue;
        }
        var isArray = Array.isArray(props[propName]);
        if (props.multiple && !isArray) {
          'production' !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
        } else if (!props.multiple && isArray) {
          'production' !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
        }
      }
    }
    function updateOptions(inst, multiple, propValue) {
      var selectedValue, i;
      var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
      if (multiple) {
        selectedValue = {};
        for (i = 0; i < propValue.length; i++) {
          selectedValue['' + propValue[i]] = true;
        }
        for (i = 0; i < options.length; i++) {
          var selected = selectedValue.hasOwnProperty(options[i].value);
          if (options[i].selected !== selected) {
            options[i].selected = selected;
          }
        }
      } else {
        selectedValue = '' + propValue;
        for (i = 0; i < options.length; i++) {
          if (options[i].value === selectedValue) {
            options[i].selected = true;
            return;
          }
        }
        if (options.length) {
          options[0].selected = true;
        }
      }
    }
    var ReactDOMSelect = {
      getHostProps: function (inst, props) {
        return _assign({}, props, {
          onChange: inst._wrapperState.onChange,
          value: undefined
        });
      },
      mountWrapper: function (inst, props) {
        if ('production' !== 'production') {
          checkSelectPropTypes(inst, props);
        }
        var value = LinkedValueUtils.getValue(props);
        inst._wrapperState = {
          pendingUpdate: false,
          initialValue: value != null ? value : props.defaultValue,
          listeners: null,
          onChange: _handleChange.bind(inst),
          wasMultiple: Boolean(props.multiple)
        };
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
          'production' !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
          didWarnValueDefaultValue = true;
        }
      },
      getSelectValueContext: function (inst) {
        return inst._wrapperState.initialValue;
      },
      postUpdateWrapper: function (inst) {
        var props = inst._currentElement.props;
        inst._wrapperState.initialValue = undefined;
        var wasMultiple = inst._wrapperState.wasMultiple;
        inst._wrapperState.wasMultiple = Boolean(props.multiple);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          inst._wrapperState.pendingUpdate = false;
          updateOptions(inst, Boolean(props.multiple), value);
        } else if (wasMultiple !== Boolean(props.multiple)) {
          if (props.defaultValue != null) {
            updateOptions(inst, Boolean(props.multiple), props.defaultValue);
          } else {
            updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
          }
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      if (this._rootNodeID) {
        this._wrapperState.pendingUpdate = true;
      }
      ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMSelect;
  })($__require('15'));
});
$__System.registerDynamic('2f', ['2e', '34', '35', '33', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var ReactPropTypesSecret = $__require('34');
    var propTypesFactory = $__require('35');
    var React = $__require('33');
    var PropTypes = propTypesFactory(React.isValidElement);
    var invariant = $__require('30');
    var warning = $__require('24');
    var hasReadOnlyValue = {
      button: true,
      checkbox: true,
      image: true,
      hidden: true,
      radio: true,
      reset: true,
      submit: true
    };
    function _assertSingleLink(inputProps) {
      !(inputProps.checkedLink == null || inputProps.valueLink == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
    }
    function _assertValueLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.value == null && inputProps.onChange == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
    }
    function _assertCheckedLink(inputProps) {
      _assertSingleLink(inputProps);
      !(inputProps.checked == null && inputProps.onChange == null) ? 'production' !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
    }
    var propTypes = {
      value: function (props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      checked: function (props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      onChange: PropTypes.func
    };
    var loggedTypeFailures = {};
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    var LinkedValueUtils = {
      checkPropTypes: function (tagName, props, owner) {
        for (var propName in propTypes) {
          if (propTypes.hasOwnProperty(propName)) {
            var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
          }
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var addendum = getDeclarationErrorAddendum(owner);
            'production' !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
          }
        }
      },
      getValue: function (inputProps) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.value;
        }
        return inputProps.value;
      },
      getChecked: function (inputProps) {
        if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.value;
        }
        return inputProps.checked;
      },
      executeOnChange: function (inputProps, event) {
        if (inputProps.valueLink) {
          _assertValueLink(inputProps);
          return inputProps.valueLink.requestChange(event.target.value);
        } else if (inputProps.checkedLink) {
          _assertCheckedLink(inputProps);
          return inputProps.checkedLink.requestChange(event.target.checked);
        } else if (inputProps.onChange) {
          return inputProps.onChange.call(undefined, event);
        }
      }
    };
    module.exports = LinkedValueUtils;
  })($__require('15'));
});
$__System.registerDynamic('36', ['2e', '6', '2f', 'f', '10', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e'),
        _assign = $__require('6');
    var LinkedValueUtils = $__require('2f');
    var ReactDOMComponentTree = $__require('f');
    var ReactUpdates = $__require('10');
    var invariant = $__require('30');
    var warning = $__require('24');
    var didWarnValueLink = false;
    var didWarnValDefaultVal = false;
    function forceUpdateIfMounted() {
      if (this._rootNodeID) {
        ReactDOMTextarea.updateWrapper(this);
      }
    }
    var ReactDOMTextarea = {
      getHostProps: function (inst, props) {
        !(props.dangerouslySetInnerHTML == null) ? 'production' !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
        var hostProps = _assign({}, props, {
          value: undefined,
          defaultValue: undefined,
          children: '' + inst._wrapperState.initialValue,
          onChange: inst._wrapperState.onChange
        });
        return hostProps;
      },
      mountWrapper: function (inst, props) {
        if ('production' !== 'production') {
          LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
          if (props.valueLink !== undefined && !didWarnValueLink) {
            'production' !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
            didWarnValueLink = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
            'production' !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
            didWarnValDefaultVal = true;
          }
        }
        var value = LinkedValueUtils.getValue(props);
        var initialValue = value;
        if (value == null) {
          var defaultValue = props.defaultValue;
          var children = props.children;
          if (children != null) {
            if ('production' !== 'production') {
              'production' !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
            }
            !(defaultValue == null) ? 'production' !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
            if (Array.isArray(children)) {
              !(children.length <= 1) ? 'production' !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
              children = children[0];
            }
            defaultValue = '' + children;
          }
          if (defaultValue == null) {
            defaultValue = '';
          }
          initialValue = defaultValue;
        }
        inst._wrapperState = {
          initialValue: '' + initialValue,
          listeners: null,
          onChange: _handleChange.bind(inst)
        };
      },
      updateWrapper: function (inst) {
        var props = inst._currentElement.props;
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var value = LinkedValueUtils.getValue(props);
        if (value != null) {
          var newValue = '' + value;
          if (newValue !== node.value) {
            node.value = newValue;
          }
          if (props.defaultValue == null) {
            node.defaultValue = newValue;
          }
        }
        if (props.defaultValue != null) {
          node.defaultValue = props.defaultValue;
        }
      },
      postMountWrapper: function (inst) {
        var node = ReactDOMComponentTree.getNodeFromInstance(inst);
        var textContent = node.textContent;
        if (textContent === inst._wrapperState.initialValue) {
          node.value = textContent;
        }
      }
    };
    function _handleChange(event) {
      var props = this._currentElement.props;
      var returnValue = LinkedValueUtils.executeOnChange(props, event);
      ReactUpdates.asap(forceUpdateIfMounted, this);
      return returnValue;
    }
    module.exports = ReactDOMTextarea;
  })($__require('15'));
});
$__System.registerDynamic('37', ['38', '39', '3a', '3b', '3c', '24', '3d', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactReconciler = $__require('38');
    var instantiateReactComponent = $__require('39');
    var KeyEscapeUtils = $__require('3a');
    var shouldUpdateReactComponent = $__require('3b');
    var traverseAllChildren = $__require('3c');
    var warning = $__require('24');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('3d');
    }
    function instantiateChild(childInstances, child, name, selfDebugID) {
      var keyUnique = childInstances[name] === undefined;
      if ('production' !== 'production') {
        if (!ReactComponentTreeHook) {
          ReactComponentTreeHook = $__require('3d');
        }
        if (!keyUnique) {
          'production' !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
        }
      }
      if (child != null && keyUnique) {
        childInstances[name] = instantiateReactComponent(child, true);
      }
    }
    var ReactChildReconciler = {
      instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) {
        if (nestedChildNodes == null) {
          return null;
        }
        var childInstances = {};
        if ('production' !== 'production') {
          traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
            return instantiateChild(childInsts, child, name, selfDebugID);
          }, childInstances);
        } else {
          traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
        }
        return childInstances;
      },
      updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) {
        if (!nextChildren && !prevChildren) {
          return;
        }
        var name;
        var prevChild;
        for (name in nextChildren) {
          if (!nextChildren.hasOwnProperty(name)) {
            continue;
          }
          prevChild = prevChildren && prevChildren[name];
          var prevElement = prevChild && prevChild._currentElement;
          var nextElement = nextChildren[name];
          if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
            ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
            nextChildren[name] = prevChild;
          } else {
            if (prevChild) {
              removedNodes[name] = ReactReconciler.getHostNode(prevChild);
              ReactReconciler.unmountComponent(prevChild, false);
            }
            var nextChildInstance = instantiateReactComponent(nextElement, true);
            nextChildren[name] = nextChildInstance;
            var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
            mountImages.push(nextChildMountImage);
          }
        }
        for (name in prevChildren) {
          if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
            prevChild = prevChildren[name];
            removedNodes[name] = ReactReconciler.getHostNode(prevChild);
            ReactReconciler.unmountComponent(prevChild, false);
          }
        }
      },
      unmountChildren: function (renderedChildren, safely) {
        for (var name in renderedChildren) {
          if (renderedChildren.hasOwnProperty(name)) {
            var renderedChild = renderedChildren[name];
            ReactReconciler.unmountComponent(renderedChild, safely);
          }
        }
      }
    };
    module.exports = ReactChildReconciler;
  })($__require('15'));
});
$__System.registerDynamic('3e', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  // The Symbol used to tag the ReactElement type. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.

  var global = this || self,
      GLOBAL = global;
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

  module.exports = REACT_ELEMENT_TYPE;
});
$__System.registerDynamic('3f', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /* global Symbol */

  var global = this || self,
      GLOBAL = global;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  module.exports = getIteratorFn;
});
$__System.registerDynamic('3a', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */

  var global = this || self,
      GLOBAL = global;
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });

    return '$' + escapedString;
  }

  /**
   * Unescape and unwrap key for human-readable display
   *
   * @param {string} key to unescape.
   * @return {string} the unescaped key.
   */
  function unescape(key) {
    var unescapeRegex = /(=0|=2)/g;
    var unescaperLookup = {
      '=0': '=',
      '=2': ':'
    };
    var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

    return ('' + keySubstring).replace(unescapeRegex, function (match) {
      return unescaperLookup[match];
    });
  }

  var KeyEscapeUtils = {
    escape: escape,
    unescape: unescape
  };

  module.exports = KeyEscapeUtils;
});
$__System.registerDynamic('3c', ['2e', '40', '3e', '3f', '30', '3a', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var ReactCurrentOwner = $__require('40');
    var REACT_ELEMENT_TYPE = $__require('3e');
    var getIteratorFn = $__require('3f');
    var invariant = $__require('30');
    var KeyEscapeUtils = $__require('3a');
    var warning = $__require('24');
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
      if (component && typeof component === 'object' && component.key != null) {
        return KeyEscapeUtils.escape(component.key);
      }
      return index.toString(36);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;
      if (type === 'undefined' || type === 'boolean') {
        children = null;
      }
      if (children === null || type === 'string' || type === 'number' || type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
        callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            if ('production' !== 'production') {
              var mapsAsChildrenAddendum = '';
              if (ReactCurrentOwner.current) {
                var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                if (mapsAsChildrenOwnerName) {
                  mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                }
              }
              'production' !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            }
          }
        } else if (type === 'object') {
          var addendum = '';
          if ('production' !== 'production') {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
            if (children._isReactElement) {
              addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
            }
            if (ReactCurrentOwner.current) {
              var name = ReactCurrentOwner.current.getName();
              if (name) {
                addendum += ' Check the render method of `' + name + '`.';
              }
            }
          }
          var childrenString = String(children);
          !false ? 'production' !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })($__require('15'));
});
$__System.registerDynamic('41', ['3a', '3c', '24', '3d', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var KeyEscapeUtils = $__require('3a');
    var traverseAllChildren = $__require('3c');
    var warning = $__require('24');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('3d');
    }
    function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
      if (traverseContext && typeof traverseContext === 'object') {
        var result = traverseContext;
        var keyUnique = result[name] === undefined;
        if ('production' !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = $__require('3d');
          }
          if (!keyUnique) {
            'production' !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
          }
        }
        if (keyUnique && child != null) {
          result[name] = child;
        }
      }
    }
    function flattenChildren(children, selfDebugID) {
      if (children == null) {
        return children;
      }
      var result = {};
      if ('production' !== 'production') {
        traverseAllChildren(children, function (traverseContext, child, name) {
          return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
        }, result);
      } else {
        traverseAllChildren(children, flattenSingleChildIntoContext, result);
      }
      return result;
    }
    module.exports = flattenChildren;
  })($__require('15'));
});
$__System.registerDynamic('42', ['2e', '43', '44', '29', '40', '38', '37', '45', '41', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var ReactComponentEnvironment = $__require('43');
    var ReactInstanceMap = $__require('44');
    var ReactInstrumentation = $__require('29');
    var ReactCurrentOwner = $__require('40');
    var ReactReconciler = $__require('38');
    var ReactChildReconciler = $__require('37');
    var emptyFunction = $__require('45');
    var flattenChildren = $__require('41');
    var invariant = $__require('30');
    function makeInsertMarkup(markup, afterNode, toIndex) {
      return {
        type: 'INSERT_MARKUP',
        content: markup,
        fromIndex: null,
        fromNode: null,
        toIndex: toIndex,
        afterNode: afterNode
      };
    }
    function makeMove(child, afterNode, toIndex) {
      return {
        type: 'MOVE_EXISTING',
        content: null,
        fromIndex: child._mountIndex,
        fromNode: ReactReconciler.getHostNode(child),
        toIndex: toIndex,
        afterNode: afterNode
      };
    }
    function makeRemove(child, node) {
      return {
        type: 'REMOVE_NODE',
        content: null,
        fromIndex: child._mountIndex,
        fromNode: node,
        toIndex: null,
        afterNode: null
      };
    }
    function makeSetMarkup(markup) {
      return {
        type: 'SET_MARKUP',
        content: markup,
        fromIndex: null,
        fromNode: null,
        toIndex: null,
        afterNode: null
      };
    }
    function makeTextContent(textContent) {
      return {
        type: 'TEXT_CONTENT',
        content: textContent,
        fromIndex: null,
        fromNode: null,
        toIndex: null,
        afterNode: null
      };
    }
    function enqueue(queue, update) {
      if (update) {
        queue = queue || [];
        queue.push(update);
      }
      return queue;
    }
    function processQueue(inst, updateQueue) {
      ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
    }
    var setChildrenForInstrumentation = emptyFunction;
    if ('production' !== 'production') {
      var getDebugID = function (inst) {
        if (!inst._debugID) {
          var internal;
          if (internal = ReactInstanceMap.get(inst)) {
            inst = internal;
          }
        }
        return inst._debugID;
      };
      setChildrenForInstrumentation = function (children) {
        var debugID = getDebugID(this);
        if (debugID !== 0) {
          ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
            return children[key]._debugID;
          }) : []);
        }
      };
    }
    var ReactMultiChild = { Mixin: {
        _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
          if ('production' !== 'production') {
            var selfDebugID = getDebugID(this);
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
              } finally {
                ReactCurrentOwner.current = null;
              }
            }
          }
          return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
        },
        _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
          var nextChildren;
          var selfDebugID = 0;
          if ('production' !== 'production') {
            selfDebugID = getDebugID(this);
            if (this._currentElement) {
              try {
                ReactCurrentOwner.current = this._currentElement._owner;
                nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
              } finally {
                ReactCurrentOwner.current = null;
              }
              ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
              return nextChildren;
            }
          }
          nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        },
        mountChildren: function (nestedChildren, transaction, context) {
          var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
          this._renderedChildren = children;
          var mountImages = [];
          var index = 0;
          for (var name in children) {
            if (children.hasOwnProperty(name)) {
              var child = children[name];
              var selfDebugID = 0;
              if ('production' !== 'production') {
                selfDebugID = getDebugID(this);
              }
              var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
              child._mountIndex = index++;
              mountImages.push(mountImage);
            }
          }
          if ('production' !== 'production') {
            setChildrenForInstrumentation.call(this, children);
          }
          return mountImages;
        },
        updateTextContent: function (nextContent) {
          var prevChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(prevChildren, false);
          for (var name in prevChildren) {
            if (prevChildren.hasOwnProperty(name)) {
              !false ? 'production' !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
            }
          }
          var updates = [makeTextContent(nextContent)];
          processQueue(this, updates);
        },
        updateMarkup: function (nextMarkup) {
          var prevChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(prevChildren, false);
          for (var name in prevChildren) {
            if (prevChildren.hasOwnProperty(name)) {
              !false ? 'production' !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
            }
          }
          var updates = [makeSetMarkup(nextMarkup)];
          processQueue(this, updates);
        },
        updateChildren: function (nextNestedChildrenElements, transaction, context) {
          this._updateChildren(nextNestedChildrenElements, transaction, context);
        },
        _updateChildren: function (nextNestedChildrenElements, transaction, context) {
          var prevChildren = this._renderedChildren;
          var removedNodes = {};
          var mountImages = [];
          var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
          if (!nextChildren && !prevChildren) {
            return;
          }
          var updates = null;
          var name;
          var nextIndex = 0;
          var lastIndex = 0;
          var nextMountIndex = 0;
          var lastPlacedNode = null;
          for (name in nextChildren) {
            if (!nextChildren.hasOwnProperty(name)) {
              continue;
            }
            var prevChild = prevChildren && prevChildren[name];
            var nextChild = nextChildren[name];
            if (prevChild === nextChild) {
              updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
              lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              prevChild._mountIndex = nextIndex;
            } else {
              if (prevChild) {
                lastIndex = Math.max(prevChild._mountIndex, lastIndex);
              }
              updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
              nextMountIndex++;
            }
            nextIndex++;
            lastPlacedNode = ReactReconciler.getHostNode(nextChild);
          }
          for (name in removedNodes) {
            if (removedNodes.hasOwnProperty(name)) {
              updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
            }
          }
          if (updates) {
            processQueue(this, updates);
          }
          this._renderedChildren = nextChildren;
          if ('production' !== 'production') {
            setChildrenForInstrumentation.call(this, nextChildren);
          }
        },
        unmountChildren: function (safely) {
          var renderedChildren = this._renderedChildren;
          ReactChildReconciler.unmountChildren(renderedChildren, safely);
          this._renderedChildren = null;
        },
        moveChild: function (child, afterNode, toIndex, lastIndex) {
          if (child._mountIndex < lastIndex) {
            return makeMove(child, afterNode, toIndex);
          }
        },
        createChild: function (child, afterNode, mountImage) {
          return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
        },
        removeChild: function (child, node) {
          return makeRemove(child, node);
        },
        _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
          child._mountIndex = index;
          return this.createChild(child, afterNode, mountImage);
        },
        _unmountChild: function (child, node) {
          var update = this.removeChild(child, node);
          child._mountIndex = null;
          return update;
        }
      } };
    module.exports = ReactMultiChild;
  })($__require('15'));
});
$__System.registerDynamic('46', ['47', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ReactUpdateQueue = $__require('47');
    var warning = $__require('24');
    function warnNoop(publicInstance, callerName) {
      if ('production' !== 'production') {
        var constructor = publicInstance.constructor;
        'production' !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
      }
    }
    var ReactServerUpdateQueue = function () {
      function ReactServerUpdateQueue(transaction) {
        _classCallCheck(this, ReactServerUpdateQueue);
        this.transaction = transaction;
      }
      ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
        return false;
      };
      ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
        }
      };
      ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueForceUpdate(publicInstance);
        } else {
          warnNoop(publicInstance, 'forceUpdate');
        }
      };
      ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
        } else {
          warnNoop(publicInstance, 'replaceState');
        }
      };
      ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
        if (this.transaction.isInTransaction()) {
          ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
        } else {
          warnNoop(publicInstance, 'setState');
        }
      };
      return ReactServerUpdateQueue;
    }();
    module.exports = ReactServerUpdateQueue;
  })($__require('15'));
});
$__System.registerDynamic('48', ['6', '4', '49', '29', '46', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var PooledClass = $__require('4');
    var Transaction = $__require('49');
    var ReactInstrumentation = $__require('29');
    var ReactServerUpdateQueue = $__require('46');
    var TRANSACTION_WRAPPERS = [];
    if ('production' !== 'production') {
      TRANSACTION_WRAPPERS.push({
        initialize: ReactInstrumentation.debugTool.onBeginFlush,
        close: ReactInstrumentation.debugTool.onEndFlush
      });
    }
    var noopCallbackQueue = { enqueue: function () {} };
    function ReactServerRenderingTransaction(renderToStaticMarkup) {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = renderToStaticMarkup;
      this.useCreateElement = false;
      this.updateQueue = new ReactServerUpdateQueue(this);
    }
    var Mixin = {
      getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS;
      },
      getReactMountReady: function () {
        return noopCallbackQueue;
      },
      getUpdateQueue: function () {
        return this.updateQueue;
      },
      destructor: function () {},
      checkpoint: function () {},
      rollback: function () {}
    };
    _assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactServerRenderingTransaction);
    module.exports = ReactServerRenderingTransaction;
  })($__require('15'));
});
$__System.registerDynamic('11', ['f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactDOMComponentTree = $__require('f');
  function isCheckable(elem) {
    var type = elem.type;
    var nodeName = elem.nodeName;
    return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
  }
  function getTracker(inst) {
    return inst._wrapperState.valueTracker;
  }
  function attachTracker(inst, tracker) {
    inst._wrapperState.valueTracker = tracker;
  }
  function detachTracker(inst) {
    delete inst._wrapperState.valueTracker;
  }
  function getValueFromNode(node) {
    var value;
    if (node) {
      value = isCheckable(node) ? '' + node.checked : node.value;
    }
    return value;
  }
  var inputValueTracking = {
    _getTrackerFromNode: function (node) {
      return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
    },
    track: function (inst) {
      if (getTracker(inst)) {
        return;
      }
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      var valueField = isCheckable(node) ? 'checked' : 'value';
      var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
      var currentValue = '' + node[valueField];
      if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
        return;
      }
      Object.defineProperty(node, valueField, {
        enumerable: descriptor.enumerable,
        configurable: true,
        get: function () {
          return descriptor.get.call(this);
        },
        set: function (value) {
          currentValue = '' + value;
          descriptor.set.call(this, value);
        }
      });
      attachTracker(inst, {
        getValue: function () {
          return currentValue;
        },
        setValue: function (value) {
          currentValue = '' + value;
        },
        stopTracking: function () {
          detachTracker(inst);
          delete node[valueField];
        }
      });
    },
    updateValueIfChanged: function (inst) {
      if (!inst) {
        return false;
      }
      var tracker = getTracker(inst);
      if (!tracker) {
        inputValueTracking.track(inst);
        return true;
      }
      var lastValue = tracker.getValue();
      var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));
      if (nextValue !== lastValue) {
        tracker.setValue(nextValue);
        return true;
      }
      return false;
    },
    stopTracking: function (inst) {
      var tracker = getTracker(inst);
      if (tracker) {
        tracker.stopTracking();
      }
    }
  };
  module.exports = inputValueTracking;
});
$__System.registerDynamic('4a', ['2e', '6', '1e', '28', '4b', '4c', '1a', '2c', 'e', '4d', '4e', '4f', 'f', '2d', '31', '32', '36', '29', '42', '48', '45', '2b', '30', '13', '51', '11', '50', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e'),
        _assign = $__require('6');
    var AutoFocusUtils = $__require('1e');
    var CSSPropertyOperations = $__require('28');
    var DOMLazyTree = $__require('4b');
    var DOMNamespaces = $__require('4c');
    var DOMProperty = $__require('1a');
    var DOMPropertyOperations = $__require('2c');
    var EventPluginHub = $__require('e');
    var EventPluginRegistry = $__require('4d');
    var ReactBrowserEventEmitter = $__require('4e');
    var ReactDOMComponentFlags = $__require('4f');
    var ReactDOMComponentTree = $__require('f');
    var ReactDOMInput = $__require('2d');
    var ReactDOMOption = $__require('31');
    var ReactDOMSelect = $__require('32');
    var ReactDOMTextarea = $__require('36');
    var ReactInstrumentation = $__require('29');
    var ReactMultiChild = $__require('42');
    var ReactServerRenderingTransaction = $__require('48');
    var emptyFunction = $__require('45');
    var escapeTextContentForBrowser = $__require('2b');
    var invariant = $__require('30');
    var isEventSupported = $__require('13');
    var shallowEqual = $__require('51');
    var inputValueTracking = $__require('11');
    var validateDOMNesting = $__require('50');
    var warning = $__require('24');
    var Flags = ReactDOMComponentFlags;
    var deleteListener = EventPluginHub.deleteListener;
    var getNode = ReactDOMComponentTree.getNodeFromInstance;
    var listenTo = ReactBrowserEventEmitter.listenTo;
    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    var CONTENT_TYPES = {
      string: true,
      number: true
    };
    var STYLE = 'style';
    var HTML = '__html';
    var RESERVED_PROPS = {
      children: null,
      dangerouslySetInnerHTML: null,
      suppressContentEditableWarning: null
    };
    var DOC_FRAGMENT_TYPE = 11;
    function getDeclarationErrorAddendum(internalInstance) {
      if (internalInstance) {
        var owner = internalInstance._currentElement._owner || null;
        if (owner) {
          var name = owner.getName();
          if (name) {
            return ' This DOM node was rendered by `' + name + '`.';
          }
        }
      }
      return '';
    }
    function friendlyStringify(obj) {
      if (typeof obj === 'object') {
        if (Array.isArray(obj)) {
          return '[' + obj.map(friendlyStringify).join(', ') + ']';
        } else {
          var pairs = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
              pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
            }
          }
          return '{' + pairs.join(', ') + '}';
        }
      } else if (typeof obj === 'string') {
        return JSON.stringify(obj);
      } else if (typeof obj === 'function') {
        return '[function object]';
      }
      return String(obj);
    }
    var styleMutationWarning = {};
    function checkAndWarnForMutatedStyle(style1, style2, component) {
      if (style1 == null || style2 == null) {
        return;
      }
      if (shallowEqual(style1, style2)) {
        return;
      }
      var componentName = component._tag;
      var owner = component._currentElement._owner;
      var ownerName;
      if (owner) {
        ownerName = owner.getName();
      }
      var hash = ownerName + '|' + componentName;
      if (styleMutationWarning.hasOwnProperty(hash)) {
        return;
      }
      styleMutationWarning[hash] = true;
      'production' !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
    }
    function assertValidProps(component, props) {
      if (!props) {
        return;
      }
      if (voidElementTags[component._tag]) {
        !(props.children == null && props.dangerouslySetInnerHTML == null) ? 'production' !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
      }
      if (props.dangerouslySetInnerHTML != null) {
        !(props.children == null) ? 'production' !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
        !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? 'production' !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
        'production' !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
        'production' !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
      }
      !(props.style == null || typeof props.style === 'object') ? 'production' !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
    }
    function enqueuePutListener(inst, registrationName, listener, transaction) {
      if (transaction instanceof ReactServerRenderingTransaction) {
        return;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
      }
      var containerInfo = inst._hostContainerInfo;
      var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
      var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
      listenTo(registrationName, doc);
      transaction.getReactMountReady().enqueue(putListener, {
        inst: inst,
        registrationName: registrationName,
        listener: listener
      });
    }
    function putListener() {
      var listenerToPut = this;
      EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
    }
    function inputPostMount() {
      var inst = this;
      ReactDOMInput.postMountWrapper(inst);
    }
    function textareaPostMount() {
      var inst = this;
      ReactDOMTextarea.postMountWrapper(inst);
    }
    function optionPostMount() {
      var inst = this;
      ReactDOMOption.postMountWrapper(inst);
    }
    var setAndValidateContentChildDev = emptyFunction;
    if ('production' !== 'production') {
      setAndValidateContentChildDev = function (content) {
        var hasExistingContent = this._contentDebugID != null;
        var debugID = this._debugID;
        var contentDebugID = -debugID;
        if (content == null) {
          if (hasExistingContent) {
            ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
          }
          this._contentDebugID = null;
          return;
        }
        validateDOMNesting(null, String(content), this, this._ancestorInfo);
        this._contentDebugID = contentDebugID;
        if (hasExistingContent) {
          ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
          ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
        } else {
          ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
          ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
          ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
        }
      };
    }
    var mediaEvents = {
      topAbort: 'abort',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topPause: 'pause',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topSeeked: 'seeked',
      topSeeking: 'seeking',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTimeUpdate: 'timeupdate',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting'
    };
    function trackInputValue() {
      inputValueTracking.track(this);
    }
    function trapBubbledEventsLocal() {
      var inst = this;
      !inst._rootNodeID ? 'production' !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
      var node = getNode(inst);
      !node ? 'production' !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
      switch (inst._tag) {
        case 'iframe':
        case 'object':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
          break;
        case 'video':
        case 'audio':
          inst._wrapperState.listeners = [];
          for (var event in mediaEvents) {
            if (mediaEvents.hasOwnProperty(event)) {
              inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
            }
          }
          break;
        case 'source':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
          break;
        case 'img':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
          break;
        case 'form':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
          break;
        case 'input':
        case 'select':
        case 'textarea':
          inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
          break;
      }
    }
    function postUpdateSelectWrapper() {
      ReactDOMSelect.postUpdateWrapper(this);
    }
    var omittedCloseTags = {
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };
    var newlineEatingTags = {
      listing: true,
      pre: true,
      textarea: true
    };
    var voidElementTags = _assign({ menuitem: true }, omittedCloseTags);
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
    var validatedTagCache = {};
    var hasOwnProperty = {}.hasOwnProperty;
    function validateDangerousTag(tag) {
      if (!hasOwnProperty.call(validatedTagCache, tag)) {
        !VALID_TAG_REGEX.test(tag) ? 'production' !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
        validatedTagCache[tag] = true;
      }
    }
    function isCustomComponent(tagName, props) {
      return tagName.indexOf('-') >= 0 || props.is != null;
    }
    var globalIdCounter = 1;
    function ReactDOMComponent(element) {
      var tag = element.type;
      validateDangerousTag(tag);
      this._currentElement = element;
      this._tag = tag.toLowerCase();
      this._namespaceURI = null;
      this._renderedChildren = null;
      this._previousStyle = null;
      this._previousStyleCopy = null;
      this._hostNode = null;
      this._hostParent = null;
      this._rootNodeID = 0;
      this._domID = 0;
      this._hostContainerInfo = null;
      this._wrapperState = null;
      this._topLevelWrapper = null;
      this._flags = 0;
      if ('production' !== 'production') {
        this._ancestorInfo = null;
        setAndValidateContentChildDev.call(this, null);
      }
    }
    ReactDOMComponent.displayName = 'ReactDOMComponent';
    ReactDOMComponent.Mixin = {
      mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
        this._rootNodeID = globalIdCounter++;
        this._domID = hostContainerInfo._idCounter++;
        this._hostParent = hostParent;
        this._hostContainerInfo = hostContainerInfo;
        var props = this._currentElement.props;
        switch (this._tag) {
          case 'audio':
          case 'form':
          case 'iframe':
          case 'img':
          case 'link':
          case 'object':
          case 'source':
          case 'video':
            this._wrapperState = { listeners: null };
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'input':
            ReactDOMInput.mountWrapper(this, props, hostParent);
            props = ReactDOMInput.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trackInputValue, this);
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'option':
            ReactDOMOption.mountWrapper(this, props, hostParent);
            props = ReactDOMOption.getHostProps(this, props);
            break;
          case 'select':
            ReactDOMSelect.mountWrapper(this, props, hostParent);
            props = ReactDOMSelect.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
          case 'textarea':
            ReactDOMTextarea.mountWrapper(this, props, hostParent);
            props = ReactDOMTextarea.getHostProps(this, props);
            transaction.getReactMountReady().enqueue(trackInputValue, this);
            transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
            break;
        }
        assertValidProps(this, props);
        var namespaceURI;
        var parentTag;
        if (hostParent != null) {
          namespaceURI = hostParent._namespaceURI;
          parentTag = hostParent._tag;
        } else if (hostContainerInfo._tag) {
          namespaceURI = hostContainerInfo._namespaceURI;
          parentTag = hostContainerInfo._tag;
        }
        if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
          namespaceURI = DOMNamespaces.html;
        }
        if (namespaceURI === DOMNamespaces.html) {
          if (this._tag === 'svg') {
            namespaceURI = DOMNamespaces.svg;
          } else if (this._tag === 'math') {
            namespaceURI = DOMNamespaces.mathml;
          }
        }
        this._namespaceURI = namespaceURI;
        if ('production' !== 'production') {
          var parentInfo;
          if (hostParent != null) {
            parentInfo = hostParent._ancestorInfo;
          } else if (hostContainerInfo._tag) {
            parentInfo = hostContainerInfo._ancestorInfo;
          }
          if (parentInfo) {
            validateDOMNesting(this._tag, null, this, parentInfo);
          }
          this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
        }
        var mountImage;
        if (transaction.useCreateElement) {
          var ownerDocument = hostContainerInfo._ownerDocument;
          var el;
          if (namespaceURI === DOMNamespaces.html) {
            if (this._tag === 'script') {
              var div = ownerDocument.createElement('div');
              var type = this._currentElement.type;
              div.innerHTML = '<' + type + '></' + type + '>';
              el = div.removeChild(div.firstChild);
            } else if (props.is) {
              el = ownerDocument.createElement(this._currentElement.type, props.is);
            } else {
              el = ownerDocument.createElement(this._currentElement.type);
            }
          } else {
            el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
          }
          ReactDOMComponentTree.precacheNode(this, el);
          this._flags |= Flags.hasCachedChildNodes;
          if (!this._hostParent) {
            DOMPropertyOperations.setAttributeForRoot(el);
          }
          this._updateDOMProperties(null, props, transaction);
          var lazyTree = DOMLazyTree(el);
          this._createInitialChildren(transaction, props, context, lazyTree);
          mountImage = lazyTree;
        } else {
          var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
          var tagContent = this._createContentMarkup(transaction, props, context);
          if (!tagContent && omittedCloseTags[this._tag]) {
            mountImage = tagOpen + '/>';
          } else {
            mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
          }
        }
        switch (this._tag) {
          case 'input':
            transaction.getReactMountReady().enqueue(inputPostMount, this);
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'textarea':
            transaction.getReactMountReady().enqueue(textareaPostMount, this);
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'select':
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'button':
            if (props.autoFocus) {
              transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
            }
            break;
          case 'option':
            transaction.getReactMountReady().enqueue(optionPostMount, this);
            break;
        }
        return mountImage;
      },
      _createOpenTagMarkupAndPutListeners: function (transaction, props) {
        var ret = '<' + this._currentElement.type;
        for (var propKey in props) {
          if (!props.hasOwnProperty(propKey)) {
            continue;
          }
          var propValue = props[propKey];
          if (propValue == null) {
            continue;
          }
          if (registrationNameModules.hasOwnProperty(propKey)) {
            if (propValue) {
              enqueuePutListener(this, propKey, propValue, transaction);
            }
          } else {
            if (propKey === STYLE) {
              if (propValue) {
                if ('production' !== 'production') {
                  this._previousStyle = propValue;
                }
                propValue = this._previousStyleCopy = _assign({}, props.style);
              }
              propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
            }
            var markup = null;
            if (this._tag != null && isCustomComponent(this._tag, props)) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += ' ' + markup;
            }
          }
        }
        if (transaction.renderToStaticMarkup) {
          return ret;
        }
        if (!this._hostParent) {
          ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
        }
        ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
        return ret;
      },
      _createContentMarkup: function (transaction, props, context) {
        var ret = '';
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            ret = innerHTML.__html;
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            ret = escapeTextContentForBrowser(contentToUse);
            if ('production' !== 'production') {
              setAndValidateContentChildDev.call(this, contentToUse);
            }
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, context);
            ret = mountImages.join('');
          }
        }
        if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
          return '\n' + ret;
        } else {
          return ret;
        }
      },
      _createInitialChildren: function (transaction, props, context, lazyTree) {
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null) {
            DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
          }
        } else {
          var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
          var childrenToUse = contentToUse != null ? null : props.children;
          if (contentToUse != null) {
            if (contentToUse !== '') {
              if ('production' !== 'production') {
                setAndValidateContentChildDev.call(this, contentToUse);
              }
              DOMLazyTree.queueText(lazyTree, contentToUse);
            }
          } else if (childrenToUse != null) {
            var mountImages = this.mountChildren(childrenToUse, transaction, context);
            for (var i = 0; i < mountImages.length; i++) {
              DOMLazyTree.queueChild(lazyTree, mountImages[i]);
            }
          }
        }
      },
      receiveComponent: function (nextElement, transaction, context) {
        var prevElement = this._currentElement;
        this._currentElement = nextElement;
        this.updateComponent(transaction, prevElement, nextElement, context);
      },
      updateComponent: function (transaction, prevElement, nextElement, context) {
        var lastProps = prevElement.props;
        var nextProps = this._currentElement.props;
        switch (this._tag) {
          case 'input':
            lastProps = ReactDOMInput.getHostProps(this, lastProps);
            nextProps = ReactDOMInput.getHostProps(this, nextProps);
            break;
          case 'option':
            lastProps = ReactDOMOption.getHostProps(this, lastProps);
            nextProps = ReactDOMOption.getHostProps(this, nextProps);
            break;
          case 'select':
            lastProps = ReactDOMSelect.getHostProps(this, lastProps);
            nextProps = ReactDOMSelect.getHostProps(this, nextProps);
            break;
          case 'textarea':
            lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
            nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
            break;
        }
        assertValidProps(this, nextProps);
        this._updateDOMProperties(lastProps, nextProps, transaction);
        this._updateDOMChildren(lastProps, nextProps, transaction, context);
        switch (this._tag) {
          case 'input':
            ReactDOMInput.updateWrapper(this);
            break;
          case 'textarea':
            ReactDOMTextarea.updateWrapper(this);
            break;
          case 'select':
            transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
            break;
        }
      },
      _updateDOMProperties: function (lastProps, nextProps, transaction) {
        var propKey;
        var styleName;
        var styleUpdates;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = this._previousStyleCopy;
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                styleUpdates = styleUpdates || {};
                styleUpdates[styleName] = '';
              }
            }
            this._previousStyleCopy = null;
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (lastProps[propKey]) {
              deleteListener(this, propKey);
            }
          } else if (isCustomComponent(this._tag, lastProps)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
            }
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
            continue;
          }
          if (propKey === STYLE) {
            if (nextProp) {
              if ('production' !== 'production') {
                checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
                this._previousStyle = nextProp;
              }
              nextProp = this._previousStyleCopy = _assign({}, nextProp);
            } else {
              this._previousStyleCopy = null;
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = '';
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  styleUpdates = styleUpdates || {};
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              styleUpdates = nextProp;
            }
          } else if (registrationNameModules.hasOwnProperty(propKey)) {
            if (nextProp) {
              enqueuePutListener(this, propKey, nextProp, transaction);
            } else if (lastProp) {
              deleteListener(this, propKey);
            }
          } else if (isCustomComponent(this._tag, nextProps)) {
            if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
              DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
            }
          } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
            var node = getNode(this);
            if (nextProp != null) {
              DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
            } else {
              DOMPropertyOperations.deleteValueForProperty(node, propKey);
            }
          }
        }
        if (styleUpdates) {
          CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
        }
      },
      _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
        var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
        var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
        var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
        var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
        var lastChildren = lastContent != null ? null : lastProps.children;
        var nextChildren = nextContent != null ? null : nextProps.children;
        var lastHasContentOrHtml = lastContent != null || lastHtml != null;
        var nextHasContentOrHtml = nextContent != null || nextHtml != null;
        if (lastChildren != null && nextChildren == null) {
          this.updateChildren(null, transaction, context);
        } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
          this.updateTextContent('');
          if ('production' !== 'production') {
            ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
          }
        }
        if (nextContent != null) {
          if (lastContent !== nextContent) {
            this.updateTextContent('' + nextContent);
            if ('production' !== 'production') {
              setAndValidateContentChildDev.call(this, nextContent);
            }
          }
        } else if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            this.updateMarkup('' + nextHtml);
          }
          if ('production' !== 'production') {
            ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
          }
        } else if (nextChildren != null) {
          if ('production' !== 'production') {
            setAndValidateContentChildDev.call(this, null);
          }
          this.updateChildren(nextChildren, transaction, context);
        }
      },
      getHostNode: function () {
        return getNode(this);
      },
      unmountComponent: function (safely) {
        switch (this._tag) {
          case 'audio':
          case 'form':
          case 'iframe':
          case 'img':
          case 'link':
          case 'object':
          case 'source':
          case 'video':
            var listeners = this._wrapperState.listeners;
            if (listeners) {
              for (var i = 0; i < listeners.length; i++) {
                listeners[i].remove();
              }
            }
            break;
          case 'input':
          case 'textarea':
            inputValueTracking.stopTracking(this);
            break;
          case 'html':
          case 'head':
          case 'body':
            !false ? 'production' !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
            break;
        }
        this.unmountChildren(safely);
        ReactDOMComponentTree.uncacheNode(this);
        EventPluginHub.deleteAllListeners(this);
        this._rootNodeID = 0;
        this._domID = 0;
        this._wrapperState = null;
        if ('production' !== 'production') {
          setAndValidateContentChildDev.call(this, null);
        }
      },
      getPublicInstance: function () {
        return getNode(this);
      }
    };
    _assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
    module.exports = ReactDOMComponent;
  })($__require('15'));
});
$__System.registerDynamic('52', ['6', '4b', 'f'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var _assign = $__require('6');
  var DOMLazyTree = $__require('4b');
  var ReactDOMComponentTree = $__require('f');
  var ReactDOMEmptyComponent = function (instantiate) {
    this._currentElement = null;
    this._hostNode = null;
    this._hostParent = null;
    this._hostContainerInfo = null;
    this._domID = 0;
  };
  _assign(ReactDOMEmptyComponent.prototype, {
    mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
      var domID = hostContainerInfo._idCounter++;
      this._domID = domID;
      this._hostParent = hostParent;
      this._hostContainerInfo = hostContainerInfo;
      var nodeValue = ' react-empty: ' + this._domID + ' ';
      if (transaction.useCreateElement) {
        var ownerDocument = hostContainerInfo._ownerDocument;
        var node = ownerDocument.createComment(nodeValue);
        ReactDOMComponentTree.precacheNode(this, node);
        return DOMLazyTree(node);
      } else {
        if (transaction.renderToStaticMarkup) {
          return '';
        }
        return '<!--' + nodeValue + '-->';
      }
    },
    receiveComponent: function () {},
    getHostNode: function () {
      return ReactDOMComponentTree.getNodeFromInstance(this);
    },
    unmountComponent: function () {
      ReactDOMComponentTree.uncacheNode(this);
    }
  });
  module.exports = ReactDOMEmptyComponent;
});
$__System.registerDynamic('53', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    function getLowestCommonAncestor(instA, instB) {
      !('_hostNode' in instA) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
      !('_hostNode' in instB) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
      var depthA = 0;
      for (var tempA = instA; tempA; tempA = tempA._hostParent) {
        depthA++;
      }
      var depthB = 0;
      for (var tempB = instB; tempB; tempB = tempB._hostParent) {
        depthB++;
      }
      while (depthA - depthB > 0) {
        instA = instA._hostParent;
        depthA--;
      }
      while (depthB - depthA > 0) {
        instB = instB._hostParent;
        depthB--;
      }
      var depth = depthA;
      while (depth--) {
        if (instA === instB) {
          return instA;
        }
        instA = instA._hostParent;
        instB = instB._hostParent;
      }
      return null;
    }
    function isAncestor(instA, instB) {
      !('_hostNode' in instA) ? 'production' !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
      !('_hostNode' in instB) ? 'production' !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
      while (instB) {
        if (instB === instA) {
          return true;
        }
        instB = instB._hostParent;
      }
      return false;
    }
    function getParentInstance(inst) {
      !('_hostNode' in inst) ? 'production' !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
      return inst._hostParent;
    }
    function traverseTwoPhase(inst, fn, arg) {
      var path = [];
      while (inst) {
        path.push(inst);
        inst = inst._hostParent;
      }
      var i;
      for (i = path.length; i-- > 0;) {
        fn(path[i], 'captured', arg);
      }
      for (i = 0; i < path.length; i++) {
        fn(path[i], 'bubbled', arg);
      }
    }
    function traverseEnterLeave(from, to, fn, argFrom, argTo) {
      var common = from && to ? getLowestCommonAncestor(from, to) : null;
      var pathFrom = [];
      while (from && from !== common) {
        pathFrom.push(from);
        from = from._hostParent;
      }
      var pathTo = [];
      while (to && to !== common) {
        pathTo.push(to);
        to = to._hostParent;
      }
      var i;
      for (i = 0; i < pathFrom.length; i++) {
        fn(pathFrom[i], 'bubbled', argFrom);
      }
      for (i = pathTo.length; i-- > 0;) {
        fn(pathTo[i], 'captured', argTo);
      }
    }
    module.exports = {
      isAncestor: isAncestor,
      getLowestCommonAncestor: getLowestCommonAncestor,
      getParentInstance: getParentInstance,
      traverseTwoPhase: traverseTwoPhase,
      traverseEnterLeave: traverseEnterLeave
    };
  })($__require('15'));
});
$__System.registerDynamic('54', ['30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var invariant = $__require('30');
    function toArray(obj) {
      var length = obj.length;
      !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? 'production' !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
      !(typeof length === 'number') ? 'production' !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
      !(length === 0 || length - 1 in obj) ? 'production' !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
      !(typeof obj.callee !== 'function') ? 'production' !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
      if (obj.hasOwnProperty) {
        try {
          return Array.prototype.slice.call(obj);
        } catch (e) {}
      }
      var ret = Array(length);
      for (var ii = 0; ii < length; ii++) {
        ret[ii] = obj[ii];
      }
      return ret;
    }
    function hasArrayNature(obj) {
      return !!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj && !('setInterval' in obj) && typeof obj.nodeType != 'number' && (Array.isArray(obj) || 'callee' in obj || 'item' in obj);
    }
    function createArrayFromMixed(obj) {
      if (!hasArrayNature(obj)) {
        return [obj];
      } else if (Array.isArray(obj)) {
        return obj.slice();
      } else {
        return toArray(obj);
      }
    }
    module.exports = createArrayFromMixed;
  })($__require('15'));
});
$__System.registerDynamic('55', ['c', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ExecutionEnvironment = $__require('c');
    var invariant = $__require('30');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var shouldWrap = {};
    var selectWrap = [1, '<select multiple="true">', '</select>'];
    var tableWrap = [1, '<table>', '</table>'];
    var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
    var markupWrap = {
      '*': [1, '?<div>', '</div>'],
      'area': [1, '<map>', '</map>'],
      'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
      'legend': [1, '<fieldset>', '</fieldset>'],
      'param': [1, '<object>', '</object>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'optgroup': selectWrap,
      'option': selectWrap,
      'caption': tableWrap,
      'colgroup': tableWrap,
      'tbody': tableWrap,
      'tfoot': tableWrap,
      'thead': tableWrap,
      'td': trWrap,
      'th': trWrap
    };
    var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
    svgElements.forEach(function (nodeName) {
      markupWrap[nodeName] = svgWrap;
      shouldWrap[nodeName] = true;
    });
    function getMarkupWrap(nodeName) {
      !!!dummyNode ? 'production' !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
      if (!markupWrap.hasOwnProperty(nodeName)) {
        nodeName = '*';
      }
      if (!shouldWrap.hasOwnProperty(nodeName)) {
        if (nodeName === '*') {
          dummyNode.innerHTML = '<link />';
        } else {
          dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
        }
        shouldWrap[nodeName] = !dummyNode.firstChild;
      }
      return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
    }
    module.exports = getMarkupWrap;
  })($__require('15'));
});
$__System.registerDynamic('56', ['c', '54', '55', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ExecutionEnvironment = $__require('c');
    var createArrayFromMixed = $__require('54');
    var getMarkupWrap = $__require('55');
    var invariant = $__require('30');
    var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
    var nodeNamePattern = /^\s*<(\w+)/;
    function getNodeName(markup) {
      var nodeNameMatch = markup.match(nodeNamePattern);
      return nodeNameMatch && nodeNameMatch[1].toLowerCase();
    }
    function createNodesFromMarkup(markup, handleScript) {
      var node = dummyNode;
      !!!dummyNode ? 'production' !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
      var nodeName = getNodeName(markup);
      var wrap = nodeName && getMarkupWrap(nodeName);
      if (wrap) {
        node.innerHTML = wrap[1] + markup + wrap[2];
        var wrapDepth = wrap[0];
        while (wrapDepth--) {
          node = node.lastChild;
        }
      } else {
        node.innerHTML = markup;
      }
      var scripts = node.getElementsByTagName('script');
      if (scripts.length) {
        !handleScript ? 'production' !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
        createArrayFromMixed(scripts).forEach(handleScript);
      }
      var nodes = Array.from(node.childNodes);
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
      return nodes;
    }
    module.exports = createNodesFromMarkup;
  })($__require('15'));
});
$__System.registerDynamic('57', ['2e', '4b', 'c', '56', '45', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var DOMLazyTree = $__require('4b');
    var ExecutionEnvironment = $__require('c');
    var createNodesFromMarkup = $__require('56');
    var emptyFunction = $__require('45');
    var invariant = $__require('30');
    var Danger = { dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
        !ExecutionEnvironment.canUseDOM ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
        !markup ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
        !(oldChild.nodeName !== 'HTML') ? 'production' !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
        if (typeof markup === 'string') {
          var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
          oldChild.parentNode.replaceChild(newChild, oldChild);
        } else {
          DOMLazyTree.replaceChildWithTree(oldChild, markup);
        }
      } };
    module.exports = Danger;
  })($__require('15'));
});
$__System.registerDynamic('1c', ['4b', '57', 'f', '29', '58', '59', '5a', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMLazyTree = $__require('4b');
    var Danger = $__require('57');
    var ReactDOMComponentTree = $__require('f');
    var ReactInstrumentation = $__require('29');
    var createMicrosoftUnsafeLocalFunction = $__require('58');
    var setInnerHTML = $__require('59');
    var setTextContent = $__require('5a');
    function getNodeAfter(parentNode, node) {
      if (Array.isArray(node)) {
        node = node[1];
      }
      return node ? node.nextSibling : parentNode.firstChild;
    }
    var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
      parentNode.insertBefore(childNode, referenceNode);
    });
    function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
      DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
    }
    function moveChild(parentNode, childNode, referenceNode) {
      if (Array.isArray(childNode)) {
        moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
      } else {
        insertChildAt(parentNode, childNode, referenceNode);
      }
    }
    function removeChild(parentNode, childNode) {
      if (Array.isArray(childNode)) {
        var closingComment = childNode[1];
        childNode = childNode[0];
        removeDelimitedText(parentNode, childNode, closingComment);
        parentNode.removeChild(closingComment);
      }
      parentNode.removeChild(childNode);
    }
    function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
      var node = openingComment;
      while (true) {
        var nextNode = node.nextSibling;
        insertChildAt(parentNode, node, referenceNode);
        if (node === closingComment) {
          break;
        }
        node = nextNode;
      }
    }
    function removeDelimitedText(parentNode, startNode, closingComment) {
      while (true) {
        var node = startNode.nextSibling;
        if (node === closingComment) {
          break;
        } else {
          parentNode.removeChild(node);
        }
      }
    }
    function replaceDelimitedText(openingComment, closingComment, stringText) {
      var parentNode = openingComment.parentNode;
      var nodeAfterComment = openingComment.nextSibling;
      if (nodeAfterComment === closingComment) {
        if (stringText) {
          insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
        }
      } else {
        if (stringText) {
          setTextContent(nodeAfterComment, stringText);
          removeDelimitedText(parentNode, nodeAfterComment, closingComment);
        } else {
          removeDelimitedText(parentNode, openingComment, closingComment);
        }
      }
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
          type: 'replace text',
          payload: stringText
        });
      }
    }
    var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
    if ('production' !== 'production') {
      dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
        Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
        if (prevInstance._debugID !== 0) {
          ReactInstrumentation.debugTool.onHostOperation({
            instanceID: prevInstance._debugID,
            type: 'replace with',
            payload: markup.toString()
          });
        } else {
          var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
          if (nextInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: nextInstance._debugID,
              type: 'mount',
              payload: markup.toString()
            });
          }
        }
      };
    }
    var DOMChildrenOperations = {
      dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
      replaceDelimitedText: replaceDelimitedText,
      processUpdates: function (parentNode, updates) {
        if ('production' !== 'production') {
          var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
        }
        for (var k = 0; k < updates.length; k++) {
          var update = updates[k];
          switch (update.type) {
            case 'INSERT_MARKUP':
              insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'insert child',
                  payload: {
                    toIndex: update.toIndex,
                    content: update.content.toString()
                  }
                });
              }
              break;
            case 'MOVE_EXISTING':
              moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'move child',
                  payload: {
                    fromIndex: update.fromIndex,
                    toIndex: update.toIndex
                  }
                });
              }
              break;
            case 'SET_MARKUP':
              setInnerHTML(parentNode, update.content);
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'replace children',
                  payload: update.content.toString()
                });
              }
              break;
            case 'TEXT_CONTENT':
              setTextContent(parentNode, update.content);
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'replace text',
                  payload: update.content.toString()
                });
              }
              break;
            case 'REMOVE_NODE':
              removeChild(parentNode, update.fromNode);
              if ('production' !== 'production') {
                ReactInstrumentation.debugTool.onHostOperation({
                  instanceID: parentNodeDebugID,
                  type: 'remove child',
                  payload: { fromIndex: update.fromIndex }
                });
              }
              break;
          }
        }
      }
    };
    module.exports = DOMChildrenOperations;
  })($__require('15'));
});
$__System.registerDynamic('5b', ['2e', '6', '1c', '4b', 'f', '2b', '30', '50', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e'),
        _assign = $__require('6');
    var DOMChildrenOperations = $__require('1c');
    var DOMLazyTree = $__require('4b');
    var ReactDOMComponentTree = $__require('f');
    var escapeTextContentForBrowser = $__require('2b');
    var invariant = $__require('30');
    var validateDOMNesting = $__require('50');
    var ReactDOMTextComponent = function (text) {
      this._currentElement = text;
      this._stringText = '' + text;
      this._hostNode = null;
      this._hostParent = null;
      this._domID = 0;
      this._mountIndex = 0;
      this._closingComment = null;
      this._commentNodes = null;
    };
    _assign(ReactDOMTextComponent.prototype, {
      mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
        if ('production' !== 'production') {
          var parentInfo;
          if (hostParent != null) {
            parentInfo = hostParent._ancestorInfo;
          } else if (hostContainerInfo != null) {
            parentInfo = hostContainerInfo._ancestorInfo;
          }
          if (parentInfo) {
            validateDOMNesting(null, this._stringText, this, parentInfo);
          }
        }
        var domID = hostContainerInfo._idCounter++;
        var openingValue = ' react-text: ' + domID + ' ';
        var closingValue = ' /react-text ';
        this._domID = domID;
        this._hostParent = hostParent;
        if (transaction.useCreateElement) {
          var ownerDocument = hostContainerInfo._ownerDocument;
          var openingComment = ownerDocument.createComment(openingValue);
          var closingComment = ownerDocument.createComment(closingValue);
          var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
          if (this._stringText) {
            DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
          }
          DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
          ReactDOMComponentTree.precacheNode(this, openingComment);
          this._closingComment = closingComment;
          return lazyTree;
        } else {
          var escapedText = escapeTextContentForBrowser(this._stringText);
          if (transaction.renderToStaticMarkup) {
            return escapedText;
          }
          return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
        }
      },
      receiveComponent: function (nextText, transaction) {
        if (nextText !== this._currentElement) {
          this._currentElement = nextText;
          var nextStringText = '' + nextText;
          if (nextStringText !== this._stringText) {
            this._stringText = nextStringText;
            var commentNodes = this.getHostNode();
            DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
          }
        }
      },
      getHostNode: function () {
        var hostNode = this._commentNodes;
        if (hostNode) {
          return hostNode;
        }
        if (!this._closingComment) {
          var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
          var node = openingComment.nextSibling;
          while (true) {
            !(node != null) ? 'production' !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
            if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
              this._closingComment = node;
              break;
            }
            node = node.nextSibling;
          }
        }
        hostNode = [this._hostNode, this._closingComment];
        this._commentNodes = hostNode;
        return hostNode;
      },
      unmountComponent: function () {
        this._closingComment = null;
        this._commentNodes = null;
        ReactDOMComponentTree.uncacheNode(this);
      }
    });
    module.exports = ReactDOMTextComponent;
  })($__require('15'));
});
$__System.registerDynamic('5c', ['6', '10', '49', '45'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var _assign = $__require('6');
  var ReactUpdates = $__require('10');
  var Transaction = $__require('49');
  var emptyFunction = $__require('45');
  var RESET_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: function () {
      ReactDefaultBatchingStrategy.isBatchingUpdates = false;
    }
  };
  var FLUSH_BATCHED_UPDATES = {
    initialize: emptyFunction,
    close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
  };
  var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
  function ReactDefaultBatchingStrategyTransaction() {
    this.reinitializeTransaction();
  }
  _assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, { getTransactionWrappers: function () {
      return TRANSACTION_WRAPPERS;
    } });
  var transaction = new ReactDefaultBatchingStrategyTransaction();
  var ReactDefaultBatchingStrategy = {
    isBatchingUpdates: false,
    batchedUpdates: function (callback, a, b, c, d, e) {
      var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
      ReactDefaultBatchingStrategy.isBatchingUpdates = true;
      if (alreadyBatchingUpdates) {
        return callback(a, b, c, d, e);
      } else {
        return transaction.perform(callback, null, a, b, c, d, e);
      }
    }
  };
  module.exports = ReactDefaultBatchingStrategy;
});
$__System.registerDynamic('5d', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  'use strict';

  /**
   * Gets the scroll position of the supplied element or window.
   *
   * The return values are unbounded, unlike `getScrollPosition`. This means they
   * may be negative or exceed the element boundaries (which is possible using
   * inertial scrolling).
   *
   * @param {DOMWindow|DOMElement} scrollable
   * @return {object} Map with `x` and `y` keys.
   */

  var global = this || self,
      GLOBAL = global;
  function getUnboundedScrollPosition(scrollable) {
    if (scrollable.Window && scrollable instanceof scrollable.Window) {
      return {
        x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
        y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }

  module.exports = getUnboundedScrollPosition;
});
$__System.registerDynamic('5e', ['6', '5f', 'c', '4', 'f', '10', '12', '5d', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var EventListener = $__require('5f');
    var ExecutionEnvironment = $__require('c');
    var PooledClass = $__require('4');
    var ReactDOMComponentTree = $__require('f');
    var ReactUpdates = $__require('10');
    var getEventTarget = $__require('12');
    var getUnboundedScrollPosition = $__require('5d');
    function findParent(inst) {
      while (inst._hostParent) {
        inst = inst._hostParent;
      }
      var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
      var container = rootNode.parentNode;
      return ReactDOMComponentTree.getClosestInstanceFromNode(container);
    }
    function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
      this.topLevelType = topLevelType;
      this.nativeEvent = nativeEvent;
      this.ancestors = [];
    }
    _assign(TopLevelCallbackBookKeeping.prototype, { destructor: function () {
        this.topLevelType = null;
        this.nativeEvent = null;
        this.ancestors.length = 0;
      } });
    PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
    function handleTopLevelImpl(bookKeeping) {
      var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
      var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
      var ancestor = targetInst;
      do {
        bookKeeping.ancestors.push(ancestor);
        ancestor = ancestor && findParent(ancestor);
      } while (ancestor);
      for (var i = 0; i < bookKeeping.ancestors.length; i++) {
        targetInst = bookKeeping.ancestors[i];
        ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
      }
    }
    function scrollValueMonitor(cb) {
      var scrollPosition = getUnboundedScrollPosition(window);
      cb(scrollPosition);
    }
    var ReactEventListener = {
      _enabled: true,
      _handleTopLevel: null,
      WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
      setHandleTopLevel: function (handleTopLevel) {
        ReactEventListener._handleTopLevel = handleTopLevel;
      },
      setEnabled: function (enabled) {
        ReactEventListener._enabled = !!enabled;
      },
      isEnabled: function () {
        return ReactEventListener._enabled;
      },
      trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
        if (!element) {
          return null;
        }
        return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
        if (!element) {
          return null;
        }
        return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
      },
      monitorScrollValue: function (refresh) {
        var callback = scrollValueMonitor.bind(null, refresh);
        EventListener.listen(window, 'scroll', callback);
      },
      dispatchEvent: function (topLevelType, nativeEvent) {
        if (!ReactEventListener._enabled) {
          return;
        }
        var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
        try {
          ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
        } finally {
          TopLevelCallbackBookKeeping.release(bookKeeping);
        }
      }
    };
    module.exports = ReactEventListener;
  })($__require('15'));
});
$__System.registerDynamic('60', ['1a', 'e', '61', '43', '62', '4e', '63', '10'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var DOMProperty = $__require('1a');
  var EventPluginHub = $__require('e');
  var EventPluginUtils = $__require('61');
  var ReactComponentEnvironment = $__require('43');
  var ReactEmptyComponent = $__require('62');
  var ReactBrowserEventEmitter = $__require('4e');
  var ReactHostComponent = $__require('63');
  var ReactUpdates = $__require('10');
  var ReactInjection = {
    Component: ReactComponentEnvironment.injection,
    DOMProperty: DOMProperty.injection,
    EmptyComponent: ReactEmptyComponent.injection,
    EventPluginHub: EventPluginHub.injection,
    EventPluginUtils: EventPluginUtils.injection,
    EventEmitter: ReactBrowserEventEmitter.injection,
    HostComponent: ReactHostComponent.injection,
    Updates: ReactUpdates.injection
  };
  module.exports = ReactInjection;
});
$__System.registerDynamic('64', ['6', '65', '4', '4e', '66', '29', '49', '47', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var CallbackQueue = $__require('65');
    var PooledClass = $__require('4');
    var ReactBrowserEventEmitter = $__require('4e');
    var ReactInputSelection = $__require('66');
    var ReactInstrumentation = $__require('29');
    var Transaction = $__require('49');
    var ReactUpdateQueue = $__require('47');
    var SELECTION_RESTORATION = {
      initialize: ReactInputSelection.getSelectionInformation,
      close: ReactInputSelection.restoreSelection
    };
    var EVENT_SUPPRESSION = {
      initialize: function () {
        var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
        ReactBrowserEventEmitter.setEnabled(false);
        return currentlyEnabled;
      },
      close: function (previouslyEnabled) {
        ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
      }
    };
    var ON_DOM_READY_QUEUEING = {
      initialize: function () {
        this.reactMountReady.reset();
      },
      close: function () {
        this.reactMountReady.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
    if ('production' !== 'production') {
      TRANSACTION_WRAPPERS.push({
        initialize: ReactInstrumentation.debugTool.onBeginFlush,
        close: ReactInstrumentation.debugTool.onEndFlush
      });
    }
    function ReactReconcileTransaction(useCreateElement) {
      this.reinitializeTransaction();
      this.renderToStaticMarkup = false;
      this.reactMountReady = CallbackQueue.getPooled(null);
      this.useCreateElement = useCreateElement;
    }
    var Mixin = {
      getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS;
      },
      getReactMountReady: function () {
        return this.reactMountReady;
      },
      getUpdateQueue: function () {
        return ReactUpdateQueue;
      },
      checkpoint: function () {
        return this.reactMountReady.checkpoint();
      },
      rollback: function (checkpoint) {
        this.reactMountReady.rollback(checkpoint);
      },
      destructor: function () {
        CallbackQueue.release(this.reactMountReady);
        this.reactMountReady = null;
      }
    };
    _assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
    PooledClass.addPoolingTo(ReactReconcileTransaction);
    module.exports = ReactReconcileTransaction;
  })($__require('15'));
});
$__System.registerDynamic('67', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var NS = {
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };

  // We use attributes for everything SVG so let's avoid some duplication and run
  // code instead.
  // The following are all specified in the HTML config already so we exclude here.
  // - class (as className)
  // - color
  // - height
  // - id
  // - lang
  // - max
  // - media
  // - method
  // - min
  // - name
  // - style
  // - target
  // - type
  // - width
  var ATTRS = {
    accentHeight: 'accent-height',
    accumulate: 0,
    additive: 0,
    alignmentBaseline: 'alignment-baseline',
    allowReorder: 'allowReorder',
    alphabetic: 0,
    amplitude: 0,
    arabicForm: 'arabic-form',
    ascent: 0,
    attributeName: 'attributeName',
    attributeType: 'attributeType',
    autoReverse: 'autoReverse',
    azimuth: 0,
    baseFrequency: 'baseFrequency',
    baseProfile: 'baseProfile',
    baselineShift: 'baseline-shift',
    bbox: 0,
    begin: 0,
    bias: 0,
    by: 0,
    calcMode: 'calcMode',
    capHeight: 'cap-height',
    clip: 0,
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    clipPathUnits: 'clipPathUnits',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    contentScriptType: 'contentScriptType',
    contentStyleType: 'contentStyleType',
    cursor: 0,
    cx: 0,
    cy: 0,
    d: 0,
    decelerate: 0,
    descent: 0,
    diffuseConstant: 'diffuseConstant',
    direction: 0,
    display: 0,
    divisor: 0,
    dominantBaseline: 'dominant-baseline',
    dur: 0,
    dx: 0,
    dy: 0,
    edgeMode: 'edgeMode',
    elevation: 0,
    enableBackground: 'enable-background',
    end: 0,
    exponent: 0,
    externalResourcesRequired: 'externalResourcesRequired',
    fill: 0,
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    filter: 0,
    filterRes: 'filterRes',
    filterUnits: 'filterUnits',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    focusable: 0,
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    format: 0,
    from: 0,
    fx: 0,
    fy: 0,
    g1: 0,
    g2: 0,
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    glyphRef: 'glyphRef',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    hanging: 0,
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    ideographic: 0,
    imageRendering: 'image-rendering',
    'in': 0,
    in2: 0,
    intercept: 0,
    k: 0,
    k1: 0,
    k2: 0,
    k3: 0,
    k4: 0,
    kernelMatrix: 'kernelMatrix',
    kernelUnitLength: 'kernelUnitLength',
    kerning: 0,
    keyPoints: 'keyPoints',
    keySplines: 'keySplines',
    keyTimes: 'keyTimes',
    lengthAdjust: 'lengthAdjust',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    limitingConeAngle: 'limitingConeAngle',
    local: 0,
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    markerHeight: 'markerHeight',
    markerUnits: 'markerUnits',
    markerWidth: 'markerWidth',
    mask: 0,
    maskContentUnits: 'maskContentUnits',
    maskUnits: 'maskUnits',
    mathematical: 0,
    mode: 0,
    numOctaves: 'numOctaves',
    offset: 0,
    opacity: 0,
    operator: 0,
    order: 0,
    orient: 0,
    orientation: 0,
    origin: 0,
    overflow: 0,
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pathLength: 'pathLength',
    patternContentUnits: 'patternContentUnits',
    patternTransform: 'patternTransform',
    patternUnits: 'patternUnits',
    pointerEvents: 'pointer-events',
    points: 0,
    pointsAtX: 'pointsAtX',
    pointsAtY: 'pointsAtY',
    pointsAtZ: 'pointsAtZ',
    preserveAlpha: 'preserveAlpha',
    preserveAspectRatio: 'preserveAspectRatio',
    primitiveUnits: 'primitiveUnits',
    r: 0,
    radius: 0,
    refX: 'refX',
    refY: 'refY',
    renderingIntent: 'rendering-intent',
    repeatCount: 'repeatCount',
    repeatDur: 'repeatDur',
    requiredExtensions: 'requiredExtensions',
    requiredFeatures: 'requiredFeatures',
    restart: 0,
    result: 0,
    rotate: 0,
    rx: 0,
    ry: 0,
    scale: 0,
    seed: 0,
    shapeRendering: 'shape-rendering',
    slope: 0,
    spacing: 0,
    specularConstant: 'specularConstant',
    specularExponent: 'specularExponent',
    speed: 0,
    spreadMethod: 'spreadMethod',
    startOffset: 'startOffset',
    stdDeviation: 'stdDeviation',
    stemh: 0,
    stemv: 0,
    stitchTiles: 'stitchTiles',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    string: 0,
    stroke: 0,
    strokeDasharray: 'stroke-dasharray',
    strokeDashoffset: 'stroke-dashoffset',
    strokeLinecap: 'stroke-linecap',
    strokeLinejoin: 'stroke-linejoin',
    strokeMiterlimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    surfaceScale: 'surfaceScale',
    systemLanguage: 'systemLanguage',
    tableValues: 'tableValues',
    targetX: 'targetX',
    targetY: 'targetY',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    textLength: 'textLength',
    to: 0,
    transform: 0,
    u1: 0,
    u2: 0,
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicode: 0,
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    values: 0,
    vectorEffect: 'vector-effect',
    version: 0,
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    viewBox: 'viewBox',
    viewTarget: 'viewTarget',
    visibility: 0,
    widths: 0,
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    x: 0,
    xHeight: 'x-height',
    x1: 0,
    x2: 0,
    xChannelSelector: 'xChannelSelector',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlns: 0,
    xmlnsXlink: 'xmlns:xlink',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space',
    y: 0,
    y1: 0,
    y2: 0,
    yChannelSelector: 'yChannelSelector',
    z: 0,
    zoomAndPan: 'zoomAndPan'
  };

  var SVGDOMPropertyConfig = {
    Properties: {},
    DOMAttributeNamespaces: {
      xlinkActuate: NS.xlink,
      xlinkArcrole: NS.xlink,
      xlinkHref: NS.xlink,
      xlinkRole: NS.xlink,
      xlinkShow: NS.xlink,
      xlinkTitle: NS.xlink,
      xlinkType: NS.xlink,
      xmlBase: NS.xml,
      xmlLang: NS.xml,
      xmlSpace: NS.xml
    },
    DOMAttributeNames: {}
  };

  Object.keys(ATTRS).forEach(function (key) {
    SVGDOMPropertyConfig.Properties[key] = 0;
    if (ATTRS[key]) {
      SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
    }
  });

  module.exports = SVGDOMPropertyConfig;
});
$__System.registerDynamic('68', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Given any node return the first leaf node without children.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {DOMElement|DOMTextNode}
   */

  var global = this || self,
      GLOBAL = global;
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }

  /**
   * Get the next sibling within a container. This will walk up the
   * DOM if a node's siblings have been exhausted.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {?DOMElement|DOMTextNode}
   */
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }

  /**
   * Get object describing the nodes which contain characters at offset.
   *
   * @param {DOMElement|DOMTextNode} root
   * @param {number} offset
   * @return {?object}
   */
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;

    while (node) {
      if (node.nodeType === 3) {
        nodeEnd = nodeStart + node.textContent.length;

        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }

        nodeStart = nodeEnd;
      }

      node = getLeafNode(getSiblingNode(node));
    }
  }

  module.exports = getNodeForCharacterOffset;
});
$__System.registerDynamic('5', ['c'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('c');

  var contentKey = null;

  /**
   * Gets the key used to access text content on a DOM node.
   *
   * @return {?string} Key used to access text content.
   * @internal
   */
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      // Prefer textContent to innerText because many browsers support both but
      // SVG <text> elements don't support innerText even when <div> does.
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }

  module.exports = getTextContentAccessor;
});
$__System.registerDynamic('69', ['c', '68', '5'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('c');
  var getNodeForCharacterOffset = $__require('68');
  var getTextContentAccessor = $__require('5');
  function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
    return anchorNode === focusNode && anchorOffset === focusOffset;
  }
  function getIEOffsets(node) {
    var selection = document.selection;
    var selectedRange = selection.createRange();
    var selectedLength = selectedRange.text.length;
    var fromStart = selectedRange.duplicate();
    fromStart.moveToElementText(node);
    fromStart.setEndPoint('EndToStart', selectedRange);
    var startOffset = fromStart.text.length;
    var endOffset = startOffset + selectedLength;
    return {
      start: startOffset,
      end: endOffset
    };
  }
  function getModernOffsets(node) {
    var selection = window.getSelection && window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null;
    }
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var currentRange = selection.getRangeAt(0);
    try {
      currentRange.startContainer.nodeType;
      currentRange.endContainer.nodeType;
    } catch (e) {
      return null;
    }
    var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
    var tempRange = currentRange.cloneRange();
    tempRange.selectNodeContents(node);
    tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
    var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
    var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
    var end = start + rangeLength;
    var detectionRange = document.createRange();
    detectionRange.setStart(anchorNode, anchorOffset);
    detectionRange.setEnd(focusNode, focusOffset);
    var isBackward = detectionRange.collapsed;
    return {
      start: isBackward ? end : start,
      end: isBackward ? start : end
    };
  }
  function setIEOffsets(node, offsets) {
    var range = document.selection.createRange().duplicate();
    var start, end;
    if (offsets.end === undefined) {
      start = offsets.start;
      end = start;
    } else if (offsets.start > offsets.end) {
      start = offsets.end;
      end = offsets.start;
    } else {
      start = offsets.start;
      end = offsets.end;
    }
    range.moveToElementText(node);
    range.moveStart('character', start);
    range.setEndPoint('EndToStart', range);
    range.moveEnd('character', end - start);
    range.select();
  }
  function setModernOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }
    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }
    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);
    if (startMarker && endMarker) {
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();
      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }
  var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
  var ReactDOMSelection = {
    getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
    setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
  };
  module.exports = ReactDOMSelection;
});
$__System.registerDynamic('6a', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM node.
   */

  var global = this || self,
      GLOBAL = global;
  function isNode(object) {
    var doc = object ? object.ownerDocument || object : document;
    var defaultView = doc.defaultView || window;
    return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }

  module.exports = isNode;
});
$__System.registerDynamic('6b', ['6a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var isNode = $__require('6a');
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }
  module.exports = isTextNode;
});
$__System.registerDynamic('6c', ['6b'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var isTextNode = $__require('6b');
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if ('contains' in outerNode) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
  module.exports = containsNode;
});
$__System.registerDynamic('1f', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * @param {DOMElement} node input/textarea to focus
   */

  var global = this || self,
      GLOBAL = global;
  function focusNode(node) {
    // IE8 can throw "Can't move focus to the control because it is invisible,
    // not enabled, or of a type that does not accept the focus." for all kinds of
    // reasons that are too expensive and fragile to test.
    try {
      node.focus();
    } catch (e) {}
  }

  module.exports = focusNode;
});
$__System.registerDynamic('66', ['69', '6c', '1f', '6d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactDOMSelection = $__require('69');
  var containsNode = $__require('6c');
  var focusNode = $__require('1f');
  var getActiveElement = $__require('6d');
  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }
  var ReactInputSelection = {
    hasSelectionCapabilities: function (elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
    },
    getSelectionInformation: function () {
      var focusedElem = getActiveElement();
      return {
        focusedElem: focusedElem,
        selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
      };
    },
    restoreSelection: function (priorSelectionInformation) {
      var curFocusedElem = getActiveElement();
      var priorFocusedElem = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
          ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
        }
        focusNode(priorFocusedElem);
      }
    },
    getSelection: function (input) {
      var selection;
      if ('selectionStart' in input) {
        selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        var range = document.selection.createRange();
        if (range.parentElement() === input) {
          selection = {
            start: -range.moveStart('character', -input.value.length),
            end: -range.moveEnd('character', -input.value.length)
          };
        }
      } else {
        selection = ReactDOMSelection.getOffsets(input);
      }
      return selection || {
        start: 0,
        end: 0
      };
    },
    setSelection: function (input, offsets) {
      var start = offsets.start;
      var end = offsets.end;
      if (end === undefined) {
        end = start;
      }
      if ('selectionStart' in input) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.moveEnd('character', end - start);
        range.select();
      } else {
        ReactDOMSelection.setOffsets(input, offsets);
      }
    }
  };
  module.exports = ReactInputSelection;
});
$__System.registerDynamic('6d', [], true, function ($__require, exports, module) {
  /* */
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   */

  /* eslint-disable fb-www/typeof-undefined */

  /**
   * Same as document.activeElement but wraps in a try-catch block. In IE it is
   * not safe to call document.activeElement if there is nothing focused.
   *
   * The activeElement will be null only if the document or document body is not
   * yet defined.
   *
   * @param {?DOMDocument} doc Defaults to current document.
   * @return {?DOMElement}
   */

  var global = this || self,
      GLOBAL = global;
  function getActiveElement(doc) /*?DOMElement*/{
    doc = doc || (typeof document !== 'undefined' ? document : undefined);
    if (typeof doc === 'undefined') {
      return null;
    }
    try {
      return doc.activeElement || doc.body;
    } catch (e) {
      return doc.body;
    }
  }

  module.exports = getActiveElement;
});
$__System.registerDynamic('14', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
   */

  var global = this || self,
      GLOBAL = global;
  var supportedInputTypes = {
    color: true,
    date: true,
    datetime: true,
    'datetime-local': true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };

  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

    if (nodeName === 'input') {
      return !!supportedInputTypes[elem.type];
    }

    if (nodeName === 'textarea') {
      return true;
    }

    return false;
  }

  module.exports = isTextInputElement;
});
$__System.registerDynamic('6e', ['b', 'c', 'f', '66', '8', '6d', '14', '51'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var EventPropagators = $__require('b');
  var ExecutionEnvironment = $__require('c');
  var ReactDOMComponentTree = $__require('f');
  var ReactInputSelection = $__require('66');
  var SyntheticEvent = $__require('8');
  var getActiveElement = $__require('6d');
  var isTextInputElement = $__require('14');
  var shallowEqual = $__require('51');
  var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
  var eventTypes = { select: {
      phasedRegistrationNames: {
        bubbled: 'onSelect',
        captured: 'onSelectCapture'
      },
      dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
    } };
  var activeElement = null;
  var activeElementInst = null;
  var lastSelection = null;
  var mouseDown = false;
  var hasListener = false;
  function getSelection(node) {
    if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    } else if (document.selection) {
      var range = document.selection.createRange();
      return {
        parentElement: range.parentElement(),
        text: range.text,
        top: range.boundingTop,
        left: range.boundingLeft
      };
    }
  }
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
      return null;
    }
    var currentSelection = getSelection(activeElement);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement;
      EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
      return syntheticEvent;
    }
    return null;
  }
  var SelectEventPlugin = {
    eventTypes: eventTypes,
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (!hasListener) {
        return null;
      }
      var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
      switch (topLevelType) {
        case 'topFocus':
          if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
            activeElement = targetNode;
            activeElementInst = targetInst;
            lastSelection = null;
          }
          break;
        case 'topBlur':
          activeElement = null;
          activeElementInst = null;
          lastSelection = null;
          break;
        case 'topMouseDown':
          mouseDown = true;
          break;
        case 'topContextMenu':
        case 'topMouseUp':
          mouseDown = false;
          return constructSelectEvent(nativeEvent, nativeEventTarget);
        case 'topSelectionChange':
          if (skipSelectionChangeEvent) {
            break;
          }
        case 'topKeyDown':
        case 'topKeyUp':
          return constructSelectEvent(nativeEvent, nativeEventTarget);
      }
      return null;
    },
    didPutListener: function (inst, registrationName, listener) {
      if (registrationName === 'onSelect') {
        hasListener = true;
      }
    }
  };
  module.exports = SelectEventPlugin;
});
$__System.registerDynamic('5f', ['45', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var emptyFunction = $__require('45');
    var EventListener = {
      listen: function listen(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, false);
          return { remove: function remove() {
              target.removeEventListener(eventType, callback, false);
            } };
        } else if (target.attachEvent) {
          target.attachEvent('on' + eventType, callback);
          return { remove: function remove() {
              target.detachEvent('on' + eventType, callback);
            } };
        }
      },
      capture: function capture(target, eventType, callback) {
        if (target.addEventListener) {
          target.addEventListener(eventType, callback, true);
          return { remove: function remove() {
              target.removeEventListener(eventType, callback, true);
            } };
        } else {
          if ('production' !== 'production') {
            console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
          }
          return { remove: emptyFunction };
        }
      },
      registerDefault: function registerDefault() {}
    };
    module.exports = EventListener;
  })($__require('15'));
});
$__System.registerDynamic('b', ['e', '61', '6f', '70', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var EventPluginHub = $__require('e');
    var EventPluginUtils = $__require('61');
    var accumulateInto = $__require('6f');
    var forEachAccumulated = $__require('70');
    var warning = $__require('24');
    var getListener = EventPluginHub.getListener;
    function listenerAtPhase(inst, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(inst, registrationName);
    }
    function accumulateDirectionalDispatches(inst, phase, event) {
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
      }
      var listener = listenerAtPhase(inst, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }
    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        var targetInst = event._targetInst;
        var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
        EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
      }
    }
    function accumulateDispatches(inst, ignoredDirection, event) {
      if (event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(inst, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }
    }
    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event._targetInst, null, event);
      }
    }
    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }
    function accumulateTwoPhaseDispatchesSkipTarget(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }
    function accumulateEnterLeaveDispatches(leave, enter, from, to) {
      EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
    }
    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }
    var EventPropagators = {
      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
      accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
      accumulateDirectDispatches: accumulateDirectDispatches,
      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
    };
    module.exports = EventPropagators;
  })($__require('15'));
});
$__System.registerDynamic('71', ['8'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('8');
  var AnimationEventInterface = {
    animationName: null,
    elapsedTime: null,
    pseudoElement: null
  };
  function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
  module.exports = SyntheticAnimationEvent;
});
$__System.registerDynamic('72', ['8'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('8');
  var ClipboardEventInterface = { clipboardData: function (event) {
      return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
    } };
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
  module.exports = SyntheticClipboardEvent;
});
$__System.registerDynamic('73', ['74'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('74');
  var FocusEventInterface = { relatedTarget: null };
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
  module.exports = SyntheticFocusEvent;
});
$__System.registerDynamic('75', ['76'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var getEventCharCode = $__require('76');
  var normalizeKey = {
    Esc: 'Escape',
    Spacebar: ' ',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Win: 'OS',
    Menu: 'ContextMenu',
    Apps: 'ContextMenu',
    Scroll: 'ScrollLock',
    MozPrintableKey: 'Unidentified'
  };
  var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta'
  };
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }
  module.exports = getEventKey;
});
$__System.registerDynamic('77', ['74', '76', '75', '78'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('74');
  var getEventCharCode = $__require('76');
  var getEventKey = $__require('75');
  var getEventModifierState = $__require('78');
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function (event) {
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function (event) {
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
  module.exports = SyntheticKeyboardEvent;
});
$__System.registerDynamic('79', ['18'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('18');
  var DragEventInterface = { dataTransfer: null };
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
  module.exports = SyntheticDragEvent;
});
$__System.registerDynamic('7a', ['74', '78'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('74');
  var getEventModifierState = $__require('78');
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
  module.exports = SyntheticTouchEvent;
});
$__System.registerDynamic('7b', ['8'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('8');
  var TransitionEventInterface = {
    propertyName: null,
    elapsedTime: null,
    pseudoElement: null
  };
  function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
  module.exports = SyntheticTransitionEvent;
});
$__System.registerDynamic('8', ['6', '4', '45', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var PooledClass = $__require('4');
    var emptyFunction = $__require('45');
    var warning = $__require('24');
    var didWarnForAddedNewProperty = false;
    var isProxySupported = typeof Proxy === 'function';
    var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
    var EventInterface = {
      type: null,
      target: null,
      currentTarget: emptyFunction.thatReturnsNull,
      eventPhase: null,
      bubbles: null,
      cancelable: null,
      timeStamp: function (event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: null,
      isTrusted: null
    };
    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
      if ('production' !== 'production') {
        delete this.nativeEvent;
        delete this.preventDefault;
        delete this.stopPropagation;
      }
      this.dispatchConfig = dispatchConfig;
      this._targetInst = targetInst;
      this.nativeEvent = nativeEvent;
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if (!Interface.hasOwnProperty(propName)) {
          continue;
        }
        if ('production' !== 'production') {
          delete this[propName];
        }
        var normalize = Interface[propName];
        if (normalize) {
          this[propName] = normalize(nativeEvent);
        } else {
          if (propName === 'target') {
            this.target = nativeEventTarget;
          } else {
            this[propName] = nativeEvent[propName];
          }
        }
      }
      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
      if (defaultPrevented) {
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      } else {
        this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
      }
      this.isPropagationStopped = emptyFunction.thatReturnsFalse;
      return this;
    }
    _assign(SyntheticEvent.prototype, {
      preventDefault: function () {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        if (!event) {
          return;
        }
        if (event.preventDefault) {
          event.preventDefault();
        } else if (typeof event.returnValue !== 'unknown') {
          event.returnValue = false;
        }
        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
      },
      stopPropagation: function () {
        var event = this.nativeEvent;
        if (!event) {
          return;
        }
        if (event.stopPropagation) {
          event.stopPropagation();
        } else if (typeof event.cancelBubble !== 'unknown') {
          event.cancelBubble = true;
        }
        this.isPropagationStopped = emptyFunction.thatReturnsTrue;
      },
      persist: function () {
        this.isPersistent = emptyFunction.thatReturnsTrue;
      },
      isPersistent: emptyFunction.thatReturnsFalse,
      destructor: function () {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
          if ('production' !== 'production') {
            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
          } else {
            this[propName] = null;
          }
        }
        for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
          this[shouldBeReleasedProperties[i]] = null;
        }
        if ('production' !== 'production') {
          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
        }
      }
    });
    SyntheticEvent.Interface = EventInterface;
    if ('production' !== 'production') {
      if (isProxySupported) {
        SyntheticEvent = new Proxy(SyntheticEvent, {
          construct: function (target, args) {
            return this.apply(target, Object.create(target.prototype), args);
          },
          apply: function (constructor, that, args) {
            return new Proxy(constructor.apply(that, args), { set: function (target, prop, value) {
                if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                  'production' !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
                  didWarnForAddedNewProperty = true;
                }
                target[prop] = value;
                return true;
              } });
          }
        });
      }
    }
    SyntheticEvent.augmentClass = function (Class, Interface) {
      var Super = this;
      var E = function () {};
      E.prototype = Super.prototype;
      var prototype = new E();
      _assign(prototype, Class.prototype);
      Class.prototype = prototype;
      Class.prototype.constructor = Class;
      Class.Interface = _assign({}, Super.Interface, Interface);
      Class.augmentClass = Super.augmentClass;
      PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
    };
    PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
    module.exports = SyntheticEvent;
    function getPooledWarningPropertyDefinition(propName, getVal) {
      var isFunction = typeof getVal === 'function';
      return {
        configurable: true,
        set: set,
        get: get
      };
      function set(val) {
        var action = isFunction ? 'setting the method' : 'setting the property';
        warn(action, 'This is effectively a no-op');
        return val;
      }
      function get() {
        var action = isFunction ? 'accessing the method' : 'accessing the property';
        var result = isFunction ? 'This is a no-op function' : 'This is set to null';
        warn(action, result);
        return getVal;
      }
      function warn(action, result) {
        var warningCondition = false;
        'production' !== 'production' ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
      }
    }
  })($__require('15'));
});
$__System.registerDynamic('12', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Gets the target node from a native browser event by accounting for
   * inconsistencies in browser DOM APIs.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {DOMEventTarget} Target node.
   */

  var global = this || self,
      GLOBAL = global;
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;

    // Normalize SVG <use> element events #4963
    if (target.correspondingUseElement) {
      target = target.correspondingUseElement;
    }

    // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
    // @see http://www.quirksmode.org/js/events_properties.html
    return target.nodeType === 3 ? target.parentNode : target;
  }

  module.exports = getEventTarget;
});
$__System.registerDynamic('74', ['8', '12'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticEvent = $__require('8');
  var getEventTarget = $__require('12');
  var UIEventInterface = {
    view: function (event) {
      if (event.view) {
        return event.view;
      }
      var target = getEventTarget(event);
      if (target.window === target) {
        return target;
      }
      var doc = target.ownerDocument;
      if (doc) {
        return doc.defaultView || doc.parentWindow;
      } else {
        return window;
      }
    },
    detail: function (event) {
      return event.detail || 0;
    }
  };
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
  module.exports = SyntheticUIEvent;
});
$__System.registerDynamic('78', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Translation from modifier key to the associated property in the event.
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
   */

  var global = this || self,
      GLOBAL = global;
  var modifierKeyToProp = {
    Alt: 'altKey',
    Control: 'ctrlKey',
    Meta: 'metaKey',
    Shift: 'shiftKey'
  };

  // IE8 does not implement getModifierState so we simply map it to the only
  // modifier keys exposed by the event itself, does not support Lock-keys.
  // Currently, all major browsers except Chrome seems to support Lock-keys.
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }

  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }

  module.exports = getEventModifierState;
});
$__System.registerDynamic('18', ['74', '7c', '78'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticUIEvent = $__require('74');
  var ViewportMetrics = $__require('7c');
  var getEventModifierState = $__require('78');
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: function (event) {
      var button = event.button;
      if ('which' in event) {
        return button;
      }
      return button === 2 ? 2 : button === 4 ? 1 : 0;
    },
    buttons: null,
    relatedTarget: function (event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    },
    pageX: function (event) {
      return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
    },
    pageY: function (event) {
      return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
    }
  };
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
  module.exports = SyntheticMouseEvent;
});
$__System.registerDynamic('7d', ['18'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var SyntheticMouseEvent = $__require('18');
  var WheelEventInterface = {
    deltaX: function (event) {
      return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function (event) {
      return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
    },
    deltaZ: null,
    deltaMode: null
  };
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }
  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
  module.exports = SyntheticWheelEvent;
});
$__System.registerDynamic('76', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * `charCode` represents the actual "character code" and is safe to use with
   * `String.fromCharCode`. As such, only keys that correspond to printable
   * characters produce a valid `charCode`, the only exception to this is Enter.
   * The Tab-key is considered non-printable and does not have a `charCode`,
   * presumably because it does not produce a tab-character in browsers.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {number} Normalized `charCode` property.
   */

  var global = this || self,
      GLOBAL = global;
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;

    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;

      // FF does not set `charCode` for the Enter-key, check against `keyCode`.
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      // IE8 does not implement `charCode`, but `keyCode` has the correct value.
      charCode = keyCode;
    }

    // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
    // Must not discard the (non-)printable Enter-key.
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }

    return 0;
  }

  module.exports = getEventCharCode;
});
$__System.registerDynamic('7e', ['2e', '5f', 'b', 'f', '71', '72', '8', '73', '77', '18', '79', '7a', '7b', '74', '7d', '45', '76', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var EventListener = $__require('5f');
    var EventPropagators = $__require('b');
    var ReactDOMComponentTree = $__require('f');
    var SyntheticAnimationEvent = $__require('71');
    var SyntheticClipboardEvent = $__require('72');
    var SyntheticEvent = $__require('8');
    var SyntheticFocusEvent = $__require('73');
    var SyntheticKeyboardEvent = $__require('77');
    var SyntheticMouseEvent = $__require('18');
    var SyntheticDragEvent = $__require('79');
    var SyntheticTouchEvent = $__require('7a');
    var SyntheticTransitionEvent = $__require('7b');
    var SyntheticUIEvent = $__require('74');
    var SyntheticWheelEvent = $__require('7d');
    var emptyFunction = $__require('45');
    var getEventCharCode = $__require('76');
    var invariant = $__require('30');
    var eventTypes = {};
    var topLevelEventsToDispatchConfig = {};
    ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
      var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
      var onEvent = 'on' + capitalizedEvent;
      var topEvent = 'top' + capitalizedEvent;
      var type = {
        phasedRegistrationNames: {
          bubbled: onEvent,
          captured: onEvent + 'Capture'
        },
        dependencies: [topEvent]
      };
      eventTypes[event] = type;
      topLevelEventsToDispatchConfig[topEvent] = type;
    });
    var onClickListeners = {};
    function getDictionaryKey(inst) {
      return '.' + inst._rootNodeID;
    }
    function isInteractive(tag) {
      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    var SimpleEventPlugin = {
      eventTypes: eventTypes,
      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
        if (!dispatchConfig) {
          return null;
        }
        var EventConstructor;
        switch (topLevelType) {
          case 'topAbort':
          case 'topCanPlay':
          case 'topCanPlayThrough':
          case 'topDurationChange':
          case 'topEmptied':
          case 'topEncrypted':
          case 'topEnded':
          case 'topError':
          case 'topInput':
          case 'topInvalid':
          case 'topLoad':
          case 'topLoadedData':
          case 'topLoadedMetadata':
          case 'topLoadStart':
          case 'topPause':
          case 'topPlay':
          case 'topPlaying':
          case 'topProgress':
          case 'topRateChange':
          case 'topReset':
          case 'topSeeked':
          case 'topSeeking':
          case 'topStalled':
          case 'topSubmit':
          case 'topSuspend':
          case 'topTimeUpdate':
          case 'topVolumeChange':
          case 'topWaiting':
            EventConstructor = SyntheticEvent;
            break;
          case 'topKeyPress':
            if (getEventCharCode(nativeEvent) === 0) {
              return null;
            }
          case 'topKeyDown':
          case 'topKeyUp':
            EventConstructor = SyntheticKeyboardEvent;
            break;
          case 'topBlur':
          case 'topFocus':
            EventConstructor = SyntheticFocusEvent;
            break;
          case 'topClick':
            if (nativeEvent.button === 2) {
              return null;
            }
          case 'topDoubleClick':
          case 'topMouseDown':
          case 'topMouseMove':
          case 'topMouseUp':
          case 'topMouseOut':
          case 'topMouseOver':
          case 'topContextMenu':
            EventConstructor = SyntheticMouseEvent;
            break;
          case 'topDrag':
          case 'topDragEnd':
          case 'topDragEnter':
          case 'topDragExit':
          case 'topDragLeave':
          case 'topDragOver':
          case 'topDragStart':
          case 'topDrop':
            EventConstructor = SyntheticDragEvent;
            break;
          case 'topTouchCancel':
          case 'topTouchEnd':
          case 'topTouchMove':
          case 'topTouchStart':
            EventConstructor = SyntheticTouchEvent;
            break;
          case 'topAnimationEnd':
          case 'topAnimationIteration':
          case 'topAnimationStart':
            EventConstructor = SyntheticAnimationEvent;
            break;
          case 'topTransitionEnd':
            EventConstructor = SyntheticTransitionEvent;
            break;
          case 'topScroll':
            EventConstructor = SyntheticUIEvent;
            break;
          case 'topWheel':
            EventConstructor = SyntheticWheelEvent;
            break;
          case 'topCopy':
          case 'topCut':
          case 'topPaste':
            EventConstructor = SyntheticClipboardEvent;
            break;
        }
        !EventConstructor ? 'production' !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
        var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      },
      didPutListener: function (inst, registrationName, listener) {
        if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
          var key = getDictionaryKey(inst);
          var node = ReactDOMComponentTree.getNodeFromInstance(inst);
          if (!onClickListeners[key]) {
            onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
          }
        }
      },
      willDeleteListener: function (inst, registrationName) {
        if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
          var key = getDictionaryKey(inst);
          onClickListeners[key].remove();
          delete onClickListeners[key];
        }
      }
    };
    module.exports = SimpleEventPlugin;
  })($__require('15'));
});
$__System.registerDynamic('7f', ['2', 'a', 'd', '16', '17', '19', '1d', '4a', 'f', '52', '53', '5b', '5c', '5e', '60', '64', '67', '6e', '7e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ARIADOMPropertyConfig = $__require('2');
  var BeforeInputEventPlugin = $__require('a');
  var ChangeEventPlugin = $__require('d');
  var DefaultEventPluginOrder = $__require('16');
  var EnterLeaveEventPlugin = $__require('17');
  var HTMLDOMPropertyConfig = $__require('19');
  var ReactComponentBrowserEnvironment = $__require('1d');
  var ReactDOMComponent = $__require('4a');
  var ReactDOMComponentTree = $__require('f');
  var ReactDOMEmptyComponent = $__require('52');
  var ReactDOMTreeTraversal = $__require('53');
  var ReactDOMTextComponent = $__require('5b');
  var ReactDefaultBatchingStrategy = $__require('5c');
  var ReactEventListener = $__require('5e');
  var ReactInjection = $__require('60');
  var ReactReconcileTransaction = $__require('64');
  var SVGDOMPropertyConfig = $__require('67');
  var SelectEventPlugin = $__require('6e');
  var SimpleEventPlugin = $__require('7e');
  var alreadyInjected = false;
  function inject() {
    if (alreadyInjected) {
      return;
    }
    alreadyInjected = true;
    ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
    ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
    ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
    ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
    ReactInjection.EventPluginHub.injectEventPluginsByName({
      SimpleEventPlugin: SimpleEventPlugin,
      EnterLeaveEventPlugin: EnterLeaveEventPlugin,
      ChangeEventPlugin: ChangeEventPlugin,
      SelectEventPlugin: SelectEventPlugin,
      BeforeInputEventPlugin: BeforeInputEventPlugin
    });
    ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
    ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
    ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
    ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
      return new ReactDOMEmptyComponent(instantiate);
    });
    ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
    ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
    ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
  }
  module.exports = { inject: inject };
});
$__System.registerDynamic('80', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  module.exports = '15.6.1';
});
$__System.registerDynamic('81', ['2e', '40', 'f', '44', '82', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var ReactCurrentOwner = $__require('40');
    var ReactDOMComponentTree = $__require('f');
    var ReactInstanceMap = $__require('44');
    var getHostComponentFromComposite = $__require('82');
    var invariant = $__require('30');
    var warning = $__require('24');
    function findDOMNode(componentOrElement) {
      if ('production' !== 'production') {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          'production' !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
          owner._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrElement == null) {
        return null;
      }
      if (componentOrElement.nodeType === 1) {
        return componentOrElement;
      }
      var inst = ReactInstanceMap.get(componentOrElement);
      if (inst) {
        inst = getHostComponentFromComposite(inst);
        return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
      }
      if (typeof componentOrElement.render === 'function') {
        !false ? 'production' !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
      } else {
        !false ? 'production' !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
      }
    }
    module.exports = findDOMNode;
  })($__require('15'));
});
$__System.registerDynamic('82', ['83'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactNodeTypes = $__require('83');
  function getHostComponentFromComposite(inst) {
    var type;
    while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
      inst = inst._renderedComponent;
    }
    if (type === ReactNodeTypes.HOST) {
      return inst._renderedComponent;
    } else if (type === ReactNodeTypes.EMPTY) {
      return null;
    }
  }
  module.exports = getHostComponentFromComposite;
});
$__System.registerDynamic('2b', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * Based on the escape-html library, which is used under the MIT License below:
   *
   * Copyright (c) 2012-2013 TJ Holowaychuk
   * Copyright (c) 2015 Andreas Lubbe
   * Copyright (c) 2015 Tiancheng "Timothy" Gu
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * 'Software'), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
   * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
   * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
   * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   */

  'use strict';

  // code copied and modified from escape-html
  /**
   * Module variables.
   * @private
   */

  var global = this || self,
      GLOBAL = global;
  var matchHtmlRegExp = /["'&<>]/;

  /**
   * Escape special characters in the given string of html.
   *
   * @param  {string} string The string to escape for inserting into HTML
   * @return {string}
   * @public
   */

  function escapeHtml(string) {
    var str = '' + string;
    var match = matchHtmlRegExp.exec(str);

    if (!match) {
      return str;
    }

    var escape;
    var html = '';
    var index = 0;
    var lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          // "
          escape = '&quot;';
          break;
        case 38:
          // &
          escape = '&amp;';
          break;
        case 39:
          // '
          escape = '&#x27;'; // modified from escape-html; used to be '&#39'
          break;
        case 60:
          // <
          escape = '&lt;';
          break;
        case 62:
          // >
          escape = '&gt;';
          break;
        default:
          continue;
      }

      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }

      lastIndex = index + 1;
      html += escape;
    }

    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  // end code copied and modified from escape-html

  /**
   * Escapes text to prevent scripting attacks.
   *
   * @param {*} text Text value to escape.
   * @return {string} An escaped string.
   */
  function escapeTextContentForBrowser(text) {
    if (typeof text === 'boolean' || typeof text === 'number') {
      // this shortcircuit helps perf for types that we know will never have
      // special characters, especially given that this function is used often
      // for numeric dom ids.
      return '' + text;
    }
    return escapeHtml(text);
  }

  module.exports = escapeTextContentForBrowser;
});
$__System.registerDynamic('5a', ['c', '2b', '59'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('c');
  var escapeTextContentForBrowser = $__require('2b');
  var setInnerHTML = $__require('59');
  var setTextContent = function (node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  };
  if (ExecutionEnvironment.canUseDOM) {
    if (!('textContent' in document.documentElement)) {
      setTextContent = function (node, text) {
        if (node.nodeType === 3) {
          node.nodeValue = text;
          return;
        }
        setInnerHTML(node, escapeTextContentForBrowser(text));
      };
    }
  }
  module.exports = setTextContent;
});
$__System.registerDynamic('4b', ['4c', '59', '58', '5a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var DOMNamespaces = $__require('4c');
  var setInnerHTML = $__require('59');
  var createMicrosoftUnsafeLocalFunction = $__require('58');
  var setTextContent = $__require('5a');
  var ELEMENT_NODE_TYPE = 1;
  var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
  var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
  function insertTreeChildren(tree) {
    if (!enableLazy) {
      return;
    }
    var node = tree.node;
    var children = tree.children;
    if (children.length) {
      for (var i = 0; i < children.length; i++) {
        insertTreeBefore(node, children[i], null);
      }
    } else if (tree.html != null) {
      setInnerHTML(node, tree.html);
    } else if (tree.text != null) {
      setTextContent(node, tree.text);
    }
  }
  var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
    if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
      insertTreeChildren(tree);
      parentNode.insertBefore(tree.node, referenceNode);
    } else {
      parentNode.insertBefore(tree.node, referenceNode);
      insertTreeChildren(tree);
    }
  });
  function replaceChildWithTree(oldNode, newTree) {
    oldNode.parentNode.replaceChild(newTree.node, oldNode);
    insertTreeChildren(newTree);
  }
  function queueChild(parentTree, childTree) {
    if (enableLazy) {
      parentTree.children.push(childTree);
    } else {
      parentTree.node.appendChild(childTree.node);
    }
  }
  function queueHTML(tree, html) {
    if (enableLazy) {
      tree.html = html;
    } else {
      setInnerHTML(tree.node, html);
    }
  }
  function queueText(tree, text) {
    if (enableLazy) {
      tree.text = text;
    } else {
      setTextContent(tree.node, text);
    }
  }
  function toString() {
    return this.node.nodeName;
  }
  function DOMLazyTree(node) {
    return {
      node: node,
      children: [],
      html: null,
      text: null,
      toString: toString
    };
  }
  DOMLazyTree.insertTreeBefore = insertTreeBefore;
  DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
  DOMLazyTree.queueChild = queueChild;
  DOMLazyTree.queueHTML = queueHTML;
  DOMLazyTree.queueText = queueText;
  module.exports = DOMLazyTree;
});
$__System.registerDynamic('61', ['2e', '84', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var ReactErrorUtils = $__require('84');
    var invariant = $__require('30');
    var warning = $__require('24');
    var ComponentTree;
    var TreeTraversal;
    var injection = {
      injectComponentTree: function (Injected) {
        ComponentTree = Injected;
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
        }
      },
      injectTreeTraversal: function (Injected) {
        TreeTraversal = Injected;
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
        }
      }
    };
    function isEndish(topLevelType) {
      return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
    }
    function isMoveish(topLevelType) {
      return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
    }
    function isStartish(topLevelType) {
      return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
    }
    var validateEventDispatches;
    if ('production' !== 'production') {
      validateEventDispatches = function (event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;
        var listenersIsArr = Array.isArray(dispatchListeners);
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
        var instancesIsArr = Array.isArray(dispatchInstances);
        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
        'production' !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
      };
    }
    function executeDispatch(event, simulated, listener, inst) {
      var type = event.type || 'unknown-event';
      event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
      if (simulated) {
        ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
      } else {
        ReactErrorUtils.invokeGuardedCallback(type, listener, event);
      }
      event.currentTarget = null;
    }
    function executeDispatchesInOrder(event, simulated) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      if ('production' !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
        }
      } else if (dispatchListeners) {
        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
      }
      event._dispatchListeners = null;
      event._dispatchInstances = null;
    }
    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      if ('production' !== 'production') {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }
          if (dispatchListeners[i](event, dispatchInstances[i])) {
            return dispatchInstances[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchInstances)) {
          return dispatchInstances;
        }
      }
      return null;
    }
    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchInstances = null;
      event._dispatchListeners = null;
      return ret;
    }
    function executeDirectDispatch(event) {
      if ('production' !== 'production') {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchInstance = event._dispatchInstances;
      !!Array.isArray(dispatchListener) ? 'production' !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
      event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
      var res = dispatchListener ? dispatchListener(event) : null;
      event.currentTarget = null;
      event._dispatchListeners = null;
      event._dispatchInstances = null;
      return res;
    }
    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }
    var EventPluginUtils = {
      isEndish: isEndish,
      isMoveish: isMoveish,
      isStartish: isStartish,
      executeDirectDispatch: executeDirectDispatch,
      executeDispatchesInOrder: executeDispatchesInOrder,
      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
      hasDispatches: hasDispatches,
      getInstanceFromNode: function (node) {
        return ComponentTree.getInstanceFromNode(node);
      },
      getNodeFromInstance: function (node) {
        return ComponentTree.getNodeFromInstance(node);
      },
      isAncestor: function (a, b) {
        return TreeTraversal.isAncestor(a, b);
      },
      getLowestCommonAncestor: function (a, b) {
        return TreeTraversal.getLowestCommonAncestor(a, b);
      },
      getParentInstance: function (inst) {
        return TreeTraversal.getParentInstance(inst);
      },
      traverseTwoPhase: function (target, fn, arg) {
        return TreeTraversal.traverseTwoPhase(target, fn, arg);
      },
      traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
        return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
      },
      injection: injection
    };
    module.exports = EventPluginUtils;
  })($__require('15'));
});
$__System.registerDynamic('6f', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    function accumulateInto(current, next) {
      !(next != null) ? 'production' !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
      if (current == null) {
        return next;
      }
      if (Array.isArray(current)) {
        if (Array.isArray(next)) {
          current.push.apply(current, next);
          return current;
        }
        current.push(next);
        return current;
      }
      if (Array.isArray(next)) {
        return [current].concat(next);
      }
      return [current, next];
    }
    module.exports = accumulateInto;
  })($__require('15'));
});
$__System.registerDynamic('70', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * @param {array} arr an "accumulation" of items which is either an Array or
   * a single item. Useful when paired with the `accumulate` module. This is a
   * simple utility that allows us to reason about a collection of items, but
   * handling the case when there is exactly one item (and we do not need to
   * allocate an array).
   */

  var global = this || self,
      GLOBAL = global;
  function forEachAccumulated(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  }

  module.exports = forEachAccumulated;
});
$__System.registerDynamic('e', ['2e', '4d', '61', '84', '6f', '70', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var EventPluginRegistry = $__require('4d');
    var EventPluginUtils = $__require('61');
    var ReactErrorUtils = $__require('84');
    var accumulateInto = $__require('6f');
    var forEachAccumulated = $__require('70');
    var invariant = $__require('30');
    var listenerBank = {};
    var eventQueue = null;
    var executeDispatchesAndRelease = function (event, simulated) {
      if (event) {
        EventPluginUtils.executeDispatchesInOrder(event, simulated);
        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var executeDispatchesAndReleaseSimulated = function (e) {
      return executeDispatchesAndRelease(e, true);
    };
    var executeDispatchesAndReleaseTopLevel = function (e) {
      return executeDispatchesAndRelease(e, false);
    };
    var getDictionaryKey = function (inst) {
      return '.' + inst._rootNodeID;
    };
    function isInteractive(tag) {
      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
    }
    function shouldPreventMouseEvent(name, type, props) {
      switch (name) {
        case 'onClick':
        case 'onClickCapture':
        case 'onDoubleClick':
        case 'onDoubleClickCapture':
        case 'onMouseDown':
        case 'onMouseDownCapture':
        case 'onMouseMove':
        case 'onMouseMoveCapture':
        case 'onMouseUp':
        case 'onMouseUpCapture':
          return !!(props.disabled && isInteractive(type));
        default:
          return false;
      }
    }
    var EventPluginHub = {
      injection: {
        injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
        injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
      },
      putListener: function (inst, registrationName, listener) {
        !(typeof listener === 'function') ? 'production' !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
        var key = getDictionaryKey(inst);
        var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
        bankForRegistrationName[key] = listener;
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.didPutListener) {
          PluginModule.didPutListener(inst, registrationName, listener);
        }
      },
      getListener: function (inst, registrationName) {
        var bankForRegistrationName = listenerBank[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
          return null;
        }
        var key = getDictionaryKey(inst);
        return bankForRegistrationName && bankForRegistrationName[key];
      },
      deleteListener: function (inst, registrationName) {
        var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
        if (PluginModule && PluginModule.willDeleteListener) {
          PluginModule.willDeleteListener(inst, registrationName);
        }
        var bankForRegistrationName = listenerBank[registrationName];
        if (bankForRegistrationName) {
          var key = getDictionaryKey(inst);
          delete bankForRegistrationName[key];
        }
      },
      deleteAllListeners: function (inst) {
        var key = getDictionaryKey(inst);
        for (var registrationName in listenerBank) {
          if (!listenerBank.hasOwnProperty(registrationName)) {
            continue;
          }
          if (!listenerBank[registrationName][key]) {
            continue;
          }
          var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
          if (PluginModule && PluginModule.willDeleteListener) {
            PluginModule.willDeleteListener(inst, registrationName);
          }
          delete listenerBank[registrationName][key];
        }
      },
      extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        var events;
        var plugins = EventPluginRegistry.plugins;
        for (var i = 0; i < plugins.length; i++) {
          var possiblePlugin = plugins[i];
          if (possiblePlugin) {
            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
            if (extractedEvents) {
              events = accumulateInto(events, extractedEvents);
            }
          }
        }
        return events;
      },
      enqueueEvents: function (events) {
        if (events) {
          eventQueue = accumulateInto(eventQueue, events);
        }
      },
      processEventQueue: function (simulated) {
        var processingEventQueue = eventQueue;
        eventQueue = null;
        if (simulated) {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
        } else {
          forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
        }
        !!eventQueue ? 'production' !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
        ReactErrorUtils.rethrowCaughtError();
      },
      __purge: function () {
        listenerBank = {};
      },
      __getListenerBank: function () {
        return listenerBank;
      }
    };
    module.exports = EventPluginHub;
  })($__require('15'));
});
$__System.registerDynamic('85', ['e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var EventPluginHub = $__require('e');
  function runEventQueueInBatch(events) {
    EventPluginHub.enqueueEvents(events);
    EventPluginHub.processEventQueue(false);
  }
  var ReactEventEmitterMixin = { handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      runEventQueueInBatch(events);
    } };
  module.exports = ReactEventEmitterMixin;
});
$__System.registerDynamic('7c', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ViewportMetrics = {
    currentScrollLeft: 0,

    currentScrollTop: 0,

    refreshScrollValues: function (scrollPosition) {
      ViewportMetrics.currentScrollLeft = scrollPosition.x;
      ViewportMetrics.currentScrollTop = scrollPosition.y;
    }
  };

  module.exports = ViewportMetrics;
});
$__System.registerDynamic('86', ['c'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('c');

  /**
   * Generate a mapping of standard vendor prefixes using the defined style property and event name.
   *
   * @param {string} styleProp
   * @param {string} eventName
   * @returns {object}
   */
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};

    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes['Webkit' + styleProp] = 'webkit' + eventName;
    prefixes['Moz' + styleProp] = 'moz' + eventName;
    prefixes['ms' + styleProp] = 'MS' + eventName;
    prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

    return prefixes;
  }

  /**
   * A list of event names to a configurable list of vendor prefixes.
   */
  var vendorPrefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
    animationstart: makePrefixMap('Animation', 'AnimationStart'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };

  /**
   * Event names that have already been detected and prefixed (if applicable).
   */
  var prefixedEventNames = {};

  /**
   * Element to check for prefixes on.
   */
  var style = {};

  /**
   * Bootstrap if a DOM exists.
   */
  if (ExecutionEnvironment.canUseDOM) {
    style = document.createElement('div').style;

    // On some platforms, in particular some releases of Android 4.x,
    // the un-prefixed "animation" and "transition" properties are defined on the
    // style object but the events that fire will still be prefixed, so we need
    // to check if the un-prefixed events are usable, and if not remove them from the map.
    if (!('AnimationEvent' in window)) {
      delete vendorPrefixes.animationend.animation;
      delete vendorPrefixes.animationiteration.animation;
      delete vendorPrefixes.animationstart.animation;
    }

    // Same as above
    if (!('TransitionEvent' in window)) {
      delete vendorPrefixes.transitionend.transition;
    }
  }

  /**
   * Attempts to determine the correct vendor prefixed event name.
   *
   * @param {string} eventName
   * @returns {string}
   */
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    } else if (!vendorPrefixes[eventName]) {
      return eventName;
    }

    var prefixMap = vendorPrefixes[eventName];

    for (var styleProp in prefixMap) {
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
        return prefixedEventNames[eventName] = prefixMap[styleProp];
      }
    }

    return '';
  }

  module.exports = getVendorPrefixedEventName;
});
$__System.registerDynamic('13', ['c'], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('c');

  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
  }

  /**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }

    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;

    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }

  module.exports = isEventSupported;
});
$__System.registerDynamic('4e', ['6', '4d', '85', '7c', '86', '13', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var EventPluginRegistry = $__require('4d');
    var ReactEventEmitterMixin = $__require('85');
    var ViewportMetrics = $__require('7c');
    var getVendorPrefixedEventName = $__require('86');
    var isEventSupported = $__require('13');
    var hasEventPageXY;
    var alreadyListeningTo = {};
    var isMonitoringScrollValue = false;
    var reactTopListenersCounter = 0;
    var topEventMapping = {
      topAbort: 'abort',
      topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
      topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
      topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
      topBlur: 'blur',
      topCanPlay: 'canplay',
      topCanPlayThrough: 'canplaythrough',
      topChange: 'change',
      topClick: 'click',
      topCompositionEnd: 'compositionend',
      topCompositionStart: 'compositionstart',
      topCompositionUpdate: 'compositionupdate',
      topContextMenu: 'contextmenu',
      topCopy: 'copy',
      topCut: 'cut',
      topDoubleClick: 'dblclick',
      topDrag: 'drag',
      topDragEnd: 'dragend',
      topDragEnter: 'dragenter',
      topDragExit: 'dragexit',
      topDragLeave: 'dragleave',
      topDragOver: 'dragover',
      topDragStart: 'dragstart',
      topDrop: 'drop',
      topDurationChange: 'durationchange',
      topEmptied: 'emptied',
      topEncrypted: 'encrypted',
      topEnded: 'ended',
      topError: 'error',
      topFocus: 'focus',
      topInput: 'input',
      topKeyDown: 'keydown',
      topKeyPress: 'keypress',
      topKeyUp: 'keyup',
      topLoadedData: 'loadeddata',
      topLoadedMetadata: 'loadedmetadata',
      topLoadStart: 'loadstart',
      topMouseDown: 'mousedown',
      topMouseMove: 'mousemove',
      topMouseOut: 'mouseout',
      topMouseOver: 'mouseover',
      topMouseUp: 'mouseup',
      topPaste: 'paste',
      topPause: 'pause',
      topPlay: 'play',
      topPlaying: 'playing',
      topProgress: 'progress',
      topRateChange: 'ratechange',
      topScroll: 'scroll',
      topSeeked: 'seeked',
      topSeeking: 'seeking',
      topSelectionChange: 'selectionchange',
      topStalled: 'stalled',
      topSuspend: 'suspend',
      topTextInput: 'textInput',
      topTimeUpdate: 'timeupdate',
      topTouchCancel: 'touchcancel',
      topTouchEnd: 'touchend',
      topTouchMove: 'touchmove',
      topTouchStart: 'touchstart',
      topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
      topVolumeChange: 'volumechange',
      topWaiting: 'waiting',
      topWheel: 'wheel'
    };
    var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
    function getListeningForDocument(mountAt) {
      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
        mountAt[topListenersIDKey] = reactTopListenersCounter++;
        alreadyListeningTo[mountAt[topListenersIDKey]] = {};
      }
      return alreadyListeningTo[mountAt[topListenersIDKey]];
    }
    var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
      ReactEventListener: null,
      injection: { injectReactEventListener: function (ReactEventListener) {
          ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
          ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
        } },
      setEnabled: function (enabled) {
        if (ReactBrowserEventEmitter.ReactEventListener) {
          ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
        }
      },
      isEnabled: function () {
        return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
      },
      listenTo: function (registrationName, contentDocumentHandle) {
        var mountAt = contentDocumentHandle;
        var isListening = getListeningForDocument(mountAt);
        var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
        for (var i = 0; i < dependencies.length; i++) {
          var dependency = dependencies[i];
          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
            if (dependency === 'topWheel') {
              if (isEventSupported('wheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
              } else if (isEventSupported('mousewheel')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
              }
            } else if (dependency === 'topScroll') {
              if (isEventSupported('scroll', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
              } else {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
              }
            } else if (dependency === 'topFocus' || dependency === 'topBlur') {
              if (isEventSupported('focus', true)) {
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
              } else if (isEventSupported('focusin')) {
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
                ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
              }
              isListening.topBlur = true;
              isListening.topFocus = true;
            } else if (topEventMapping.hasOwnProperty(dependency)) {
              ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
            }
            isListening[dependency] = true;
          }
        }
      },
      trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
      },
      trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
        return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
      },
      supportsEventPageXY: function () {
        if (!document.createEvent) {
          return false;
        }
        var ev = document.createEvent('MouseEvent');
        return ev != null && 'pageX' in ev;
      },
      ensureScrollValueMonitoring: function () {
        if (hasEventPageXY === undefined) {
          hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
        }
        if (!hasEventPageXY && !isMonitoringScrollValue) {
          var refresh = ViewportMetrics.refreshScrollValues;
          ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
          isMonitoringScrollValue = true;
        }
      }
    });
    module.exports = ReactBrowserEventEmitter;
  })($__require('15'));
});
$__System.registerDynamic('4f', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2015-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactDOMComponentFlags = {
    hasCachedChildNodes: 1 << 0
  };

  module.exports = ReactDOMComponentFlags;
});
$__System.registerDynamic('f', ['2e', '1a', '4f', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var DOMProperty = $__require('1a');
    var ReactDOMComponentFlags = $__require('4f');
    var invariant = $__require('30');
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var Flags = ReactDOMComponentFlags;
    var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
    function shouldPrecacheNode(node, nodeID) {
      return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
    }
    function getRenderedHostOrTextFromComponent(component) {
      var rendered;
      while (rendered = component._renderedComponent) {
        component = rendered;
      }
      return component;
    }
    function precacheNode(inst, node) {
      var hostInst = getRenderedHostOrTextFromComponent(inst);
      hostInst._hostNode = node;
      node[internalInstanceKey] = hostInst;
    }
    function uncacheNode(inst) {
      var node = inst._hostNode;
      if (node) {
        delete node[internalInstanceKey];
        inst._hostNode = null;
      }
    }
    function precacheChildNodes(inst, node) {
      if (inst._flags & Flags.hasCachedChildNodes) {
        return;
      }
      var children = inst._renderedChildren;
      var childNode = node.firstChild;
      outer: for (var name in children) {
        if (!children.hasOwnProperty(name)) {
          continue;
        }
        var childInst = children[name];
        var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
        if (childID === 0) {
          continue;
        }
        for (; childNode !== null; childNode = childNode.nextSibling) {
          if (shouldPrecacheNode(childNode, childID)) {
            precacheNode(childInst, childNode);
            continue outer;
          }
        }
        !false ? 'production' !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
      }
      inst._flags |= Flags.hasCachedChildNodes;
    }
    function getClosestInstanceFromNode(node) {
      if (node[internalInstanceKey]) {
        return node[internalInstanceKey];
      }
      var parents = [];
      while (!node[internalInstanceKey]) {
        parents.push(node);
        if (node.parentNode) {
          node = node.parentNode;
        } else {
          return null;
        }
      }
      var closest;
      var inst;
      for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
        closest = inst;
        if (parents.length) {
          precacheChildNodes(inst, node);
        }
      }
      return closest;
    }
    function getInstanceFromNode(node) {
      var inst = getClosestInstanceFromNode(node);
      if (inst != null && inst._hostNode === node) {
        return inst;
      } else {
        return null;
      }
    }
    function getNodeFromInstance(inst) {
      !(inst._hostNode !== undefined) ? 'production' !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
      if (inst._hostNode) {
        return inst._hostNode;
      }
      var parents = [];
      while (!inst._hostNode) {
        parents.push(inst);
        !inst._hostParent ? 'production' !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
        inst = inst._hostParent;
      }
      for (; parents.length; inst = parents.pop()) {
        precacheChildNodes(inst, inst._hostNode);
      }
      return inst._hostNode;
    }
    var ReactDOMComponentTree = {
      getClosestInstanceFromNode: getClosestInstanceFromNode,
      getInstanceFromNode: getInstanceFromNode,
      getNodeFromInstance: getNodeFromInstance,
      precacheChildNodes: precacheChildNodes,
      precacheNode: precacheNode,
      uncacheNode: uncacheNode
    };
    module.exports = ReactDOMComponentTree;
  })($__require('15'));
});
$__System.registerDynamic('50', ['6', '45', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var emptyFunction = $__require('45');
    var warning = $__require('24');
    var validateDOMNesting = emptyFunction;
    if ('production' !== 'production') {
      var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
      var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', 'foreignObject', 'desc', 'title'];
      var buttonScopeTags = inScopeTags.concat(['button']);
      var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
      var emptyAncestorInfo = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      var updatedAncestorInfo = function (oldInfo, tag, instance) {
        var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
        var info = {
          tag: tag,
          instance: instance
        };
        if (inScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.aTagInScope = null;
          ancestorInfo.buttonTagInScope = null;
          ancestorInfo.nobrTagInScope = null;
        }
        if (buttonScopeTags.indexOf(tag) !== -1) {
          ancestorInfo.pTagInButtonScope = null;
        }
        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
          ancestorInfo.listItemTagAutoclosing = null;
          ancestorInfo.dlItemTagAutoclosing = null;
        }
        ancestorInfo.current = info;
        if (tag === 'form') {
          ancestorInfo.formTag = info;
        }
        if (tag === 'a') {
          ancestorInfo.aTagInScope = info;
        }
        if (tag === 'button') {
          ancestorInfo.buttonTagInScope = info;
        }
        if (tag === 'nobr') {
          ancestorInfo.nobrTagInScope = info;
        }
        if (tag === 'p') {
          ancestorInfo.pTagInButtonScope = info;
        }
        if (tag === 'li') {
          ancestorInfo.listItemTagAutoclosing = info;
        }
        if (tag === 'dd' || tag === 'dt') {
          ancestorInfo.dlItemTagAutoclosing = info;
        }
        return ancestorInfo;
      };
      var isTagValidWithParent = function (tag, parentTag) {
        switch (parentTag) {
          case 'select':
            return tag === 'option' || tag === 'optgroup' || tag === '#text';
          case 'optgroup':
            return tag === 'option' || tag === '#text';
          case 'option':
            return tag === '#text';
          case 'tr':
            return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'tbody':
          case 'thead':
          case 'tfoot':
            return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'colgroup':
            return tag === 'col' || tag === 'template';
          case 'table':
            return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'head':
            return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
          case 'html':
            return tag === 'head' || tag === 'body';
          case '#document':
            return tag === 'html';
        }
        switch (tag) {
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
          case 'rp':
          case 'rt':
            return impliedEndTags.indexOf(parentTag) === -1;
          case 'body':
          case 'caption':
          case 'col':
          case 'colgroup':
          case 'frame':
          case 'head':
          case 'html':
          case 'tbody':
          case 'td':
          case 'tfoot':
          case 'th':
          case 'thead':
          case 'tr':
            return parentTag == null;
        }
        return true;
      };
      var findInvalidAncestorForTag = function (tag, ancestorInfo) {
        switch (tag) {
          case 'address':
          case 'article':
          case 'aside':
          case 'blockquote':
          case 'center':
          case 'details':
          case 'dialog':
          case 'dir':
          case 'div':
          case 'dl':
          case 'fieldset':
          case 'figcaption':
          case 'figure':
          case 'footer':
          case 'header':
          case 'hgroup':
          case 'main':
          case 'menu':
          case 'nav':
          case 'ol':
          case 'p':
          case 'section':
          case 'summary':
          case 'ul':
          case 'pre':
          case 'listing':
          case 'table':
          case 'hr':
          case 'xmp':
          case 'h1':
          case 'h2':
          case 'h3':
          case 'h4':
          case 'h5':
          case 'h6':
            return ancestorInfo.pTagInButtonScope;
          case 'form':
            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
          case 'li':
            return ancestorInfo.listItemTagAutoclosing;
          case 'dd':
          case 'dt':
            return ancestorInfo.dlItemTagAutoclosing;
          case 'button':
            return ancestorInfo.buttonTagInScope;
          case 'a':
            return ancestorInfo.aTagInScope;
          case 'nobr':
            return ancestorInfo.nobrTagInScope;
        }
        return null;
      };
      var findOwnerStack = function (instance) {
        if (!instance) {
          return [];
        }
        var stack = [];
        do {
          stack.push(instance);
        } while (instance = instance._currentElement._owner);
        stack.reverse();
        return stack;
      };
      var didWarn = {};
      validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        if (childText != null) {
          'production' !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
          childTag = '#text';
        }
        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
        var problematic = invalidParent || invalidAncestor;
        if (problematic) {
          var ancestorTag = problematic.tag;
          var ancestorInstance = problematic.instance;
          var childOwner = childInstance && childInstance._currentElement._owner;
          var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
          var childOwners = findOwnerStack(childOwner);
          var ancestorOwners = findOwnerStack(ancestorOwner);
          var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
          var i;
          var deepestCommon = -1;
          for (i = 0; i < minStackLen; i++) {
            if (childOwners[i] === ancestorOwners[i]) {
              deepestCommon = i;
            } else {
              break;
            }
          }
          var UNKNOWN = '(unknown)';
          var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
            return inst.getName() || UNKNOWN;
          });
          var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
            return inst.getName() || UNKNOWN;
          });
          var ownerInfo = [].concat(deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag, invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
          var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
          if (didWarn[warnKey]) {
            return;
          }
          didWarn[warnKey] = true;
          var tagDisplayName = childTag;
          var whitespaceInfo = '';
          if (childTag === '#text') {
            if (/\S/.test(childText)) {
              tagDisplayName = 'Text nodes';
            } else {
              tagDisplayName = 'Whitespace text nodes';
              whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
            }
          } else {
            tagDisplayName = '<' + childTag + '>';
          }
          if (invalidParent) {
            var info = '';
            if (ancestorTag === 'table' && childTag === 'tr') {
              info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
            }
            'production' !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
          } else {
            'production' !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
          }
        }
      };
      validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
      validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current;
        var parentTag = parentInfo && parentInfo.tag;
        return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
      };
    }
    module.exports = validateDOMNesting;
  })($__require('15'));
});
$__System.registerDynamic('87', ['50', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var validateDOMNesting = $__require('50');
    var DOC_NODE_TYPE = 9;
    function ReactDOMContainerInfo(topLevelWrapper, node) {
      var info = {
        _topLevelWrapper: topLevelWrapper,
        _idCounter: 1,
        _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
        _node: node,
        _tag: node ? node.nodeName.toLowerCase() : null,
        _namespaceURI: node ? node.namespaceURI : null
      };
      if ('production' !== 'production') {
        info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
      }
      return info;
    }
    module.exports = ReactDOMContainerInfo;
  })($__require('15'));
});
$__System.registerDynamic('88', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactDOMFeatureFlags = {
    useCreateElement: true,
    useFiber: false
  };

  module.exports = ReactDOMFeatureFlags;
});
$__System.registerDynamic('89', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var MOD = 65521;

  // adler32 is not cryptographically strong, and is only used to sanity check that
  // markup generated on the server matches the markup generated on the client.
  // This implementation (a modified version of the SheetJS version) has been optimized
  // for our use case, at the expense of conforming to the adler32 specification
  // for non-ascii inputs.
  function adler32(data) {
    var a = 1;
    var b = 0;
    var i = 0;
    var l = data.length;
    var m = l & ~0x3;
    while (i < m) {
      var n = Math.min(i + 4096, m);
      for (; i < n; i += 4) {
        b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
      }
      a %= MOD;
      b %= MOD;
    }
    for (; i < l; i++) {
      b += a += data.charCodeAt(i);
    }
    a %= MOD;
    b %= MOD;
    return a | b << 16;
  }

  module.exports = adler32;
});
$__System.registerDynamic('8a', ['89'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var adler32 = $__require('89');
  var TAG_END = /\/?>/;
  var COMMENT_START = /^<\!\-\-/;
  var ReactMarkupChecksum = {
    CHECKSUM_ATTR_NAME: 'data-react-checksum',
    addChecksumToMarkup: function (markup) {
      var checksum = adler32(markup);
      if (COMMENT_START.test(markup)) {
        return markup;
      } else {
        return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
      }
    },
    canReuseMarkup: function (markup, element) {
      var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
      existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
      var markupChecksum = adler32(markup);
      return markupChecksum === existingChecksum;
    }
  };
  module.exports = ReactMarkupChecksum;
});
$__System.registerDynamic('47', ['2e', '40', '44', '29', '10', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var ReactCurrentOwner = $__require('40');
    var ReactInstanceMap = $__require('44');
    var ReactInstrumentation = $__require('29');
    var ReactUpdates = $__require('10');
    var invariant = $__require('30');
    var warning = $__require('24');
    function enqueueUpdate(internalInstance) {
      ReactUpdates.enqueueUpdate(internalInstance);
    }
    function formatUnexpectedArgument(arg) {
      var type = typeof arg;
      if (type !== 'object') {
        return type;
      }
      var displayName = arg.constructor && arg.constructor.name || type;
      var keys = Object.keys(arg);
      if (keys.length > 0 && keys.length < 20) {
        return displayName + ' (keys: ' + keys.join(', ') + ')';
      }
      return displayName;
    }
    function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
      var internalInstance = ReactInstanceMap.get(publicInstance);
      if (!internalInstance) {
        if ('production' !== 'production') {
          var ctor = publicInstance.constructor;
          'production' !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
        }
        return null;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
      }
      return internalInstance;
    }
    var ReactUpdateQueue = {
      isMounted: function (publicInstance) {
        if ('production' !== 'production') {
          var owner = ReactCurrentOwner.current;
          if (owner !== null) {
            'production' !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
            owner._warnedAboutRefsInRender = true;
          }
        }
        var internalInstance = ReactInstanceMap.get(publicInstance);
        if (internalInstance) {
          return !!internalInstance._renderedComponent;
        } else {
          return false;
        }
      },
      enqueueCallback: function (publicInstance, callback, callerName) {
        ReactUpdateQueue.validateCallback(callback, callerName);
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
        if (!internalInstance) {
          return null;
        }
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueCallbackInternal: function (internalInstance, callback) {
        if (internalInstance._pendingCallbacks) {
          internalInstance._pendingCallbacks.push(callback);
        } else {
          internalInstance._pendingCallbacks = [callback];
        }
        enqueueUpdate(internalInstance);
      },
      enqueueForceUpdate: function (publicInstance) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingForceUpdate = true;
        enqueueUpdate(internalInstance);
      },
      enqueueReplaceState: function (publicInstance, completeState, callback) {
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
        if (!internalInstance) {
          return;
        }
        internalInstance._pendingStateQueue = [completeState];
        internalInstance._pendingReplaceState = true;
        if (callback !== undefined && callback !== null) {
          ReactUpdateQueue.validateCallback(callback, 'replaceState');
          if (internalInstance._pendingCallbacks) {
            internalInstance._pendingCallbacks.push(callback);
          } else {
            internalInstance._pendingCallbacks = [callback];
          }
        }
        enqueueUpdate(internalInstance);
      },
      enqueueSetState: function (publicInstance, partialState) {
        if ('production' !== 'production') {
          ReactInstrumentation.debugTool.onSetState();
          'production' !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
        }
        var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
        if (!internalInstance) {
          return;
        }
        var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
        queue.push(partialState);
        enqueueUpdate(internalInstance);
      },
      enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
        internalInstance._pendingElement = nextElement;
        internalInstance._context = nextContext;
        enqueueUpdate(internalInstance);
      },
      validateCallback: function (callback, callerName) {
        !(!callback || typeof callback === 'function') ? 'production' !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
      }
    };
    module.exports = ReactUpdateQueue;
  })($__require('15'));
});
$__System.registerDynamic('65', ['2e', '4', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var PooledClass = $__require('4');
    var invariant = $__require('30');
    var CallbackQueue = function () {
      function CallbackQueue(arg) {
        _classCallCheck(this, CallbackQueue);
        this._callbacks = null;
        this._contexts = null;
        this._arg = arg;
      }
      CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
        this._callbacks = this._callbacks || [];
        this._callbacks.push(callback);
        this._contexts = this._contexts || [];
        this._contexts.push(context);
      };
      CallbackQueue.prototype.notifyAll = function notifyAll() {
        var callbacks = this._callbacks;
        var contexts = this._contexts;
        var arg = this._arg;
        if (callbacks && contexts) {
          !(callbacks.length === contexts.length) ? 'production' !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
          this._callbacks = null;
          this._contexts = null;
          for (var i = 0; i < callbacks.length; i++) {
            callbacks[i].call(contexts[i], arg);
          }
          callbacks.length = 0;
          contexts.length = 0;
        }
      };
      CallbackQueue.prototype.checkpoint = function checkpoint() {
        return this._callbacks ? this._callbacks.length : 0;
      };
      CallbackQueue.prototype.rollback = function rollback(len) {
        if (this._callbacks && this._contexts) {
          this._callbacks.length = len;
          this._contexts.length = len;
        }
      };
      CallbackQueue.prototype.reset = function reset() {
        this._callbacks = null;
        this._contexts = null;
      };
      CallbackQueue.prototype.destructor = function destructor() {
        this.reset();
      };
      return CallbackQueue;
    }();
    module.exports = PooledClass.addPoolingTo(CallbackQueue);
  })($__require('15'));
});
$__System.registerDynamic('4', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    var oneArgumentPooler = function (copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function (a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function (a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function (a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var standardReleaser = function (instance) {
      var Klass = this;
      !(instance instanceof Klass) ? 'production' !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
      instance.destructor();
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function (CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler
    };
    module.exports = PooledClass;
  })($__require('15'));
});
$__System.registerDynamic('8b', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactFeatureFlags = {
    // When true, call console.time() before and .timeEnd() after each top-level
    // render (both initial renders and updates). Useful when looking at prod-mode
    // timeline profiles in Chrome, for example.
    logTopLevelRenders: false
  };

  module.exports = ReactFeatureFlags;
});
$__System.registerDynamic('49', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    var OBSERVED_ERROR = {};
    var TransactionImpl = {
      reinitializeTransaction: function () {
        this.transactionWrappers = this.getTransactionWrappers();
        if (this.wrapperInitData) {
          this.wrapperInitData.length = 0;
        } else {
          this.wrapperInitData = [];
        }
        this._isInTransaction = false;
      },
      _isInTransaction: false,
      getTransactionWrappers: null,
      isInTransaction: function () {
        return !!this._isInTransaction;
      },
      perform: function (method, scope, a, b, c, d, e, f) {
        !!this.isInTransaction() ? 'production' !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
        var errorThrown;
        var ret;
        try {
          this._isInTransaction = true;
          errorThrown = true;
          this.initializeAll(0);
          ret = method.call(scope, a, b, c, d, e, f);
          errorThrown = false;
        } finally {
          try {
            if (errorThrown) {
              try {
                this.closeAll(0);
              } catch (err) {}
            } else {
              this.closeAll(0);
            }
          } finally {
            this._isInTransaction = false;
          }
        }
        return ret;
      },
      initializeAll: function (startIndex) {
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          try {
            this.wrapperInitData[i] = OBSERVED_ERROR;
            this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
          } finally {
            if (this.wrapperInitData[i] === OBSERVED_ERROR) {
              try {
                this.initializeAll(i + 1);
              } catch (err) {}
            }
          }
        }
      },
      closeAll: function (startIndex) {
        !this.isInTransaction() ? 'production' !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
        var transactionWrappers = this.transactionWrappers;
        for (var i = startIndex; i < transactionWrappers.length; i++) {
          var wrapper = transactionWrappers[i];
          var initData = this.wrapperInitData[i];
          var errorThrown;
          try {
            errorThrown = true;
            if (initData !== OBSERVED_ERROR && wrapper.close) {
              wrapper.close.call(this, initData);
            }
            errorThrown = false;
          } finally {
            if (errorThrown) {
              try {
                this.closeAll(i + 1);
              } catch (e) {}
            }
          }
        }
        this.wrapperInitData.length = 0;
      }
    };
    module.exports = TransactionImpl;
  })($__require('15'));
});
$__System.registerDynamic('10', ['2e', '6', '65', '4', '8b', '38', '49', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e'),
        _assign = $__require('6');
    var CallbackQueue = $__require('65');
    var PooledClass = $__require('4');
    var ReactFeatureFlags = $__require('8b');
    var ReactReconciler = $__require('38');
    var Transaction = $__require('49');
    var invariant = $__require('30');
    var dirtyComponents = [];
    var updateBatchNumber = 0;
    var asapCallbackQueue = CallbackQueue.getPooled();
    var asapEnqueued = false;
    var batchingStrategy = null;
    function ensureInjected() {
      !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
    }
    var NESTED_UPDATES = {
      initialize: function () {
        this.dirtyComponentsLength = dirtyComponents.length;
      },
      close: function () {
        if (this.dirtyComponentsLength !== dirtyComponents.length) {
          dirtyComponents.splice(0, this.dirtyComponentsLength);
          flushBatchedUpdates();
        } else {
          dirtyComponents.length = 0;
        }
      }
    };
    var UPDATE_QUEUEING = {
      initialize: function () {
        this.callbackQueue.reset();
      },
      close: function () {
        this.callbackQueue.notifyAll();
      }
    };
    var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
    function ReactUpdatesFlushTransaction() {
      this.reinitializeTransaction();
      this.dirtyComponentsLength = null;
      this.callbackQueue = CallbackQueue.getPooled();
      this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
    }
    _assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
      getTransactionWrappers: function () {
        return TRANSACTION_WRAPPERS;
      },
      destructor: function () {
        this.dirtyComponentsLength = null;
        CallbackQueue.release(this.callbackQueue);
        this.callbackQueue = null;
        ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
        this.reconcileTransaction = null;
      },
      perform: function (method, scope, a) {
        return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
      }
    });
    PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
    function batchedUpdates(callback, a, b, c, d, e) {
      ensureInjected();
      return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
    }
    function mountOrderComparator(c1, c2) {
      return c1._mountOrder - c2._mountOrder;
    }
    function runBatchedUpdates(transaction) {
      var len = transaction.dirtyComponentsLength;
      !(len === dirtyComponents.length) ? 'production' !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
      dirtyComponents.sort(mountOrderComparator);
      updateBatchNumber++;
      for (var i = 0; i < len; i++) {
        var component = dirtyComponents[i];
        var callbacks = component._pendingCallbacks;
        component._pendingCallbacks = null;
        var markerName;
        if (ReactFeatureFlags.logTopLevelRenders) {
          var namedComponent = component;
          if (component._currentElement.type.isReactTopLevelWrapper) {
            namedComponent = component._renderedComponent;
          }
          markerName = 'React update: ' + namedComponent.getName();
          console.time(markerName);
        }
        ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
        if (markerName) {
          console.timeEnd(markerName);
        }
        if (callbacks) {
          for (var j = 0; j < callbacks.length; j++) {
            transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
          }
        }
      }
    }
    var flushBatchedUpdates = function () {
      while (dirtyComponents.length || asapEnqueued) {
        if (dirtyComponents.length) {
          var transaction = ReactUpdatesFlushTransaction.getPooled();
          transaction.perform(runBatchedUpdates, null, transaction);
          ReactUpdatesFlushTransaction.release(transaction);
        }
        if (asapEnqueued) {
          asapEnqueued = false;
          var queue = asapCallbackQueue;
          asapCallbackQueue = CallbackQueue.getPooled();
          queue.notifyAll();
          CallbackQueue.release(queue);
        }
      }
    };
    function enqueueUpdate(component) {
      ensureInjected();
      if (!batchingStrategy.isBatchingUpdates) {
        batchingStrategy.batchedUpdates(enqueueUpdate, component);
        return;
      }
      dirtyComponents.push(component);
      if (component._updateBatchNumber == null) {
        component._updateBatchNumber = updateBatchNumber + 1;
      }
    }
    function asap(callback, context) {
      !batchingStrategy.isBatchingUpdates ? 'production' !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
      asapCallbackQueue.enqueue(callback, context);
      asapEnqueued = true;
    }
    var ReactUpdatesInjection = {
      injectReconcileTransaction: function (ReconcileTransaction) {
        !ReconcileTransaction ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
        ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
      },
      injectBatchingStrategy: function (_batchingStrategy) {
        !_batchingStrategy ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
        !(typeof _batchingStrategy.batchedUpdates === 'function') ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
        !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? 'production' !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
        batchingStrategy = _batchingStrategy;
      }
    };
    var ReactUpdates = {
      ReactReconcileTransaction: null,
      batchedUpdates: batchedUpdates,
      enqueueUpdate: enqueueUpdate,
      flushBatchedUpdates: flushBatchedUpdates,
      injection: ReactUpdatesInjection,
      asap: asap
    };
    module.exports = ReactUpdates;
  })($__require('15'));
});
$__System.registerDynamic('43', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    var injected = false;
    var ReactComponentEnvironment = {
      replaceNodeWithMarkup: null,
      processChildrenUpdates: null,
      injection: { injectEnvironment: function (environment) {
          !!injected ? 'production' !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
          ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
          ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
          injected = true;
        } }
    };
    module.exports = ReactComponentEnvironment;
  })($__require('15'));
});
$__System.registerDynamic('84', ['15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var caughtError = null;
    function invokeGuardedCallback(name, func, a) {
      try {
        func(a);
      } catch (x) {
        if (caughtError === null) {
          caughtError = x;
        }
      }
    }
    var ReactErrorUtils = {
      invokeGuardedCallback: invokeGuardedCallback,
      invokeGuardedCallbackWithCatch: invokeGuardedCallback,
      rethrowCaughtError: function () {
        if (caughtError) {
          var error = caughtError;
          caughtError = null;
          throw error;
        }
      }
    };
    if ('production' !== 'production') {
      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
        var fakeNode = document.createElement('react');
        ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
          var boundFunc = func.bind(null, a);
          var evtType = 'react-' + name;
          fakeNode.addEventListener(evtType, boundFunc, false);
          var evt = document.createEvent('Event');
          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);
          fakeNode.removeEventListener(evtType, boundFunc, false);
        };
      }
    }
    module.exports = ReactErrorUtils;
  })($__require('15'));
});
$__System.registerDynamic('44', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * `ReactInstanceMap` maintains a mapping from a public facing stateful
   * instance (key) and the internal representation (value). This allows public
   * methods to accept the user facing instance as an argument and map them back
   * to internal methods.
   */

  // TODO: Replace this with ES6: var ReactInstanceMap = new Map();

  var global = this || self,
      GLOBAL = global;
  var ReactInstanceMap = {
    /**
     * This API should be called `delete` but we'd have to make sure to always
     * transform these to strings for IE support. When this transform is fully
     * supported we can rename it.
     */
    remove: function (key) {
      key._reactInternalInstance = undefined;
    },

    get: function (key) {
      return key._reactInternalInstance;
    },

    has: function (key) {
      return key._reactInternalInstance !== undefined;
    },

    set: function (key, value) {
      key._reactInternalInstance = value;
    }
  };

  module.exports = ReactInstanceMap;
});
$__System.registerDynamic('83', ['2e', '33', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var React = $__require('33');
    var invariant = $__require('30');
    var ReactNodeTypes = {
      HOST: 0,
      COMPOSITE: 1,
      EMPTY: 2,
      getType: function (node) {
        if (node === null || node === false) {
          return ReactNodeTypes.EMPTY;
        } else if (React.isValidElement(node)) {
          if (typeof node.type === 'function') {
            return ReactNodeTypes.COMPOSITE;
          } else {
            return ReactNodeTypes.HOST;
          }
        }
        !false ? 'production' !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
      }
    };
    module.exports = ReactNodeTypes;
  })($__require('15'));
});
$__System.registerDynamic('8c', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    function isValidOwner(object) {
      return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
    }
    var ReactOwner = {
      addComponentAsRefTo: function (component, ref, owner) {
        !isValidOwner(owner) ? 'production' !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
        owner.attachRef(ref, component);
      },
      removeComponentAsRefFrom: function (component, ref, owner) {
        !isValidOwner(owner) ? 'production' !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
        var ownerPublicInstance = owner.getPublicInstance();
        if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
          owner.detachRef(ref);
        }
      }
    };
    module.exports = ReactOwner;
  })($__require('15'));
});
$__System.registerDynamic('8d', ['8c', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactOwner = $__require('8c');
    var ReactRef = {};
    function attachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(component.getPublicInstance());
      } else {
        ReactOwner.addComponentAsRefTo(component, ref, owner);
      }
    }
    function detachRef(ref, component, owner) {
      if (typeof ref === 'function') {
        ref(null);
      } else {
        ReactOwner.removeComponentAsRefFrom(component, ref, owner);
      }
    }
    ReactRef.attachRefs = function (instance, element) {
      if (element === null || typeof element !== 'object') {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        attachRef(ref, instance, element._owner);
      }
    };
    ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
      var prevRef = null;
      var prevOwner = null;
      if (prevElement !== null && typeof prevElement === 'object') {
        prevRef = prevElement.ref;
        prevOwner = prevElement._owner;
      }
      var nextRef = null;
      var nextOwner = null;
      if (nextElement !== null && typeof nextElement === 'object') {
        nextRef = nextElement.ref;
        nextOwner = nextElement._owner;
      }
      return prevRef !== nextRef || typeof nextRef === 'string' && nextOwner !== prevOwner;
    };
    ReactRef.detachRefs = function (instance, element) {
      if (element === null || typeof element !== 'object') {
        return;
      }
      var ref = element.ref;
      if (ref != null) {
        detachRef(ref, instance, element._owner);
      }
    };
    module.exports = ReactRef;
  })($__require('15'));
});
$__System.registerDynamic('38', ['8d', '29', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactRef = $__require('8d');
    var ReactInstrumentation = $__require('29');
    var warning = $__require('24');
    function attachRefs() {
      ReactRef.attachRefs(this, this._currentElement);
    }
    var ReactReconciler = {
      mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) {
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
          }
        }
        var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
        if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
          transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
          }
        }
        return markup;
      },
      getHostNode: function (internalInstance) {
        return internalInstance.getHostNode();
      },
      unmountComponent: function (internalInstance, safely) {
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
          }
        }
        ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
        internalInstance.unmountComponent(safely);
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
          }
        }
      },
      receiveComponent: function (internalInstance, nextElement, transaction, context) {
        var prevElement = internalInstance._currentElement;
        if (nextElement === prevElement && context === internalInstance._context) {
          return;
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
          }
        }
        var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
        if (refsChanged) {
          ReactRef.detachRefs(internalInstance, prevElement);
        }
        internalInstance.receiveComponent(nextElement, transaction, context);
        if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
          transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
          }
        }
      },
      performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
        if (internalInstance._updateBatchNumber !== updateBatchNumber) {
          'production' !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
          return;
        }
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
          }
        }
        internalInstance.performUpdateIfNecessary(transaction);
        if ('production' !== 'production') {
          if (internalInstance._debugID !== 0) {
            ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
          }
        }
      }
    };
    module.exports = ReactReconciler;
  })($__require('15'));
});
$__System.registerDynamic('8e', ['15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactPropTypeLocationNames = {};
    if ('production' !== 'production') {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })($__require('15'));
});
$__System.registerDynamic('34', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;
});
$__System.registerDynamic('8f', ['2e', '8e', '34', '30', '24', '3d', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var ReactPropTypeLocationNames = $__require('8e');
    var ReactPropTypesSecret = $__require('34');
    var invariant = $__require('30');
    var warning = $__require('24');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('3d');
    }
    var loggedTypeFailures = {};
    function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;
          try {
            !(typeof typeSpecs[typeSpecName] === 'function') ? 'production' !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          'production' !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var componentStackInfo = '';
            if ('production' !== 'production') {
              if (!ReactComponentTreeHook) {
                ReactComponentTreeHook = $__require('3d');
              }
              if (debugID !== null) {
                componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
              } else if (element !== null) {
                componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
              }
            }
            'production' !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
          }
        }
      }
    }
    module.exports = checkReactTypeSpec;
  })($__require('15'));
});
$__System.registerDynamic('51', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @typechecks
   * 
   */

  /*eslint-disable no-self-compare */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      // Added the nonzero y check to make Flow happy, but it is redundant
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }

  /**
   * Performs equality by iterating through keys on an object and returning false
   * when any key has values which are not strictly equal between the arguments.
   * Returns true when the values of all keys are strictly equal.
   */
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    // Test for A's keys different from B.
    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }

  module.exports = shallowEqual;
});
$__System.registerDynamic('90', ['2e', '6', '33', '43', '40', '84', '44', '29', '83', '38', '8f', '91', '30', '51', '3b', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e'),
        _assign = $__require('6');
    var React = $__require('33');
    var ReactComponentEnvironment = $__require('43');
    var ReactCurrentOwner = $__require('40');
    var ReactErrorUtils = $__require('84');
    var ReactInstanceMap = $__require('44');
    var ReactInstrumentation = $__require('29');
    var ReactNodeTypes = $__require('83');
    var ReactReconciler = $__require('38');
    if ('production' !== 'production') {
      var checkReactTypeSpec = $__require('8f');
    }
    var emptyObject = $__require('91');
    var invariant = $__require('30');
    var shallowEqual = $__require('51');
    var shouldUpdateReactComponent = $__require('3b');
    var warning = $__require('24');
    var CompositeTypes = {
      ImpureClass: 0,
      PureClass: 1,
      StatelessFunctional: 2
    };
    function StatelessComponent(Component) {}
    StatelessComponent.prototype.render = function () {
      var Component = ReactInstanceMap.get(this)._currentElement.type;
      var element = Component(this.props, this.context, this.updater);
      warnIfInvalidElement(Component, element);
      return element;
    };
    function warnIfInvalidElement(Component, element) {
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
        'production' !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
      }
    }
    function shouldConstruct(Component) {
      return !!(Component.prototype && Component.prototype.isReactComponent);
    }
    function isPureComponent(Component) {
      return !!(Component.prototype && Component.prototype.isPureReactComponent);
    }
    function measureLifeCyclePerf(fn, debugID, timerType) {
      if (debugID === 0) {
        return fn();
      }
      ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
      try {
        return fn();
      } finally {
        ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
      }
    }
    var nextMountID = 1;
    var ReactCompositeComponent = {
      construct: function (element) {
        this._currentElement = element;
        this._rootNodeID = 0;
        this._compositeType = null;
        this._instance = null;
        this._hostParent = null;
        this._hostContainerInfo = null;
        this._updateBatchNumber = null;
        this._pendingElement = null;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._renderedNodeType = null;
        this._renderedComponent = null;
        this._context = null;
        this._mountOrder = 0;
        this._topLevelWrapper = null;
        this._pendingCallbacks = null;
        this._calledComponentWillUnmount = false;
        if ('production' !== 'production') {
          this._warnedAboutRefsInRender = false;
        }
      },
      mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
        var _this = this;
        this._context = context;
        this._mountOrder = nextMountID++;
        this._hostParent = hostParent;
        this._hostContainerInfo = hostContainerInfo;
        var publicProps = this._currentElement.props;
        var publicContext = this._processContext(context);
        var Component = this._currentElement.type;
        var updateQueue = transaction.getUpdateQueue();
        var doConstruct = shouldConstruct(Component);
        var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
        var renderedElement;
        if (!doConstruct && (inst == null || inst.render == null)) {
          renderedElement = inst;
          warnIfInvalidElement(Component, renderedElement);
          !(inst === null || inst === false || React.isValidElement(inst)) ? 'production' !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
          inst = new StatelessComponent(Component);
          this._compositeType = CompositeTypes.StatelessFunctional;
        } else {
          if (isPureComponent(Component)) {
            this._compositeType = CompositeTypes.PureClass;
          } else {
            this._compositeType = CompositeTypes.ImpureClass;
          }
        }
        if ('production' !== 'production') {
          if (inst.render == null) {
            'production' !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
          }
          var propsMutated = inst.props !== publicProps;
          var componentName = Component.displayName || Component.name || 'Component';
          'production' !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
        }
        inst.props = publicProps;
        inst.context = publicContext;
        inst.refs = emptyObject;
        inst.updater = updateQueue;
        this._instance = inst;
        ReactInstanceMap.set(inst, this);
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
          'production' !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
          'production' !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
          'production' !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
        }
        var initialState = inst.state;
        if (initialState === undefined) {
          inst.state = initialState = null;
        }
        !(typeof initialState === 'object' && !Array.isArray(initialState)) ? 'production' !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        var markup;
        if (inst.unstable_handleError) {
          markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
        } else {
          markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
        }
        if (inst.componentDidMount) {
          if ('production' !== 'production') {
            transaction.getReactMountReady().enqueue(function () {
              measureLifeCyclePerf(function () {
                return inst.componentDidMount();
              }, _this._debugID, 'componentDidMount');
            });
          } else {
            transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
          }
        }
        return markup;
      },
      _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
        if ('production' !== 'production') {
          ReactCurrentOwner.current = this;
          try {
            return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
          } finally {
            ReactCurrentOwner.current = null;
          }
        } else {
          return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
        }
      },
      _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
        var Component = this._currentElement.type;
        if (doConstruct) {
          if ('production' !== 'production') {
            return measureLifeCyclePerf(function () {
              return new Component(publicProps, publicContext, updateQueue);
            }, this._debugID, 'ctor');
          } else {
            return new Component(publicProps, publicContext, updateQueue);
          }
        }
        if ('production' !== 'production') {
          return measureLifeCyclePerf(function () {
            return Component(publicProps, publicContext, updateQueue);
          }, this._debugID, 'render');
        } else {
          return Component(publicProps, publicContext, updateQueue);
        }
      },
      performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
        var markup;
        var checkpoint = transaction.checkpoint();
        try {
          markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
        } catch (e) {
          transaction.rollback(checkpoint);
          this._instance.unstable_handleError(e);
          if (this._pendingStateQueue) {
            this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
          }
          checkpoint = transaction.checkpoint();
          this._renderedComponent.unmountComponent(true);
          transaction.rollback(checkpoint);
          markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
        }
        return markup;
      },
      performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
        var inst = this._instance;
        var debugID = 0;
        if ('production' !== 'production') {
          debugID = this._debugID;
        }
        if (inst.componentWillMount) {
          if ('production' !== 'production') {
            measureLifeCyclePerf(function () {
              return inst.componentWillMount();
            }, debugID, 'componentWillMount');
          } else {
            inst.componentWillMount();
          }
          if (this._pendingStateQueue) {
            inst.state = this._processPendingState(inst.props, inst.context);
          }
        }
        if (renderedElement === undefined) {
          renderedElement = this._renderValidatedComponent();
        }
        var nodeType = ReactNodeTypes.getType(renderedElement);
        this._renderedNodeType = nodeType;
        var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY);
        this._renderedComponent = child;
        var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
        if ('production' !== 'production') {
          if (debugID !== 0) {
            var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
            ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
          }
        }
        return markup;
      },
      getHostNode: function () {
        return ReactReconciler.getHostNode(this._renderedComponent);
      },
      unmountComponent: function (safely) {
        if (!this._renderedComponent) {
          return;
        }
        var inst = this._instance;
        if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
          inst._calledComponentWillUnmount = true;
          if (safely) {
            var name = this.getName() + '.componentWillUnmount()';
            ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
          } else {
            if ('production' !== 'production') {
              measureLifeCyclePerf(function () {
                return inst.componentWillUnmount();
              }, this._debugID, 'componentWillUnmount');
            } else {
              inst.componentWillUnmount();
            }
          }
        }
        if (this._renderedComponent) {
          ReactReconciler.unmountComponent(this._renderedComponent, safely);
          this._renderedNodeType = null;
          this._renderedComponent = null;
          this._instance = null;
        }
        this._pendingStateQueue = null;
        this._pendingReplaceState = false;
        this._pendingForceUpdate = false;
        this._pendingCallbacks = null;
        this._pendingElement = null;
        this._context = null;
        this._rootNodeID = 0;
        this._topLevelWrapper = null;
        ReactInstanceMap.remove(inst);
      },
      _maskContext: function (context) {
        var Component = this._currentElement.type;
        var contextTypes = Component.contextTypes;
        if (!contextTypes) {
          return emptyObject;
        }
        var maskedContext = {};
        for (var contextName in contextTypes) {
          maskedContext[contextName] = context[contextName];
        }
        return maskedContext;
      },
      _processContext: function (context) {
        var maskedContext = this._maskContext(context);
        if ('production' !== 'production') {
          var Component = this._currentElement.type;
          if (Component.contextTypes) {
            this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
          }
        }
        return maskedContext;
      },
      _processChildContext: function (currentContext) {
        var Component = this._currentElement.type;
        var inst = this._instance;
        var childContext;
        if (inst.getChildContext) {
          if ('production' !== 'production') {
            ReactInstrumentation.debugTool.onBeginProcessingChildContext();
            try {
              childContext = inst.getChildContext();
            } finally {
              ReactInstrumentation.debugTool.onEndProcessingChildContext();
            }
          } else {
            childContext = inst.getChildContext();
          }
        }
        if (childContext) {
          !(typeof Component.childContextTypes === 'object') ? 'production' !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
          if ('production' !== 'production') {
            this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
          }
          for (var name in childContext) {
            !(name in Component.childContextTypes) ? 'production' !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
          }
          return _assign({}, currentContext, childContext);
        }
        return currentContext;
      },
      _checkContextTypes: function (typeSpecs, values, location) {
        if ('production' !== 'production') {
          checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
        }
      },
      receiveComponent: function (nextElement, transaction, nextContext) {
        var prevElement = this._currentElement;
        var prevContext = this._context;
        this._pendingElement = null;
        this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
      },
      performUpdateIfNecessary: function (transaction) {
        if (this._pendingElement != null) {
          ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
        } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
          this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
        } else {
          this._updateBatchNumber = null;
        }
      },
      updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
        var inst = this._instance;
        !(inst != null) ? 'production' !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
        var willReceive = false;
        var nextContext;
        if (this._context === nextUnmaskedContext) {
          nextContext = inst.context;
        } else {
          nextContext = this._processContext(nextUnmaskedContext);
          willReceive = true;
        }
        var prevProps = prevParentElement.props;
        var nextProps = nextParentElement.props;
        if (prevParentElement !== nextParentElement) {
          willReceive = true;
        }
        if (willReceive && inst.componentWillReceiveProps) {
          if ('production' !== 'production') {
            measureLifeCyclePerf(function () {
              return inst.componentWillReceiveProps(nextProps, nextContext);
            }, this._debugID, 'componentWillReceiveProps');
          } else {
            inst.componentWillReceiveProps(nextProps, nextContext);
          }
        }
        var nextState = this._processPendingState(nextProps, nextContext);
        var shouldUpdate = true;
        if (!this._pendingForceUpdate) {
          if (inst.shouldComponentUpdate) {
            if ('production' !== 'production') {
              shouldUpdate = measureLifeCyclePerf(function () {
                return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
              }, this._debugID, 'shouldComponentUpdate');
            } else {
              shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
            }
          } else {
            if (this._compositeType === CompositeTypes.PureClass) {
              shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
            }
          }
        }
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
        }
        this._updateBatchNumber = null;
        if (shouldUpdate) {
          this._pendingForceUpdate = false;
          this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
        } else {
          this._currentElement = nextParentElement;
          this._context = nextUnmaskedContext;
          inst.props = nextProps;
          inst.state = nextState;
          inst.context = nextContext;
        }
      },
      _processPendingState: function (props, context) {
        var inst = this._instance;
        var queue = this._pendingStateQueue;
        var replace = this._pendingReplaceState;
        this._pendingReplaceState = false;
        this._pendingStateQueue = null;
        if (!queue) {
          return inst.state;
        }
        if (replace && queue.length === 1) {
          return queue[0];
        }
        var nextState = _assign({}, replace ? queue[0] : inst.state);
        for (var i = replace ? 1 : 0; i < queue.length; i++) {
          var partial = queue[i];
          _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
        }
        return nextState;
      },
      _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
        var _this2 = this;
        var inst = this._instance;
        var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
        var prevProps;
        var prevState;
        var prevContext;
        if (hasComponentDidUpdate) {
          prevProps = inst.props;
          prevState = inst.state;
          prevContext = inst.context;
        }
        if (inst.componentWillUpdate) {
          if ('production' !== 'production') {
            measureLifeCyclePerf(function () {
              return inst.componentWillUpdate(nextProps, nextState, nextContext);
            }, this._debugID, 'componentWillUpdate');
          } else {
            inst.componentWillUpdate(nextProps, nextState, nextContext);
          }
        }
        this._currentElement = nextElement;
        this._context = unmaskedContext;
        inst.props = nextProps;
        inst.state = nextState;
        inst.context = nextContext;
        this._updateRenderedComponent(transaction, unmaskedContext);
        if (hasComponentDidUpdate) {
          if ('production' !== 'production') {
            transaction.getReactMountReady().enqueue(function () {
              measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
            });
          } else {
            transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
          }
        }
      },
      _updateRenderedComponent: function (transaction, context) {
        var prevComponentInstance = this._renderedComponent;
        var prevRenderedElement = prevComponentInstance._currentElement;
        var nextRenderedElement = this._renderValidatedComponent();
        var debugID = 0;
        if ('production' !== 'production') {
          debugID = this._debugID;
        }
        if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
          ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
        } else {
          var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
          ReactReconciler.unmountComponent(prevComponentInstance, false);
          var nodeType = ReactNodeTypes.getType(nextRenderedElement);
          this._renderedNodeType = nodeType;
          var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY);
          this._renderedComponent = child;
          var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
          if ('production' !== 'production') {
            if (debugID !== 0) {
              var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
              ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
            }
          }
          this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
        }
      },
      _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
        ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
      },
      _renderValidatedComponentWithoutOwnerOrContext: function () {
        var inst = this._instance;
        var renderedElement;
        if ('production' !== 'production') {
          renderedElement = measureLifeCyclePerf(function () {
            return inst.render();
          }, this._debugID, 'render');
        } else {
          renderedElement = inst.render();
        }
        if ('production' !== 'production') {
          if (renderedElement === undefined && inst.render._isMockFunction) {
            renderedElement = null;
          }
        }
        return renderedElement;
      },
      _renderValidatedComponent: function () {
        var renderedElement;
        if ('production' !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
          ReactCurrentOwner.current = this;
          try {
            renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
          } finally {
            ReactCurrentOwner.current = null;
          }
        } else {
          renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
        }
        !(renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? 'production' !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
        return renderedElement;
      },
      attachRef: function (ref, component) {
        var inst = this.getPublicInstance();
        !(inst != null) ? 'production' !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
        var publicComponentInstance = component.getPublicInstance();
        if ('production' !== 'production') {
          var componentName = component && component.getName ? component.getName() : 'a component';
          'production' !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
        }
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        refs[ref] = publicComponentInstance;
      },
      detachRef: function (ref) {
        var refs = this.getPublicInstance().refs;
        delete refs[ref];
      },
      getName: function () {
        var type = this._currentElement.type;
        var constructor = this._instance && this._instance.constructor;
        return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
      },
      getPublicInstance: function () {
        var inst = this._instance;
        if (this._compositeType === CompositeTypes.StatelessFunctional) {
          return null;
        }
        return inst;
      },
      _instantiateReactComponent: null
    };
    module.exports = ReactCompositeComponent;
  })($__require('15'));
});
$__System.registerDynamic('62', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var emptyComponentFactory;

  var ReactEmptyComponentInjection = {
    injectEmptyComponentFactory: function (factory) {
      emptyComponentFactory = factory;
    }
  };

  var ReactEmptyComponent = {
    create: function (instantiate) {
      return emptyComponentFactory(instantiate);
    }
  };

  ReactEmptyComponent.injection = ReactEmptyComponentInjection;

  module.exports = ReactEmptyComponent;
});
$__System.registerDynamic('63', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    var genericComponentClass = null;
    var textComponentClass = null;
    var ReactHostComponentInjection = {
      injectGenericComponentClass: function (componentClass) {
        genericComponentClass = componentClass;
      },
      injectTextComponentClass: function (componentClass) {
        textComponentClass = componentClass;
      }
    };
    function createInternalComponent(element) {
      !genericComponentClass ? 'production' !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
      return new genericComponentClass(element);
    }
    function createInstanceForText(text) {
      return new textComponentClass(text);
    }
    function isTextComponent(component) {
      return component instanceof textComponentClass;
    }
    var ReactHostComponent = {
      createInternalComponent: createInternalComponent,
      createInstanceForText: createInstanceForText,
      isTextComponent: isTextComponent,
      injection: ReactHostComponentInjection
    };
    module.exports = ReactHostComponent;
  })($__require('15'));
});
$__System.registerDynamic('92', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var nextDebugID = 1;

  function getNextDebugID() {
    return nextDebugID++;
  }

  module.exports = getNextDebugID;
});
$__System.registerDynamic('39', ['2e', '6', '90', '62', '63', '92', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e'),
        _assign = $__require('6');
    var ReactCompositeComponent = $__require('90');
    var ReactEmptyComponent = $__require('62');
    var ReactHostComponent = $__require('63');
    var getNextDebugID = $__require('92');
    var invariant = $__require('30');
    var warning = $__require('24');
    var ReactCompositeComponentWrapper = function (element) {
      this.construct(element);
    };
    function getDeclarationErrorAddendum(owner) {
      if (owner) {
        var name = owner.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    function isInternalComponentType(type) {
      return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
    }
    function instantiateReactComponent(node, shouldHaveDebugID) {
      var instance;
      if (node === null || node === false) {
        instance = ReactEmptyComponent.create(instantiateReactComponent);
      } else if (typeof node === 'object') {
        var element = node;
        var type = element.type;
        if (typeof type !== 'function' && typeof type !== 'string') {
          var info = '';
          if ('production' !== 'production') {
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in.";
            }
          }
          info += getDeclarationErrorAddendum(element._owner);
          !false ? 'production' !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
        }
        if (typeof element.type === 'string') {
          instance = ReactHostComponent.createInternalComponent(element);
        } else if (isInternalComponentType(element.type)) {
          instance = new element.type(element);
          if (!instance.getHostNode) {
            instance.getHostNode = instance.getNativeNode;
          }
        } else {
          instance = new ReactCompositeComponentWrapper(element);
        }
      } else if (typeof node === 'string' || typeof node === 'number') {
        instance = ReactHostComponent.createInstanceForText(node);
      } else {
        !false ? 'production' !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
      }
      if ('production' !== 'production') {
        'production' !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
      }
      instance._mountIndex = 0;
      instance._mountImage = null;
      if ('production' !== 'production') {
        instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
      }
      if ('production' !== 'production') {
        if (Object.preventExtensions) {
          Object.preventExtensions(instance);
        }
      }
      return instance;
    }
    _assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, { _instantiateReactComponent: instantiateReactComponent });
    module.exports = instantiateReactComponent;
  })($__require('15'));
});
$__System.registerDynamic('4c', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var DOMNamespaces = {
    html: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg'
  };

  module.exports = DOMNamespaces;
});
$__System.registerDynamic('58', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  /* globals MSApp */

  'use strict';

  /**
   * Create a function which has 'unsafe' privileges (required by windows8 apps)
   */

  var global = this || self,
      GLOBAL = global;
  var createMicrosoftUnsafeLocalFunction = function (func) {
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      return function (arg0, arg1, arg2, arg3) {
        MSApp.execUnsafeLocalFunction(function () {
          return func(arg0, arg1, arg2, arg3);
        });
      };
    } else {
      return func;
    }
  };

  module.exports = createMicrosoftUnsafeLocalFunction;
});
$__System.registerDynamic('59', ['c', '4c', '58', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ExecutionEnvironment = $__require('c');
    var DOMNamespaces = $__require('4c');
    var WHITESPACE_TEST = /^[ \r\n\t\f]/;
    var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
    var createMicrosoftUnsafeLocalFunction = $__require('58');
    var reusableSVGContainer;
    var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
      if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
        reusableSVGContainer = reusableSVGContainer || document.createElement('div');
        reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
        var svgNode = reusableSVGContainer.firstChild;
        while (svgNode.firstChild) {
          node.appendChild(svgNode.firstChild);
        }
      } else {
        node.innerHTML = html;
      }
    });
    if (ExecutionEnvironment.canUseDOM) {
      var testElement = document.createElement('div');
      testElement.innerHTML = ' ';
      if (testElement.innerHTML === '') {
        setInnerHTML = function (node, html) {
          if (node.parentNode) {
            node.parentNode.replaceChild(node, node);
          }
          if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
            node.innerHTML = String.fromCharCode(0xfeff) + html;
            var textNode = node.firstChild;
            if (textNode.data.length === 1) {
              node.removeChild(textNode);
            } else {
              textNode.deleteData(0, 1);
            }
          } else {
            node.innerHTML = html;
          }
        };
      }
      testElement = null;
    }
    module.exports = setInnerHTML;
  })($__require('15'));
});
$__System.registerDynamic('3b', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  /**
   * Given a `prevElement` and `nextElement`, determines if the existing
   * instance should be updated as opposed to being destroyed or replaced by a new
   * instance. Both arguments are elements. This ensures that this logic can
   * operate on stateless trees without any backing instance.
   *
   * @param {?object} prevElement
   * @param {?object} nextElement
   * @return {boolean} True if the existing instance should be updated.
   * @protected
   */

  var global = this || self,
      GLOBAL = global;
  function shouldUpdateReactComponent(prevElement, nextElement) {
    var prevEmpty = prevElement === null || prevElement === false;
    var nextEmpty = nextElement === null || nextElement === false;
    if (prevEmpty || nextEmpty) {
      return prevEmpty === nextEmpty;
    }

    var prevType = typeof prevElement;
    var nextType = typeof nextElement;
    if (prevType === 'string' || prevType === 'number') {
      return nextType === 'string' || nextType === 'number';
    } else {
      return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }

  module.exports = shouldUpdateReactComponent;
});
$__System.registerDynamic('93', ['2e', '4b', '1a', '33', '4e', '40', 'f', '87', '88', '8b', '44', '29', '8a', '38', '47', '10', '91', '39', '30', '59', '3b', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var DOMLazyTree = $__require('4b');
    var DOMProperty = $__require('1a');
    var React = $__require('33');
    var ReactBrowserEventEmitter = $__require('4e');
    var ReactCurrentOwner = $__require('40');
    var ReactDOMComponentTree = $__require('f');
    var ReactDOMContainerInfo = $__require('87');
    var ReactDOMFeatureFlags = $__require('88');
    var ReactFeatureFlags = $__require('8b');
    var ReactInstanceMap = $__require('44');
    var ReactInstrumentation = $__require('29');
    var ReactMarkupChecksum = $__require('8a');
    var ReactReconciler = $__require('38');
    var ReactUpdateQueue = $__require('47');
    var ReactUpdates = $__require('10');
    var emptyObject = $__require('91');
    var instantiateReactComponent = $__require('39');
    var invariant = $__require('30');
    var setInnerHTML = $__require('59');
    var shouldUpdateReactComponent = $__require('3b');
    var warning = $__require('24');
    var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
    var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
    var ELEMENT_NODE_TYPE = 1;
    var DOC_NODE_TYPE = 9;
    var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
    var instancesByReactRootID = {};
    function firstDifferenceIndex(string1, string2) {
      var minLen = Math.min(string1.length, string2.length);
      for (var i = 0; i < minLen; i++) {
        if (string1.charAt(i) !== string2.charAt(i)) {
          return i;
        }
      }
      return string1.length === string2.length ? -1 : minLen;
    }
    function getReactRootElementInContainer(container) {
      if (!container) {
        return null;
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        return container.documentElement;
      } else {
        return container.firstChild;
      }
    }
    function internalGetID(node) {
      return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
    }
    function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
      var markerName;
      if (ReactFeatureFlags.logTopLevelRenders) {
        var wrappedElement = wrapperInstance._currentElement.props.child;
        var type = wrappedElement.type;
        markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
        console.time(markerName);
      }
      var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0);
      if (markerName) {
        console.timeEnd(markerName);
      }
      wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
      ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
    }
    function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(!shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
      transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    }
    function unmountComponentFromNode(instance, container, safely) {
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onBeginFlush();
      }
      ReactReconciler.unmountComponent(instance, safely);
      if ('production' !== 'production') {
        ReactInstrumentation.debugTool.onEndFlush();
      }
      if (container.nodeType === DOC_NODE_TYPE) {
        container = container.documentElement;
      }
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
    }
    function hasNonRootReactChild(container) {
      var rootEl = getReactRootElementInContainer(container);
      if (rootEl) {
        var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
        return !!(inst && inst._hostParent);
      }
    }
    function nodeIsRenderedByOtherInstance(container) {
      var rootEl = getReactRootElementInContainer(container);
      return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
    }
    function isValidContainer(node) {
      return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
    }
    function isReactNode(node) {
      return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
    }
    function getHostRootInstanceInContainer(container) {
      var rootEl = getReactRootElementInContainer(container);
      var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
      return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
    }
    function getTopLevelWrapperInContainer(container) {
      var root = getHostRootInstanceInContainer(container);
      return root ? root._hostContainerInfo._topLevelWrapper : null;
    }
    var topLevelRootCounter = 1;
    var TopLevelWrapper = function () {
      this.rootID = topLevelRootCounter++;
    };
    TopLevelWrapper.prototype.isReactComponent = {};
    if ('production' !== 'production') {
      TopLevelWrapper.displayName = 'TopLevelWrapper';
    }
    TopLevelWrapper.prototype.render = function () {
      return this.props.child;
    };
    TopLevelWrapper.isReactTopLevelWrapper = true;
    var ReactMount = {
      TopLevelWrapper: TopLevelWrapper,
      _instancesByReactRootID: instancesByReactRootID,
      scrollMonitor: function (container, renderCallback) {
        renderCallback();
      },
      _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
        ReactMount.scrollMonitor(container, function () {
          ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
          if (callback) {
            ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
          }
        });
        return prevComponent;
      },
      _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
        'production' !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
        !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
        ReactBrowserEventEmitter.ensureScrollValueMonitoring();
        var componentInstance = instantiateReactComponent(nextElement, false);
        ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
        var wrapperID = componentInstance._instance.rootID;
        instancesByReactRootID[wrapperID] = componentInstance;
        return componentInstance;
      },
      renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
        !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? 'production' !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
        return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
      },
      _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
        ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
        !React.isValidElement(nextElement) ? 'production' !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
        'production' !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
        var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
        var nextContext;
        if (parentComponent) {
          var parentInst = ReactInstanceMap.get(parentComponent);
          nextContext = parentInst._processChildContext(parentInst._context);
        } else {
          nextContext = emptyObject;
        }
        var prevComponent = getTopLevelWrapperInContainer(container);
        if (prevComponent) {
          var prevWrappedElement = prevComponent._currentElement;
          var prevElement = prevWrappedElement.props.child;
          if (shouldUpdateReactComponent(prevElement, nextElement)) {
            var publicInst = prevComponent._renderedComponent.getPublicInstance();
            var updatedCallback = callback && function () {
              callback.call(publicInst);
            };
            ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
            return publicInst;
          } else {
            ReactMount.unmountComponentAtNode(container);
          }
        }
        var reactRootElement = getReactRootElementInContainer(container);
        var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
        var containerHasNonRootReactChild = hasNonRootReactChild(container);
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
          if (!containerHasReactMarkup || reactRootElement.nextSibling) {
            var rootElementSibling = reactRootElement;
            while (rootElementSibling) {
              if (internalGetID(rootElementSibling)) {
                'production' !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
                break;
              }
              rootElementSibling = rootElementSibling.nextSibling;
            }
          }
        }
        var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
        var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
        if (callback) {
          callback.call(component);
        }
        return component;
      },
      render: function (nextElement, container, callback) {
        return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
      },
      unmountComponentAtNode: function (container) {
        'production' !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
        !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
        if ('production' !== 'production') {
          'production' !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
        }
        var prevComponent = getTopLevelWrapperInContainer(container);
        if (!prevComponent) {
          var containerHasNonRootReactChild = hasNonRootReactChild(container);
          var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
          if ('production' !== 'production') {
            'production' !== 'production' ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
          }
          return false;
        }
        delete instancesByReactRootID[prevComponent._instance.rootID];
        ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
        return true;
      },
      _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
        !isValidContainer(container) ? 'production' !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
        if (shouldReuseMarkup) {
          var rootElement = getReactRootElementInContainer(container);
          if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
            ReactDOMComponentTree.precacheNode(instance, rootElement);
            return;
          } else {
            var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
            var rootMarkup = rootElement.outerHTML;
            rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
            var normalizedMarkup = markup;
            if ('production' !== 'production') {
              var normalizer;
              if (container.nodeType === ELEMENT_NODE_TYPE) {
                normalizer = document.createElement('div');
                normalizer.innerHTML = markup;
                normalizedMarkup = normalizer.innerHTML;
              } else {
                normalizer = document.createElement('iframe');
                document.body.appendChild(normalizer);
                normalizer.contentDocument.write(markup);
                normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
                document.body.removeChild(normalizer);
              }
            }
            var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
            var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
            !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
            if ('production' !== 'production') {
              'production' !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
            }
          }
        }
        !(container.nodeType !== DOC_NODE_TYPE) ? 'production' !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
        if (transaction.useCreateElement) {
          while (container.lastChild) {
            container.removeChild(container.lastChild);
          }
          DOMLazyTree.insertTreeBefore(container, markup, null);
        } else {
          setInnerHTML(container, markup);
          ReactDOMComponentTree.precacheNode(instance, container.firstChild);
        }
        if ('production' !== 'production') {
          var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
          if (hostNode._debugID !== 0) {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: hostNode._debugID,
              type: 'mount',
              payload: markup.toString()
            });
          }
        }
      }
    };
    module.exports = ReactMount;
  })($__require('15'));
});
$__System.registerDynamic('94', ['93'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactMount = $__require('93');
  module.exports = ReactMount.renderSubtreeIntoContainer;
});
$__System.registerDynamic('95', ['24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var warning = $__require('24');
    if ('production' !== 'production') {
      var processingChildContext = false;
      var warnInvalidSetState = function () {
        'production' !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
      };
    }
    var ReactInvalidSetStateWarningHook = {
      onBeginProcessingChildContext: function () {
        processingChildContext = true;
      },
      onEndProcessingChildContext: function () {
        processingChildContext = false;
      },
      onSetState: function () {
        warnInvalidSetState();
      }
    };
    module.exports = ReactInvalidSetStateWarningHook;
  })($__require('15'));
});
$__System.registerDynamic('96', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2016-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var history = [];

  var ReactHostOperationHistoryHook = {
    onHostOperation: function (operation) {
      history.push(operation);
    },
    clearHistory: function () {
      if (ReactHostOperationHistoryHook._preventClearing) {
        // Should only be used for tests.
        return;
      }

      history = [];
    },
    getHistory: function () {
      return history;
    }
  };

  module.exports = ReactHostOperationHistoryHook;
});
$__System.registerDynamic('c', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  /**
   * Simple, lightweight module assisting with the detection and context of
   * Worker. Helps avoid circular dependencies and allows code to reason about
   * whether or not they are in a Worker, even if they never include the main
   * `ReactWorker` dependency.
   */
  var ExecutionEnvironment = {

    canUseDOM: canUseDOM,

    canUseWorkers: typeof Worker !== 'undefined',

    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

    canUseViewport: canUseDOM && !!window.screen,

    isInWorker: !canUseDOM // For now, this is true - might change in the future.

  };

  module.exports = ExecutionEnvironment;
});
$__System.registerDynamic('97', ['c'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ExecutionEnvironment = $__require('c');
  var performance;
  if (ExecutionEnvironment.canUseDOM) {
    performance = window.performance || window.msPerformance || window.webkitPerformance;
  }
  module.exports = performance || {};
});
$__System.registerDynamic('98', ['97'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var performance = $__require('97');
  var performanceNow;
  if (performance.now) {
    performanceNow = function performanceNow() {
      return performance.now();
    };
  } else {
    performanceNow = function performanceNow() {
      return Date.now();
    };
  }
  module.exports = performanceNow;
});
$__System.registerDynamic('99', ['95', '96', '3d', 'c', '98', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactInvalidSetStateWarningHook = $__require('95');
    var ReactHostOperationHistoryHook = $__require('96');
    var ReactComponentTreeHook = $__require('3d');
    var ExecutionEnvironment = $__require('c');
    var performanceNow = $__require('98');
    var warning = $__require('24');
    var hooks = [];
    var didHookThrowForEvent = {};
    function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
      try {
        fn.call(context, arg1, arg2, arg3, arg4, arg5);
      } catch (e) {
        'production' !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
        didHookThrowForEvent[event] = true;
      }
    }
    function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
      for (var i = 0; i < hooks.length; i++) {
        var hook = hooks[i];
        var fn = hook[event];
        if (fn) {
          callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
        }
      }
    }
    var isProfiling = false;
    var flushHistory = [];
    var lifeCycleTimerStack = [];
    var currentFlushNesting = 0;
    var currentFlushMeasurements = [];
    var currentFlushStartTime = 0;
    var currentTimerDebugID = null;
    var currentTimerStartTime = 0;
    var currentTimerNestedFlushDuration = 0;
    var currentTimerType = null;
    var lifeCycleTimerHasWarned = false;
    function clearHistory() {
      ReactComponentTreeHook.purgeUnmountedComponents();
      ReactHostOperationHistoryHook.clearHistory();
    }
    function getTreeSnapshot(registeredIDs) {
      return registeredIDs.reduce(function (tree, id) {
        var ownerID = ReactComponentTreeHook.getOwnerID(id);
        var parentID = ReactComponentTreeHook.getParentID(id);
        tree[id] = {
          displayName: ReactComponentTreeHook.getDisplayName(id),
          text: ReactComponentTreeHook.getText(id),
          updateCount: ReactComponentTreeHook.getUpdateCount(id),
          childIDs: ReactComponentTreeHook.getChildIDs(id),
          ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
          parentID: parentID
        };
        return tree;
      }, {});
    }
    function resetMeasurements() {
      var previousStartTime = currentFlushStartTime;
      var previousMeasurements = currentFlushMeasurements;
      var previousOperations = ReactHostOperationHistoryHook.getHistory();
      if (currentFlushNesting === 0) {
        currentFlushStartTime = 0;
        currentFlushMeasurements = [];
        clearHistory();
        return;
      }
      if (previousMeasurements.length || previousOperations.length) {
        var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
        flushHistory.push({
          duration: performanceNow() - previousStartTime,
          measurements: previousMeasurements || [],
          operations: previousOperations || [],
          treeSnapshot: getTreeSnapshot(registeredIDs)
        });
      }
      clearHistory();
      currentFlushStartTime = performanceNow();
      currentFlushMeasurements = [];
    }
    function checkDebugID(debugID) {
      var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (allowRoot && debugID === 0) {
        return;
      }
      if (!debugID) {
        'production' !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
      }
    }
    function beginLifeCycleTimer(debugID, timerType) {
      if (currentFlushNesting === 0) {
        return;
      }
      if (currentTimerType && !lifeCycleTimerHasWarned) {
        'production' !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        lifeCycleTimerHasWarned = true;
      }
      currentTimerStartTime = performanceNow();
      currentTimerNestedFlushDuration = 0;
      currentTimerDebugID = debugID;
      currentTimerType = timerType;
    }
    function endLifeCycleTimer(debugID, timerType) {
      if (currentFlushNesting === 0) {
        return;
      }
      if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
        'production' !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
        lifeCycleTimerHasWarned = true;
      }
      if (isProfiling) {
        currentFlushMeasurements.push({
          timerType: timerType,
          instanceID: debugID,
          duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
        });
      }
      currentTimerStartTime = 0;
      currentTimerNestedFlushDuration = 0;
      currentTimerDebugID = null;
      currentTimerType = null;
    }
    function pauseCurrentLifeCycleTimer() {
      var currentTimer = {
        startTime: currentTimerStartTime,
        nestedFlushStartTime: performanceNow(),
        debugID: currentTimerDebugID,
        timerType: currentTimerType
      };
      lifeCycleTimerStack.push(currentTimer);
      currentTimerStartTime = 0;
      currentTimerNestedFlushDuration = 0;
      currentTimerDebugID = null;
      currentTimerType = null;
    }
    function resumeCurrentLifeCycleTimer() {
      var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
          startTime = _lifeCycleTimerStack$.startTime,
          nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
          debugID = _lifeCycleTimerStack$.debugID,
          timerType = _lifeCycleTimerStack$.timerType;
      var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
      currentTimerStartTime = startTime;
      currentTimerNestedFlushDuration += nestedFlushDuration;
      currentTimerDebugID = debugID;
      currentTimerType = timerType;
    }
    var lastMarkTimeStamp = 0;
    var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
    function shouldMark(debugID) {
      if (!isProfiling || !canUsePerformanceMeasure) {
        return false;
      }
      var element = ReactComponentTreeHook.getElement(debugID);
      if (element == null || typeof element !== 'object') {
        return false;
      }
      var isHostElement = typeof element.type === 'string';
      if (isHostElement) {
        return false;
      }
      return true;
    }
    function markBegin(debugID, markType) {
      if (!shouldMark(debugID)) {
        return;
      }
      var markName = debugID + '::' + markType;
      lastMarkTimeStamp = performanceNow();
      performance.mark(markName);
    }
    function markEnd(debugID, markType) {
      if (!shouldMark(debugID)) {
        return;
      }
      var markName = debugID + '::' + markType;
      var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
      var timeStamp = performanceNow();
      if (timeStamp - lastMarkTimeStamp > 0.1) {
        var measurementName = displayName + ' [' + markType + ']';
        performance.measure(measurementName, markName);
      }
      performance.clearMarks(markName);
      if (measurementName) {
        performance.clearMeasures(measurementName);
      }
    }
    var ReactDebugTool = {
      addHook: function (hook) {
        hooks.push(hook);
      },
      removeHook: function (hook) {
        for (var i = 0; i < hooks.length; i++) {
          if (hooks[i] === hook) {
            hooks.splice(i, 1);
            i--;
          }
        }
      },
      isProfiling: function () {
        return isProfiling;
      },
      beginProfiling: function () {
        if (isProfiling) {
          return;
        }
        isProfiling = true;
        flushHistory.length = 0;
        resetMeasurements();
        ReactDebugTool.addHook(ReactHostOperationHistoryHook);
      },
      endProfiling: function () {
        if (!isProfiling) {
          return;
        }
        isProfiling = false;
        resetMeasurements();
        ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
      },
      getFlushHistory: function () {
        return flushHistory;
      },
      onBeginFlush: function () {
        currentFlushNesting++;
        resetMeasurements();
        pauseCurrentLifeCycleTimer();
        emitEvent('onBeginFlush');
      },
      onEndFlush: function () {
        resetMeasurements();
        currentFlushNesting--;
        resumeCurrentLifeCycleTimer();
        emitEvent('onEndFlush');
      },
      onBeginLifeCycleTimer: function (debugID, timerType) {
        checkDebugID(debugID);
        emitEvent('onBeginLifeCycleTimer', debugID, timerType);
        markBegin(debugID, timerType);
        beginLifeCycleTimer(debugID, timerType);
      },
      onEndLifeCycleTimer: function (debugID, timerType) {
        checkDebugID(debugID);
        endLifeCycleTimer(debugID, timerType);
        markEnd(debugID, timerType);
        emitEvent('onEndLifeCycleTimer', debugID, timerType);
      },
      onBeginProcessingChildContext: function () {
        emitEvent('onBeginProcessingChildContext');
      },
      onEndProcessingChildContext: function () {
        emitEvent('onEndProcessingChildContext');
      },
      onHostOperation: function (operation) {
        checkDebugID(operation.instanceID);
        emitEvent('onHostOperation', operation);
      },
      onSetState: function () {
        emitEvent('onSetState');
      },
      onSetChildren: function (debugID, childDebugIDs) {
        checkDebugID(debugID);
        childDebugIDs.forEach(checkDebugID);
        emitEvent('onSetChildren', debugID, childDebugIDs);
      },
      onBeforeMountComponent: function (debugID, element, parentDebugID) {
        checkDebugID(debugID);
        checkDebugID(parentDebugID, true);
        emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
        markBegin(debugID, 'mount');
      },
      onMountComponent: function (debugID) {
        checkDebugID(debugID);
        markEnd(debugID, 'mount');
        emitEvent('onMountComponent', debugID);
      },
      onBeforeUpdateComponent: function (debugID, element) {
        checkDebugID(debugID);
        emitEvent('onBeforeUpdateComponent', debugID, element);
        markBegin(debugID, 'update');
      },
      onUpdateComponent: function (debugID) {
        checkDebugID(debugID);
        markEnd(debugID, 'update');
        emitEvent('onUpdateComponent', debugID);
      },
      onBeforeUnmountComponent: function (debugID) {
        checkDebugID(debugID);
        emitEvent('onBeforeUnmountComponent', debugID);
        markBegin(debugID, 'unmount');
      },
      onUnmountComponent: function (debugID) {
        checkDebugID(debugID);
        markEnd(debugID, 'unmount');
        emitEvent('onUnmountComponent', debugID);
      },
      onTestEvent: function () {
        emitEvent('onTestEvent');
      }
    };
    ReactDebugTool.addDevtool = ReactDebugTool.addHook;
    ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
    ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
    ReactDebugTool.addHook(ReactComponentTreeHook);
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      ReactDebugTool.beginProfiling();
    }
    module.exports = ReactDebugTool;
  })($__require('15'));
});
$__System.registerDynamic('29', ['99', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var debugTool = null;
    if ('production' !== 'production') {
      var ReactDebugTool = $__require('99');
      debugTool = ReactDebugTool;
    }
    module.exports = { debugTool: debugTool };
  })($__require('15'));
});
$__System.registerDynamic('4d', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    var eventPluginOrder = null;
    var namesToPlugins = {};
    function recomputePluginOrdering() {
      if (!eventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var pluginModule = namesToPlugins[pluginName];
        var pluginIndex = eventPluginOrder.indexOf(pluginName);
        !(pluginIndex > -1) ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
        if (EventPluginRegistry.plugins[pluginIndex]) {
          continue;
        }
        !pluginModule.extractEvents ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
        EventPluginRegistry.plugins[pluginIndex] = pluginModule;
        var publishedEvents = pluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
        }
      }
    }
    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
      !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? 'production' !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
        return true;
      }
      return false;
    }
    function publishRegistrationName(registrationName, pluginModule, eventName) {
      !!EventPluginRegistry.registrationNameModules[registrationName] ? 'production' !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
      EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
      EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
      if ('production' !== 'production') {
        var lowerCasedName = registrationName.toLowerCase();
        EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
        if (registrationName === 'onDoubleClick') {
          EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
        }
      }
    }
    var EventPluginRegistry = {
      plugins: [],
      eventNameDispatchConfigs: {},
      registrationNameModules: {},
      registrationNameDependencies: {},
      possibleRegistrationNames: 'production' !== 'production' ? {} : null,
      injectEventPluginOrder: function (injectedEventPluginOrder) {
        !!eventPluginOrder ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
        recomputePluginOrdering();
      },
      injectEventPluginsByName: function (injectedNamesToPlugins) {
        var isOrderingDirty = false;
        for (var pluginName in injectedNamesToPlugins) {
          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
            continue;
          }
          var pluginModule = injectedNamesToPlugins[pluginName];
          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
            !!namesToPlugins[pluginName] ? 'production' !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
            namesToPlugins[pluginName] = pluginModule;
            isOrderingDirty = true;
          }
        }
        if (isOrderingDirty) {
          recomputePluginOrdering();
        }
      },
      getPluginModuleForEvent: function (event) {
        var dispatchConfig = event.dispatchConfig;
        if (dispatchConfig.registrationName) {
          return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
        }
        if (dispatchConfig.phasedRegistrationNames !== undefined) {
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
          for (var phase in phasedRegistrationNames) {
            if (!phasedRegistrationNames.hasOwnProperty(phase)) {
              continue;
            }
            var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
            if (pluginModule) {
              return pluginModule;
            }
          }
        }
        return null;
      },
      _resetEventPlugins: function () {
        eventPluginOrder = null;
        for (var pluginName in namesToPlugins) {
          if (namesToPlugins.hasOwnProperty(pluginName)) {
            delete namesToPlugins[pluginName];
          }
        }
        EventPluginRegistry.plugins.length = 0;
        var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
        for (var eventName in eventNameDispatchConfigs) {
          if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
            delete eventNameDispatchConfigs[eventName];
          }
        }
        var registrationNameModules = EventPluginRegistry.registrationNameModules;
        for (var registrationName in registrationNameModules) {
          if (registrationNameModules.hasOwnProperty(registrationName)) {
            delete registrationNameModules[registrationName];
          }
        }
        if ('production' !== 'production') {
          var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
          for (var lowerCasedName in possibleRegistrationNames) {
            if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
              delete possibleRegistrationNames[lowerCasedName];
            }
          }
        }
      }
    };
    module.exports = EventPluginRegistry;
  })($__require('15'));
});
$__System.registerDynamic('9a', ['1a', '4d', '3d', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMProperty = $__require('1a');
    var EventPluginRegistry = $__require('4d');
    var ReactComponentTreeHook = $__require('3d');
    var warning = $__require('24');
    if ('production' !== 'production') {
      var reactProps = {
        children: true,
        dangerouslySetInnerHTML: true,
        key: true,
        ref: true,
        autoFocus: true,
        defaultValue: true,
        valueLink: true,
        defaultChecked: true,
        checkedLink: true,
        innerHTML: true,
        suppressContentEditableWarning: true,
        onFocusIn: true,
        onFocusOut: true
      };
      var warnedProperties = {};
      var validateProperty = function (tagName, name, debugID) {
        if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
          return true;
        }
        if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
          return true;
        }
        if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
          return true;
        }
        warnedProperties[name] = true;
        var lowerCasedName = name.toLowerCase();
        var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
        var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
        if (standardName != null) {
          'production' !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
          return true;
        } else if (registrationName != null) {
          'production' !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
          return true;
        } else {
          return false;
        }
      };
    }
    var warnUnknownProperties = function (debugID, element) {
      var unknownProps = [];
      for (var key in element.props) {
        var isValid = validateProperty(element.type, key, debugID);
        if (!isValid) {
          unknownProps.push(key);
        }
      }
      var unknownPropString = unknownProps.map(function (prop) {
        return '`' + prop + '`';
      }).join(', ');
      if (unknownProps.length === 1) {
        'production' !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      } else if (unknownProps.length > 1) {
        'production' !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      }
    };
    function handleElement(debugID, element) {
      if (element == null || typeof element.type !== 'string') {
        return;
      }
      if (element.type.indexOf('-') >= 0 || element.props.is) {
        return;
      }
      warnUnknownProperties(debugID, element);
    }
    var ReactDOMUnknownPropertyHook = {
      onBeforeMountComponent: function (debugID, element) {
        handleElement(debugID, element);
      },
      onBeforeUpdateComponent: function (debugID, element) {
        handleElement(debugID, element);
      }
    };
    module.exports = ReactDOMUnknownPropertyHook;
  })($__require('15'));
});
$__System.registerDynamic('9b', ['3d', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactComponentTreeHook = $__require('3d');
    var warning = $__require('24');
    var didWarnValueNull = false;
    function handleElement(debugID, element) {
      if (element == null) {
        return;
      }
      if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
        return;
      }
      if (element.props != null && element.props.value === null && !didWarnValueNull) {
        'production' !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
        didWarnValueNull = true;
      }
    }
    var ReactDOMNullInputValuePropHook = {
      onBeforeMountComponent: function (debugID, element) {
        handleElement(debugID, element);
      },
      onBeforeUpdateComponent: function (debugID, element) {
        handleElement(debugID, element);
      }
    };
    module.exports = ReactDOMNullInputValuePropHook;
  })($__require('15'));
});
$__System.registerDynamic('2e', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */
  'use strict';

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  var global = this || self,
      GLOBAL = global;
  function reactProdInvariant(code) {
    var argCount = arguments.length - 1;

    var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

    for (var argIdx = 0; argIdx < argCount; argIdx++) {
      message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
    }

    message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

    var error = new Error(message);
    error.name = 'Invariant Violation';
    error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

    throw error;
  }

  module.exports = reactProdInvariant;
});
$__System.registerDynamic('1a', ['2e', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('2e');
    var invariant = $__require('30');
    function checkMask(value, bitmask) {
      return (value & bitmask) === bitmask;
    }
    var DOMPropertyInjection = {
      MUST_USE_PROPERTY: 0x1,
      HAS_BOOLEAN_VALUE: 0x4,
      HAS_NUMERIC_VALUE: 0x8,
      HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
      HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
      injectDOMPropertyConfig: function (domPropertyConfig) {
        var Injection = DOMPropertyInjection;
        var Properties = domPropertyConfig.Properties || {};
        var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
        var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
        if (domPropertyConfig.isCustomAttribute) {
          DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
        }
        for (var propName in Properties) {
          !!DOMProperty.properties.hasOwnProperty(propName) ? 'production' !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
          var lowerCased = propName.toLowerCase();
          var propConfig = Properties[propName];
          var propertyInfo = {
            attributeName: lowerCased,
            attributeNamespace: null,
            propertyName: propName,
            mutationMethod: null,
            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
            hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
            hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
          };
          !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? 'production' !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
          if ('production' !== 'production') {
            DOMProperty.getPossibleStandardName[lowerCased] = propName;
          }
          if (DOMAttributeNames.hasOwnProperty(propName)) {
            var attributeName = DOMAttributeNames[propName];
            propertyInfo.attributeName = attributeName;
            if ('production' !== 'production') {
              DOMProperty.getPossibleStandardName[attributeName] = propName;
            }
          }
          if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
          }
          if (DOMPropertyNames.hasOwnProperty(propName)) {
            propertyInfo.propertyName = DOMPropertyNames[propName];
          }
          if (DOMMutationMethods.hasOwnProperty(propName)) {
            propertyInfo.mutationMethod = DOMMutationMethods[propName];
          }
          DOMProperty.properties[propName] = propertyInfo;
        }
      }
    };
    var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
    var DOMProperty = {
      ID_ATTRIBUTE_NAME: 'data-reactid',
      ROOT_ATTRIBUTE_NAME: 'data-reactroot',
      ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
      ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
      properties: {},
      getPossibleStandardName: 'production' !== 'production' ? { autofocus: 'autoFocus' } : null,
      _isCustomAttributeFunctions: [],
      isCustomAttribute: function (attributeName) {
        for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
          var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
          if (isCustomAttributeFn(attributeName)) {
            return true;
          }
        }
        return false;
      },
      injection: DOMPropertyInjection
    };
    module.exports = DOMProperty;
  })($__require('15'));
});
$__System.registerDynamic('9c', ['1a', '3d', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var DOMProperty = $__require('1a');
    var ReactComponentTreeHook = $__require('3d');
    var warning = $__require('24');
    var warnedProperties = {};
    var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
    function validateProperty(tagName, name, debugID) {
      if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
        return true;
      }
      if (rARIA.test(name)) {
        var lowerCasedName = name.toLowerCase();
        var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
        if (standardName == null) {
          warnedProperties[name] = true;
          return false;
        }
        if (name !== standardName) {
          'production' !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
          warnedProperties[name] = true;
          return true;
        }
      }
      return true;
    }
    function warnInvalidARIAProps(debugID, element) {
      var invalidProps = [];
      for (var key in element.props) {
        var isValid = validateProperty(element.type, key, debugID);
        if (!isValid) {
          invalidProps.push(key);
        }
      }
      var unknownPropString = invalidProps.map(function (prop) {
        return '`' + prop + '`';
      }).join(', ');
      if (invalidProps.length === 1) {
        'production' !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      } else if (invalidProps.length > 1) {
        'production' !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      }
    }
    function handleElement(debugID, element) {
      if (element == null || typeof element.type !== 'string') {
        return;
      }
      if (element.type.indexOf('-') >= 0 || element.props.is) {
        return;
      }
      warnInvalidARIAProps(debugID, element);
    }
    var ReactDOMInvalidARIAHook = {
      onBeforeMountComponent: function (debugID, element) {
        if ('production' !== 'production') {
          handleElement(debugID, element);
        }
      },
      onBeforeUpdateComponent: function (debugID, element) {
        if ('production' !== 'production') {
          handleElement(debugID, element);
        }
      }
    };
    module.exports = ReactDOMInvalidARIAHook;
  })($__require('15'));
});
$__System.registerDynamic('9d', ['f', '7f', '93', '38', '10', '80', '81', '82', '94', '24', 'c', '29', '9a', '9b', '9c', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactDOMComponentTree = $__require('f');
    var ReactDefaultInjection = $__require('7f');
    var ReactMount = $__require('93');
    var ReactReconciler = $__require('38');
    var ReactUpdates = $__require('10');
    var ReactVersion = $__require('80');
    var findDOMNode = $__require('81');
    var getHostComponentFromComposite = $__require('82');
    var renderSubtreeIntoContainer = $__require('94');
    var warning = $__require('24');
    ReactDefaultInjection.inject();
    var ReactDOM = {
      findDOMNode: findDOMNode,
      render: ReactMount.render,
      unmountComponentAtNode: ReactMount.unmountComponentAtNode,
      version: ReactVersion,
      unstable_batchedUpdates: ReactUpdates.batchedUpdates,
      unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
        ComponentTree: {
          getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
          getNodeFromInstance: function (inst) {
            if (inst._renderedComponent) {
              inst = getHostComponentFromComposite(inst);
            }
            if (inst) {
              return ReactDOMComponentTree.getNodeFromInstance(inst);
            } else {
              return null;
            }
          }
        },
        Mount: ReactMount,
        Reconciler: ReactReconciler
      });
    }
    if ('production' !== 'production') {
      var ExecutionEnvironment = $__require('c');
      if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
          if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
            var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
            console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
          }
        }
        var testFunc = function testFn() {};
        'production' !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
        var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
        'production' !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
        var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
        for (var i = 0; i < expectedFeatures.length; i++) {
          if (!expectedFeatures[i]) {
            'production' !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
            break;
          }
        }
      }
    }
    if ('production' !== 'production') {
      var ReactInstrumentation = $__require('29');
      var ReactDOMUnknownPropertyHook = $__require('9a');
      var ReactDOMNullInputValuePropHook = $__require('9b');
      var ReactDOMInvalidARIAHook = $__require('9c');
      ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
      ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
      ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
    }
    module.exports = ReactDOM;
  })($__require('15'));
});
$__System.registerDynamic('9e', ['9d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  module.exports = $__require('9d');
});
$__System.registerDynamic("9f", ["9e"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("9e");
});
$__System.registerDynamic("a0", ["15"], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
  (function (process) {
    (function (f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof undefined === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.PouchDB = f();
      }
    })(function () {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof $__require == "function" && $__require;
              if (!u && a) return a(o, !0);
              if (i) return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = { exports: {} };
            t[o][0].call(l.exports, function (e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof $__require == "function" && $__require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
      }({
        1: [function (_dereq_, module, exports) {
          'use strict';

          module.exports = argsArray;
          function argsArray(fun) {
            return function () {
              var len = arguments.length;
              if (len) {
                var args = [];
                var i = -1;
                while (++i < len) {
                  args[i] = arguments[i];
                }
                return fun.call(this, args);
              } else {
                return fun.call(this, []);
              }
            };
          }
        }, {}],
        2: [function (_dereq_, module, exports) {
          (function (process) {
            exports = module.exports = _dereq_(3);
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
            exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
            function useColors() {
              if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
                return true;
              }
              return typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style || typeof window !== 'undefined' && window && window.console && (console.firebug || console.exception && console.table) || typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }
            exports.formatters.j = function (v) {
              try {
                return JSON.stringify(v);
              } catch (err) {
                return '[UnexpectedJSONParseError]: ' + err.message;
              }
            };
            function formatArgs(args) {
              var useColors = this.useColors;
              args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
              if (!useColors) return;
              var c = 'color: ' + this.color;
              args.splice(1, 0, c, 'color: inherit');
              var index = 0;
              var lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, function (match) {
                if ('%%' === match) return;
                index++;
                if ('%c' === match) {
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }
            function log() {
              return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
            }
            function save(namespaces) {
              try {
                if (null == namespaces) {
                  exports.storage.removeItem('debug');
                } else {
                  exports.storage.debug = namespaces;
                }
              } catch (e) {}
            }
            function load() {
              var r;
              try {
                r = exports.storage.debug;
              } catch (e) {}
              if (!r && typeof process !== 'undefined' && 'env' in process) {
                r = process.env.DEBUG;
              }
              return r;
            }
            exports.enable(load());
            function localstorage() {
              try {
                return window.localStorage;
              } catch (e) {}
            }
          }).call(this, _dereq_(9));
        }, {
          "3": 3,
          "9": 9
        }],
        3: [function (_dereq_, module, exports) {
          exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
          exports.coerce = coerce;
          exports.disable = disable;
          exports.enable = enable;
          exports.enabled = enabled;
          exports.humanize = _dereq_(8);
          exports.names = [];
          exports.skips = [];
          exports.formatters = {};
          var prevTime;
          function selectColor(namespace) {
            var hash = 0,
                i;
            for (i in namespace) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return exports.colors[Math.abs(hash) % exports.colors.length];
          }
          function createDebug(namespace) {
            function debug() {
              if (!debug.enabled) return;
              var self = debug;
              var curr = +new Date();
              var ms = curr - (prevTime || curr);
              self.diff = ms;
              self.prev = prevTime;
              self.curr = curr;
              prevTime = curr;
              var args = new Array(arguments.length);
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
              }
              args[0] = exports.coerce(args[0]);
              if ('string' !== typeof args[0]) {
                args.unshift('%O');
              }
              var index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
                if (match === '%%') return match;
                index++;
                var formatter = exports.formatters[format];
                if ('function' === typeof formatter) {
                  var val = args[index];
                  match = formatter.call(self, val);
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });
              exports.formatArgs.call(self, args);
              var logFn = debug.log || exports.log || console.log.bind(console);
              logFn.apply(self, args);
            }
            debug.namespace = namespace;
            debug.enabled = exports.enabled(namespace);
            debug.useColors = exports.useColors();
            debug.color = selectColor(namespace);
            if ('function' === typeof exports.init) {
              exports.init(debug);
            }
            return debug;
          }
          function enable(namespaces) {
            exports.save(namespaces);
            exports.names = [];
            exports.skips = [];
            var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
            var len = split.length;
            for (var i = 0; i < len; i++) {
              if (!split[i]) continue;
              namespaces = split[i].replace(/\*/g, '.*?');
              if (namespaces[0] === '-') {
                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
              } else {
                exports.names.push(new RegExp('^' + namespaces + '$'));
              }
            }
          }
          function disable() {
            exports.enable('');
          }
          function enabled(name) {
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) {
              if (exports.skips[i].test(name)) {
                return false;
              }
            }
            for (i = 0, len = exports.names.length; i < len; i++) {
              if (exports.names[i].test(name)) {
                return true;
              }
            }
            return false;
          }
          function coerce(val) {
            if (val instanceof Error) return val.stack || val.message;
            return val;
          }
        }, { "8": 8 }],
        4: [function (_dereq_, module, exports) {
          function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined;
          }
          module.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._maxListeners = undefined;
          EventEmitter.defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function (n) {
            if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
            this._maxListeners = n;
            return this;
          };
          EventEmitter.prototype.emit = function (type) {
            var er, handler, len, args, i, listeners;
            if (!this._events) this._events = {};
            if (type === 'error') {
              if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er = arguments[1];
                if (er instanceof Error) {
                  throw er;
                } else {
                  var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                  err.context = er;
                  throw err;
                }
              }
            }
            handler = this._events[type];
            if (isUndefined(handler)) return false;
            if (isFunction(handler)) {
              switch (arguments.length) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  args = Array.prototype.slice.call(arguments, 1);
                  handler.apply(this, args);
              }
            } else if (isObject(handler)) {
              args = Array.prototype.slice.call(arguments, 1);
              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++) listeners[i].apply(this, args);
            }
            return true;
          };
          EventEmitter.prototype.addListener = function (type, listener) {
            var m;
            if (!isFunction(listener)) throw TypeError('listener must be a function');
            if (!this._events) this._events = {};
            if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
            if (!this._events[type]) this._events[type] = listener;else if (isObject(this._events[type])) this._events[type].push(listener);else this._events[type] = [this._events[type], listener];
            if (isObject(this._events[type]) && !this._events[type].warned) {
              if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
              } else {
                m = EventEmitter.defaultMaxListeners;
              }
              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
                if (typeof console.trace === 'function') {
                  console.trace();
                }
              }
            }
            return this;
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.once = function (type, listener) {
            if (!isFunction(listener)) throw TypeError('listener must be a function');
            var fired = false;
            function g() {
              this.removeListener(type, g);
              if (!fired) {
                fired = true;
                listener.apply(this, arguments);
              }
            }
            g.listener = listener;
            this.on(type, g);
            return this;
          };
          EventEmitter.prototype.removeListener = function (type, listener) {
            var list, position, length, i;
            if (!isFunction(listener)) throw TypeError('listener must be a function');
            if (!this._events || !this._events[type]) return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || isFunction(list.listener) && list.listener === listener) {
              delete this._events[type];
              if (this._events.removeListener) this.emit('removeListener', type, listener);
            } else if (isObject(list)) {
              for (i = length; i-- > 0;) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                  position = i;
                  break;
                }
              }
              if (position < 0) return this;
              if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
              } else {
                list.splice(position, 1);
              }
              if (this._events.removeListener) this.emit('removeListener', type, listener);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function (type) {
            var key, listeners;
            if (!this._events) return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
              return this;
            }
            if (arguments.length === 0) {
              for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners('removeListener');
              this._events = {};
              return this;
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
              this.removeListener(type, listeners);
            } else if (listeners) {
              while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];
            return this;
          };
          EventEmitter.prototype.listeners = function (type) {
            var ret;
            if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
            return ret;
          };
          EventEmitter.prototype.listenerCount = function (type) {
            if (this._events) {
              var evlistener = this._events[type];
              if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
            }
            return 0;
          };
          EventEmitter.listenerCount = function (emitter, type) {
            return emitter.listenerCount(type);
          };
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          function isUndefined(arg) {
            return arg === void 0;
          }
        }, {}],
        5: [function (_dereq_, module, exports) {
          (function (global) {
            'use strict';

            var Mutation = global.MutationObserver || global.WebKitMutationObserver;
            var scheduleDrain;
            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick);
                var element = global.document.createTextNode('');
                observer.observe(element, { characterData: true });
                scheduleDrain = function () {
                  element.data = called = ++called % 2;
                };
              } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                var channel = new global.MessageChannel();
                channel.port1.onmessage = nextTick;
                scheduleDrain = function () {
                  channel.port2.postMessage(0);
                };
              } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                scheduleDrain = function () {
                  var scriptEl = global.document.createElement('script');
                  scriptEl.onreadystatechange = function () {
                    nextTick();
                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };
                  global.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function () {
                  setTimeout(nextTick, 0);
                };
              }
            }
            var draining;
            var queue = [];
            function nextTick() {
              draining = true;
              var i, oldQueue;
              var len = queue.length;
              while (len) {
                oldQueue = queue;
                queue = [];
                i = -1;
                while (++i < len) {
                  oldQueue[i]();
                }
                len = queue.length;
              }
              draining = false;
            }
            module.exports = immediate;
            function immediate(task) {
              if (queue.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        6: [function (_dereq_, module, exports) {
          if (typeof Object.create === 'function') {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, { constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                } });
            };
          } else {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function () {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
        }, {}],
        7: [function (_dereq_, module, exports) {
          'use strict';

          var immediate = _dereq_(5);
          function INTERNAL() {}
          var handlers = {};
          var REJECTED = ['REJECTED'];
          var FULFILLED = ['FULFILLED'];
          var PENDING = ['PENDING'];
          module.exports = Promise;
          function Promise(resolver) {
            if (typeof resolver !== 'function') {
              throw new TypeError('resolver must be a function');
            }
            this.state = PENDING;
            this.queue = [];
            this.outcome = void 0;
            if (resolver !== INTERNAL) {
              safelyResolveThenable(this, resolver);
            }
          }
          Promise.prototype["catch"] = function (onRejected) {
            return this.then(null, onRejected);
          };
          Promise.prototype.then = function (onFulfilled, onRejected) {
            if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
              return this;
            }
            var promise = new this.constructor(INTERNAL);
            if (this.state !== PENDING) {
              var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
              unwrap(promise, resolver, this.outcome);
            } else {
              this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
            }
            return promise;
          };
          function QueueItem(promise, onFulfilled, onRejected) {
            this.promise = promise;
            if (typeof onFulfilled === 'function') {
              this.onFulfilled = onFulfilled;
              this.callFulfilled = this.otherCallFulfilled;
            }
            if (typeof onRejected === 'function') {
              this.onRejected = onRejected;
              this.callRejected = this.otherCallRejected;
            }
          }
          QueueItem.prototype.callFulfilled = function (value) {
            handlers.resolve(this.promise, value);
          };
          QueueItem.prototype.otherCallFulfilled = function (value) {
            unwrap(this.promise, this.onFulfilled, value);
          };
          QueueItem.prototype.callRejected = function (value) {
            handlers.reject(this.promise, value);
          };
          QueueItem.prototype.otherCallRejected = function (value) {
            unwrap(this.promise, this.onRejected, value);
          };
          function unwrap(promise, func, value) {
            immediate(function () {
              var returnValue;
              try {
                returnValue = func(value);
              } catch (e) {
                return handlers.reject(promise, e);
              }
              if (returnValue === promise) {
                handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
              } else {
                handlers.resolve(promise, returnValue);
              }
            });
          }
          handlers.resolve = function (self, value) {
            var result = tryCatch(getThen, value);
            if (result.status === 'error') {
              return handlers.reject(self, result.value);
            }
            var thenable = result.value;
            if (thenable) {
              safelyResolveThenable(self, thenable);
            } else {
              self.state = FULFILLED;
              self.outcome = value;
              var i = -1;
              var len = self.queue.length;
              while (++i < len) {
                self.queue[i].callFulfilled(value);
              }
            }
            return self;
          };
          handlers.reject = function (self, error) {
            self.state = REJECTED;
            self.outcome = error;
            var i = -1;
            var len = self.queue.length;
            while (++i < len) {
              self.queue[i].callRejected(error);
            }
            return self;
          };
          function getThen(obj) {
            var then = obj && obj.then;
            if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
              return function appyThen() {
                then.apply(obj, arguments);
              };
            }
          }
          function safelyResolveThenable(self, thenable) {
            var called = false;
            function onError(value) {
              if (called) {
                return;
              }
              called = true;
              handlers.reject(self, value);
            }
            function onSuccess(value) {
              if (called) {
                return;
              }
              called = true;
              handlers.resolve(self, value);
            }
            function tryToUnwrap() {
              thenable(onSuccess, onError);
            }
            var result = tryCatch(tryToUnwrap);
            if (result.status === 'error') {
              onError(result.value);
            }
          }
          function tryCatch(func, value) {
            var out = {};
            try {
              out.value = func(value);
              out.status = 'success';
            } catch (e) {
              out.status = 'error';
              out.value = e;
            }
            return out;
          }
          Promise.resolve = resolve;
          function resolve(value) {
            if (value instanceof this) {
              return value;
            }
            return handlers.resolve(new this(INTERNAL), value);
          }
          Promise.reject = reject;
          function reject(reason) {
            var promise = new this(INTERNAL);
            return handlers.reject(promise, reason);
          }
          Promise.all = all;
          function all(iterable) {
            var self = this;
            if (Object.prototype.toString.call(iterable) !== '[object Array]') {
              return this.reject(new TypeError('must be an array'));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var values = new Array(len);
            var resolved = 0;
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              allResolver(iterable[i], i);
            }
            return promise;
            function allResolver(value, i) {
              self.resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });
              function resolveFromAll(outValue) {
                values[i] = outValue;
                if (++resolved === len && !called) {
                  called = true;
                  handlers.resolve(promise, values);
                }
              }
            }
          }
          Promise.race = race;
          function race(iterable) {
            var self = this;
            if (Object.prototype.toString.call(iterable) !== '[object Array]') {
              return this.reject(new TypeError('must be an array'));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              resolver(iterable[i]);
            }
            return promise;
            function resolver(value) {
              self.resolve(value).then(function (response) {
                if (!called) {
                  called = true;
                  handlers.resolve(promise, response);
                }
              }, function (error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });
            }
          }
        }, { "5": 5 }],
        8: [function (_dereq_, module, exports) {
          var s = 1000;
          var m = s * 60;
          var h = m * 60;
          var d = h * 24;
          var y = d * 365.25;
          module.exports = function (val, options) {
            options = options || {};
            var type = typeof val;
            if (type === 'string' && val.length > 0) {
              return parse(val);
            } else if (type === 'number' && isNaN(val) === false) {
              return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
          };
          function parse(str) {
            str = String(str);
            if (str.length > 10000) {
              return;
            }
            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
            if (!match) {
              return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || 'ms').toLowerCase();
            switch (type) {
              case 'years':
              case 'year':
              case 'yrs':
              case 'yr':
              case 'y':
                return n * y;
              case 'days':
              case 'day':
              case 'd':
                return n * d;
              case 'hours':
              case 'hour':
              case 'hrs':
              case 'hr':
              case 'h':
                return n * h;
              case 'minutes':
              case 'minute':
              case 'mins':
              case 'min':
              case 'm':
                return n * m;
              case 'seconds':
              case 'second':
              case 'secs':
              case 'sec':
              case 's':
                return n * s;
              case 'milliseconds':
              case 'millisecond':
              case 'msecs':
              case 'msec':
              case 'ms':
                return n;
              default:
                return undefined;
            }
          }
          function fmtShort(ms) {
            if (ms >= d) {
              return Math.round(ms / d) + 'd';
            }
            if (ms >= h) {
              return Math.round(ms / h) + 'h';
            }
            if (ms >= m) {
              return Math.round(ms / m) + 'm';
            }
            if (ms >= s) {
              return Math.round(ms / s) + 's';
            }
            return ms + 'ms';
          }
          function fmtLong(ms) {
            return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
          }
          function plural(ms, n, name) {
            if (ms < n) {
              return;
            }
            if (ms < n * 1.5) {
              return Math.floor(ms / n) + ' ' + name;
            }
            return Math.ceil(ms / n) + ' ' + name + 's';
          }
        }, {}],
        9: [function (_dereq_, module, exports) {
          var process = module.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
          }
          (function () {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function (fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array);
          };
          process.title = 'browser';
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = '';
          process.versions = {};
          function noop() {}
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;
          process.listeners = function (name) {
            return [];
          };
          process.binding = function (name) {
            throw new Error('process.binding is not supported');
          };
          process.cwd = function () {
            return '/';
          };
          process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
          };
          process.umask = function () {
            return 0;
          };
        }, {}],
        10: [function (_dereq_, module, exports) {
          (function (factory) {
            if (typeof exports === 'object') {
              module.exports = factory();
            } else if (typeof define === 'function' && define.amd) {
              define(factory);
            } else {
              var glob;
              try {
                glob = window;
              } catch (e) {
                glob = self;
              }
              glob.SparkMD5 = factory();
            }
          })(function (undefined) {
            'use strict';

            var add32 = function (a, b) {
              return a + b & 0xFFFFFFFF;
            },
                hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
            function cmn(q, a, b, x, s, t) {
              a = add32(add32(a, q), add32(x, t));
              return add32(a << s | a >>> 32 - s, b);
            }
            function md5cycle(x, k) {
              var a = x[0],
                  b = x[1],
                  c = x[2],
                  d = x[3];
              a += (b & c | ~b & d) + k[0] - 680876936 | 0;
              a = (a << 7 | a >>> 25) + b | 0;
              d += (a & b | ~a & c) + k[1] - 389564586 | 0;
              d = (d << 12 | d >>> 20) + a | 0;
              c += (d & a | ~d & b) + k[2] + 606105819 | 0;
              c = (c << 17 | c >>> 15) + d | 0;
              b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
              b = (b << 22 | b >>> 10) + c | 0;
              a += (b & c | ~b & d) + k[4] - 176418897 | 0;
              a = (a << 7 | a >>> 25) + b | 0;
              d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
              d = (d << 12 | d >>> 20) + a | 0;
              c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
              c = (c << 17 | c >>> 15) + d | 0;
              b += (c & d | ~c & a) + k[7] - 45705983 | 0;
              b = (b << 22 | b >>> 10) + c | 0;
              a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
              a = (a << 7 | a >>> 25) + b | 0;
              d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
              d = (d << 12 | d >>> 20) + a | 0;
              c += (d & a | ~d & b) + k[10] - 42063 | 0;
              c = (c << 17 | c >>> 15) + d | 0;
              b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
              b = (b << 22 | b >>> 10) + c | 0;
              a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
              a = (a << 7 | a >>> 25) + b | 0;
              d += (a & b | ~a & c) + k[13] - 40341101 | 0;
              d = (d << 12 | d >>> 20) + a | 0;
              c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
              c = (c << 17 | c >>> 15) + d | 0;
              b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
              b = (b << 22 | b >>> 10) + c | 0;
              a += (b & d | c & ~d) + k[1] - 165796510 | 0;
              a = (a << 5 | a >>> 27) + b | 0;
              d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
              d = (d << 9 | d >>> 23) + a | 0;
              c += (d & b | a & ~b) + k[11] + 643717713 | 0;
              c = (c << 14 | c >>> 18) + d | 0;
              b += (c & a | d & ~a) + k[0] - 373897302 | 0;
              b = (b << 20 | b >>> 12) + c | 0;
              a += (b & d | c & ~d) + k[5] - 701558691 | 0;
              a = (a << 5 | a >>> 27) + b | 0;
              d += (a & c | b & ~c) + k[10] + 38016083 | 0;
              d = (d << 9 | d >>> 23) + a | 0;
              c += (d & b | a & ~b) + k[15] - 660478335 | 0;
              c = (c << 14 | c >>> 18) + d | 0;
              b += (c & a | d & ~a) + k[4] - 405537848 | 0;
              b = (b << 20 | b >>> 12) + c | 0;
              a += (b & d | c & ~d) + k[9] + 568446438 | 0;
              a = (a << 5 | a >>> 27) + b | 0;
              d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
              d = (d << 9 | d >>> 23) + a | 0;
              c += (d & b | a & ~b) + k[3] - 187363961 | 0;
              c = (c << 14 | c >>> 18) + d | 0;
              b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
              b = (b << 20 | b >>> 12) + c | 0;
              a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
              a = (a << 5 | a >>> 27) + b | 0;
              d += (a & c | b & ~c) + k[2] - 51403784 | 0;
              d = (d << 9 | d >>> 23) + a | 0;
              c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
              c = (c << 14 | c >>> 18) + d | 0;
              b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
              b = (b << 20 | b >>> 12) + c | 0;
              a += (b ^ c ^ d) + k[5] - 378558 | 0;
              a = (a << 4 | a >>> 28) + b | 0;
              d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
              d = (d << 11 | d >>> 21) + a | 0;
              c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
              c = (c << 16 | c >>> 16) + d | 0;
              b += (c ^ d ^ a) + k[14] - 35309556 | 0;
              b = (b << 23 | b >>> 9) + c | 0;
              a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
              a = (a << 4 | a >>> 28) + b | 0;
              d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
              d = (d << 11 | d >>> 21) + a | 0;
              c += (d ^ a ^ b) + k[7] - 155497632 | 0;
              c = (c << 16 | c >>> 16) + d | 0;
              b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
              b = (b << 23 | b >>> 9) + c | 0;
              a += (b ^ c ^ d) + k[13] + 681279174 | 0;
              a = (a << 4 | a >>> 28) + b | 0;
              d += (a ^ b ^ c) + k[0] - 358537222 | 0;
              d = (d << 11 | d >>> 21) + a | 0;
              c += (d ^ a ^ b) + k[3] - 722521979 | 0;
              c = (c << 16 | c >>> 16) + d | 0;
              b += (c ^ d ^ a) + k[6] + 76029189 | 0;
              b = (b << 23 | b >>> 9) + c | 0;
              a += (b ^ c ^ d) + k[9] - 640364487 | 0;
              a = (a << 4 | a >>> 28) + b | 0;
              d += (a ^ b ^ c) + k[12] - 421815835 | 0;
              d = (d << 11 | d >>> 21) + a | 0;
              c += (d ^ a ^ b) + k[15] + 530742520 | 0;
              c = (c << 16 | c >>> 16) + d | 0;
              b += (c ^ d ^ a) + k[2] - 995338651 | 0;
              b = (b << 23 | b >>> 9) + c | 0;
              a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
              a = (a << 6 | a >>> 26) + b | 0;
              d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
              d = (d << 10 | d >>> 22) + a | 0;
              c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
              c = (c << 15 | c >>> 17) + d | 0;
              b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
              b = (b << 21 | b >>> 11) + c | 0;
              a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
              a = (a << 6 | a >>> 26) + b | 0;
              d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
              d = (d << 10 | d >>> 22) + a | 0;
              c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
              c = (c << 15 | c >>> 17) + d | 0;
              b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
              b = (b << 21 | b >>> 11) + c | 0;
              a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
              a = (a << 6 | a >>> 26) + b | 0;
              d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
              d = (d << 10 | d >>> 22) + a | 0;
              c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
              c = (c << 15 | c >>> 17) + d | 0;
              b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
              b = (b << 21 | b >>> 11) + c | 0;
              a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
              a = (a << 6 | a >>> 26) + b | 0;
              d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
              d = (d << 10 | d >>> 22) + a | 0;
              c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
              c = (c << 15 | c >>> 17) + d | 0;
              b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
              b = (b << 21 | b >>> 11) + c | 0;
              x[0] = a + x[0] | 0;
              x[1] = b + x[1] | 0;
              x[2] = c + x[2] | 0;
              x[3] = d + x[3] | 0;
            }
            function md5blk(s) {
              var md5blks = [],
                  i;
              for (i = 0; i < 64; i += 4) {
                md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
              }
              return md5blks;
            }
            function md5blk_array(a) {
              var md5blks = [],
                  i;
              for (i = 0; i < 64; i += 4) {
                md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
              }
              return md5blks;
            }
            function md51(s) {
              var n = s.length,
                  state = [1732584193, -271733879, -1732584194, 271733878],
                  i,
                  length,
                  tail,
                  tmp,
                  lo,
                  hi;
              for (i = 64; i <= n; i += 64) {
                md5cycle(state, md5blk(s.substring(i - 64, i)));
              }
              s = s.substring(i - 64);
              length = s.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
              }
              tail[i >> 2] |= 0x80 << (i % 4 << 3);
              if (i > 55) {
                md5cycle(state, tail);
                for (i = 0; i < 16; i += 1) {
                  tail[i] = 0;
                }
              }
              tmp = n * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(state, tail);
              return state;
            }
            function md51_array(a) {
              var n = a.length,
                  state = [1732584193, -271733879, -1732584194, 271733878],
                  i,
                  length,
                  tail,
                  tmp,
                  lo,
                  hi;
              for (i = 64; i <= n; i += 64) {
                md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
              }
              a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
              length = a.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= a[i] << (i % 4 << 3);
              }
              tail[i >> 2] |= 0x80 << (i % 4 << 3);
              if (i > 55) {
                md5cycle(state, tail);
                for (i = 0; i < 16; i += 1) {
                  tail[i] = 0;
                }
              }
              tmp = n * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(state, tail);
              return state;
            }
            function rhex(n) {
              var s = '',
                  j;
              for (j = 0; j < 4; j += 1) {
                s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];
              }
              return s;
            }
            function hex(x) {
              var i;
              for (i = 0; i < x.length; i += 1) {
                x[i] = rhex(x[i]);
              }
              return x.join('');
            }
            if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
              add32 = function (x, y) {
                var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                    msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                return msw << 16 | lsw & 0xFFFF;
              };
            }
            if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
              (function () {
                function clamp(val, length) {
                  val = val | 0 || 0;
                  if (val < 0) {
                    return Math.max(val + length, 0);
                  }
                  return Math.min(val, length);
                }
                ArrayBuffer.prototype.slice = function (from, to) {
                  var length = this.byteLength,
                      begin = clamp(from, length),
                      end = length,
                      num,
                      target,
                      targetArray,
                      sourceArray;
                  if (to !== undefined) {
                    end = clamp(to, length);
                  }
                  if (begin > end) {
                    return new ArrayBuffer(0);
                  }
                  num = end - begin;
                  target = new ArrayBuffer(num);
                  targetArray = new Uint8Array(target);
                  sourceArray = new Uint8Array(this, begin, num);
                  targetArray.set(sourceArray);
                  return target;
                };
              })();
            }
            function toUtf8(str) {
              if (/[\u0080-\uFFFF]/.test(str)) {
                str = unescape(encodeURIComponent(str));
              }
              return str;
            }
            function utf8Str2ArrayBuffer(str, returnUInt8Array) {
              var length = str.length,
                  buff = new ArrayBuffer(length),
                  arr = new Uint8Array(buff),
                  i;
              for (i = 0; i < length; i += 1) {
                arr[i] = str.charCodeAt(i);
              }
              return returnUInt8Array ? arr : buff;
            }
            function arrayBuffer2Utf8Str(buff) {
              return String.fromCharCode.apply(null, new Uint8Array(buff));
            }
            function concatenateArrayBuffers(first, second, returnUInt8Array) {
              var result = new Uint8Array(first.byteLength + second.byteLength);
              result.set(new Uint8Array(first));
              result.set(new Uint8Array(second), first.byteLength);
              return returnUInt8Array ? result : result.buffer;
            }
            function hexToBinaryString(hex) {
              var bytes = [],
                  length = hex.length,
                  x;
              for (x = 0; x < length - 1; x += 2) {
                bytes.push(parseInt(hex.substr(x, 2), 16));
              }
              return String.fromCharCode.apply(String, bytes);
            }
            function SparkMD5() {
              this.reset();
            }
            SparkMD5.prototype.append = function (str) {
              this.appendBinary(toUtf8(str));
              return this;
            };
            SparkMD5.prototype.appendBinary = function (contents) {
              this._buff += contents;
              this._length += contents.length;
              var length = this._buff.length,
                  i;
              for (i = 64; i <= length; i += 64) {
                md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
              }
              this._buff = this._buff.substring(i - 64);
              return this;
            };
            SparkMD5.prototype.end = function (raw) {
              var buff = this._buff,
                  length = buff.length,
                  i,
                  tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  ret;
              for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD5.prototype.reset = function () {
              this._buff = '';
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD5.prototype.getState = function () {
              return {
                buff: this._buff,
                length: this._length,
                hash: this._hash
              };
            };
            SparkMD5.prototype.setState = function (state) {
              this._buff = state.buff;
              this._length = state.length;
              this._hash = state.hash;
              return this;
            };
            SparkMD5.prototype.destroy = function () {
              delete this._hash;
              delete this._buff;
              delete this._length;
            };
            SparkMD5.prototype._finish = function (tail, length) {
              var i = length,
                  tmp,
                  lo,
                  hi;
              tail[i >> 2] |= 0x80 << (i % 4 << 3);
              if (i > 55) {
                md5cycle(this._hash, tail);
                for (i = 0; i < 16; i += 1) {
                  tail[i] = 0;
                }
              }
              tmp = this._length * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(this._hash, tail);
            };
            SparkMD5.hash = function (str, raw) {
              return SparkMD5.hashBinary(toUtf8(str), raw);
            };
            SparkMD5.hashBinary = function (content, raw) {
              var hash = md51(content),
                  ret = hex(hash);
              return raw ? hexToBinaryString(ret) : ret;
            };
            SparkMD5.ArrayBuffer = function () {
              this.reset();
            };
            SparkMD5.ArrayBuffer.prototype.append = function (arr) {
              var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
                  length = buff.length,
                  i;
              this._length += arr.byteLength;
              for (i = 64; i <= length; i += 64) {
                md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
              }
              this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
              return this;
            };
            SparkMD5.ArrayBuffer.prototype.end = function (raw) {
              var buff = this._buff,
                  length = buff.length,
                  tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                  i,
                  ret;
              for (i = 0; i < length; i += 1) {
                tail[i >> 2] |= buff[i] << (i % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD5.ArrayBuffer.prototype.reset = function () {
              this._buff = new Uint8Array(0);
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD5.ArrayBuffer.prototype.getState = function () {
              var state = SparkMD5.prototype.getState.call(this);
              state.buff = arrayBuffer2Utf8Str(state.buff);
              return state;
            };
            SparkMD5.ArrayBuffer.prototype.setState = function (state) {
              state.buff = utf8Str2ArrayBuffer(state.buff, true);
              return SparkMD5.prototype.setState.call(this, state);
            };
            SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
            SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
            SparkMD5.ArrayBuffer.hash = function (arr, raw) {
              var hash = md51_array(new Uint8Array(arr)),
                  ret = hex(hash);
              return raw ? hexToBinaryString(ret) : ret;
            };
            return SparkMD5;
          });
        }, {}],
        11: [function (_dereq_, module, exports) {
          var byteToHex = [];
          for (var i = 0; i < 256; ++i) {
            byteToHex[i] = (i + 0x100).toString(16).substr(1);
          }
          function bytesToUuid(buf, offset) {
            var i = offset || 0;
            var bth = byteToHex;
            return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
          }
          module.exports = bytesToUuid;
        }, {}],
        12: [function (_dereq_, module, exports) {
          (function (global) {
            var rng;
            var crypto = global.crypto || global.msCrypto;
            if (crypto && crypto.getRandomValues) {
              var rnds8 = new Uint8Array(16);
              rng = function whatwgRNG() {
                crypto.getRandomValues(rnds8);
                return rnds8;
              };
            }
            if (!rng) {
              var rnds = new Array(16);
              rng = function () {
                for (var i = 0, r; i < 16; i++) {
                  if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
                  rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
                }
                return rnds;
              };
            }
            module.exports = rng;
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        13: [function (_dereq_, module, exports) {
          var rng = _dereq_(12);
          var bytesToUuid = _dereq_(11);
          function v4(options, buf, offset) {
            var i = buf && offset || 0;
            if (typeof options == 'string') {
              buf = options == 'binary' ? new Array(16) : null;
              options = null;
            }
            options = options || {};
            var rnds = options.random || (options.rng || rng)();
            rnds[6] = rnds[6] & 0x0f | 0x40;
            rnds[8] = rnds[8] & 0x3f | 0x80;
            if (buf) {
              for (var ii = 0; ii < 16; ++ii) {
                buf[i + ii] = rnds[ii];
              }
            }
            return buf || bytesToUuid(rnds);
          }
          module.exports = v4;
        }, {
          "11": 11,
          "12": 12
        }],
        14: [function (_dereq_, module, exports) {
          'use strict';

          exports.stringify = function stringify(input) {
            var queue = [];
            queue.push({ obj: input });
            var res = '';
            var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;
            while (next = queue.pop()) {
              obj = next.obj;
              prefix = next.prefix || '';
              val = next.val || '';
              res += prefix;
              if (val) {
                res += val;
              } else if (typeof obj !== 'object') {
                res += typeof obj === 'undefined' ? null : JSON.stringify(obj);
              } else if (obj === null) {
                res += 'null';
              } else if (Array.isArray(obj)) {
                queue.push({ val: ']' });
                for (i = obj.length - 1; i >= 0; i--) {
                  arrayPrefix = i === 0 ? '' : ',';
                  queue.push({
                    obj: obj[i],
                    prefix: arrayPrefix
                  });
                }
                queue.push({ val: '[' });
              } else {
                keys = [];
                for (k in obj) {
                  if (obj.hasOwnProperty(k)) {
                    keys.push(k);
                  }
                }
                queue.push({ val: '}' });
                for (i = keys.length - 1; i >= 0; i--) {
                  key = keys[i];
                  value = obj[key];
                  objPrefix = i > 0 ? ',' : '';
                  objPrefix += JSON.stringify(key) + ':';
                  queue.push({
                    obj: value,
                    prefix: objPrefix
                  });
                }
                queue.push({ val: '{' });
              }
            }
            return res;
          };
          function pop(obj, stack, metaStack) {
            var lastMetaElement = metaStack[metaStack.length - 1];
            if (obj === lastMetaElement.element) {
              metaStack.pop();
              lastMetaElement = metaStack[metaStack.length - 1];
            }
            var element = lastMetaElement.element;
            var lastElementIndex = lastMetaElement.index;
            if (Array.isArray(element)) {
              element.push(obj);
            } else if (lastElementIndex === stack.length - 2) {
              var key = stack.pop();
              element[key] = obj;
            } else {
              stack.push(obj);
            }
          }
          exports.parse = function (str) {
            var stack = [];
            var metaStack = [];
            var i = 0;
            var collationIndex, parsedNum, numChar;
            var parsedString, lastCh, numConsecutiveSlashes, ch;
            var arrayElement, objElement;
            while (true) {
              collationIndex = str[i++];
              if (collationIndex === '}' || collationIndex === ']' || typeof collationIndex === 'undefined') {
                if (stack.length === 1) {
                  return stack.pop();
                } else {
                  pop(stack.pop(), stack, metaStack);
                  continue;
                }
              }
              switch (collationIndex) {
                case ' ':
                case '\t':
                case '\n':
                case ':':
                case ',':
                  break;
                case 'n':
                  i += 3;
                  pop(null, stack, metaStack);
                  break;
                case 't':
                  i += 3;
                  pop(true, stack, metaStack);
                  break;
                case 'f':
                  i += 4;
                  pop(false, stack, metaStack);
                  break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case '-':
                  parsedNum = '';
                  i--;
                  while (true) {
                    numChar = str[i++];
                    if (/[\d\.\-e\+]/.test(numChar)) {
                      parsedNum += numChar;
                    } else {
                      i--;
                      break;
                    }
                  }
                  pop(parseFloat(parsedNum), stack, metaStack);
                  break;
                case '"':
                  parsedString = '';
                  lastCh = void 0;
                  numConsecutiveSlashes = 0;
                  while (true) {
                    ch = str[i++];
                    if (ch !== '"' || lastCh === '\\' && numConsecutiveSlashes % 2 === 1) {
                      parsedString += ch;
                      lastCh = ch;
                      if (lastCh === '\\') {
                        numConsecutiveSlashes++;
                      } else {
                        numConsecutiveSlashes = 0;
                      }
                    } else {
                      break;
                    }
                  }
                  pop(JSON.parse('"' + parsedString + '"'), stack, metaStack);
                  break;
                case '[':
                  arrayElement = {
                    element: [],
                    index: stack.length
                  };
                  stack.push(arrayElement.element);
                  metaStack.push(arrayElement);
                  break;
                case '{':
                  objElement = {
                    element: {},
                    index: stack.length
                  };
                  stack.push(objElement.element);
                  metaStack.push(objElement);
                  break;
                default:
                  throw new Error('unexpectedly reached end of input: ' + collationIndex);
              }
            }
          };
        }, {}],
        15: [function (_dereq_, module, exports) {
          (function (global) {
            'use strict';

            function _interopDefault(ex) {
              return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
            }
            var lie = _interopDefault(_dereq_(7));
            var getArguments = _interopDefault(_dereq_(1));
            var events = _dereq_(4);
            var inherits = _interopDefault(_dereq_(6));
            var nextTick = _interopDefault(_dereq_(5));
            var v4 = _interopDefault(_dereq_(13));
            var debug = _interopDefault(_dereq_(2));
            var Md5 = _interopDefault(_dereq_(10));
            var vuvuzela = _interopDefault(_dereq_(14));
            var PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;
            function isBinaryObject(object) {
              return typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer || typeof Blob !== 'undefined' && object instanceof Blob;
            }
            function cloneArrayBuffer(buff) {
              if (typeof buff.slice === 'function') {
                return buff.slice(0);
              }
              var target = new ArrayBuffer(buff.byteLength);
              var targetArray = new Uint8Array(target);
              var sourceArray = new Uint8Array(buff);
              targetArray.set(sourceArray);
              return target;
            }
            function cloneBinaryObject(object) {
              if (object instanceof ArrayBuffer) {
                return cloneArrayBuffer(object);
              }
              var size = object.size;
              var type = object.type;
              if (typeof object.slice === 'function') {
                return object.slice(0, size, type);
              }
              return object.webkitSlice(0, size, type);
            }
            var funcToString = Function.prototype.toString;
            var objectCtorString = funcToString.call(Object);
            function isPlainObject(value) {
              var proto = Object.getPrototypeOf(value);
              if (proto === null) {
                return true;
              }
              var Ctor = proto.constructor;
              return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
            }
            function clone(object) {
              var newObject;
              var i;
              var len;
              if (!object || typeof object !== 'object') {
                return object;
              }
              if (Array.isArray(object)) {
                newObject = [];
                for (i = 0, len = object.length; i < len; i++) {
                  newObject[i] = clone(object[i]);
                }
                return newObject;
              }
              if (object instanceof Date) {
                return object.toISOString();
              }
              if (isBinaryObject(object)) {
                return cloneBinaryObject(object);
              }
              if (!isPlainObject(object)) {
                return object;
              }
              newObject = {};
              for (i in object) {
                if (Object.prototype.hasOwnProperty.call(object, i)) {
                  var value = clone(object[i]);
                  if (typeof value !== 'undefined') {
                    newObject[i] = value;
                  }
                }
              }
              return newObject;
            }
            function once(fun) {
              var called = false;
              return getArguments(function (args) {
                if (called) {
                  throw new Error('once called more than once');
                } else {
                  called = true;
                  fun.apply(this, args);
                }
              });
            }
            function toPromise(func) {
              return getArguments(function (args) {
                args = clone(args);
                var self = this;
                var usedCB = typeof args[args.length - 1] === 'function' ? args.pop() : false;
                var promise = new PouchPromise$1(function (fulfill, reject) {
                  var resp;
                  try {
                    var callback = once(function (err, mesg) {
                      if (err) {
                        reject(err);
                      } else {
                        fulfill(mesg);
                      }
                    });
                    args.push(callback);
                    resp = func.apply(self, args);
                    if (resp && typeof resp.then === 'function') {
                      fulfill(resp);
                    }
                  } catch (e) {
                    reject(e);
                  }
                });
                if (usedCB) {
                  promise.then(function (result) {
                    usedCB(null, result);
                  }, usedCB);
                }
                return promise;
              });
            }
            function logApiCall(self, name, args) {
              if (self.constructor.listeners('debug').length) {
                var logArgs = ['api', self.name, name];
                for (var i = 0; i < args.length - 1; i++) {
                  logArgs.push(args[i]);
                }
                self.constructor.emit('debug', logArgs);
                var origCallback = args[args.length - 1];
                args[args.length - 1] = function (err, res) {
                  var responseArgs = ['api', self.name, name];
                  responseArgs = responseArgs.concat(err ? ['error', err] : ['success', res]);
                  self.constructor.emit('debug', responseArgs);
                  origCallback(err, res);
                };
              }
            }
            function adapterFun(name, callback) {
              return toPromise(getArguments(function (args) {
                if (this._closed) {
                  return PouchPromise$1.reject(new Error('database is closed'));
                }
                if (this._destroyed) {
                  return PouchPromise$1.reject(new Error('database is destroyed'));
                }
                var self = this;
                logApiCall(self, name, args);
                if (!this.taskqueue.isReady) {
                  return new PouchPromise$1(function (fulfill, reject) {
                    self.taskqueue.addTask(function (failed) {
                      if (failed) {
                        reject(failed);
                      } else {
                        fulfill(self[name].apply(self, args));
                      }
                    });
                  });
                }
                return callback.apply(this, args);
              }));
            }
            function mangle(key) {
              return '$' + key;
            }
            function unmangle(key) {
              return key.substring(1);
            }
            function Map$1() {
              this._store = {};
            }
            Map$1.prototype.get = function (key) {
              var mangled = mangle(key);
              return this._store[mangled];
            };
            Map$1.prototype.set = function (key, value) {
              var mangled = mangle(key);
              this._store[mangled] = value;
              return true;
            };
            Map$1.prototype.has = function (key) {
              var mangled = mangle(key);
              return mangled in this._store;
            };
            Map$1.prototype["delete"] = function (key) {
              var mangled = mangle(key);
              var res = mangled in this._store;
              delete this._store[mangled];
              return res;
            };
            Map$1.prototype.forEach = function (cb) {
              var keys = Object.keys(this._store);
              for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                var value = this._store[key];
                key = unmangle(key);
                cb(value, key);
              }
            };
            Object.defineProperty(Map$1.prototype, 'size', { get: function () {
                return Object.keys(this._store).length;
              } });
            function Set$1(array) {
              this._store = new Map$1();
              if (array && Array.isArray(array)) {
                for (var i = 0, len = array.length; i < len; i++) {
                  this.add(array[i]);
                }
              }
            }
            Set$1.prototype.add = function (key) {
              return this._store.set(key, true);
            };
            Set$1.prototype.has = function (key) {
              return this._store.has(key);
            };
            Set$1.prototype.forEach = function (cb) {
              this._store.forEach(function (value, key) {
                cb(key);
              });
            };
            Object.defineProperty(Set$1.prototype, 'size', { get: function () {
                return this._store.size;
              } });
            function supportsMapAndSet() {
              if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {
                return false;
              }
              var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);
              return prop && 'get' in prop && Map[Symbol.species] === Map;
            }
            var ExportedSet;
            var ExportedMap;
            {
              if (supportsMapAndSet()) {
                ExportedSet = Set;
                ExportedMap = Map;
              } else {
                ExportedSet = Set$1;
                ExportedMap = Map$1;
              }
            }
            function pick(obj, arr) {
              var res = {};
              for (var i = 0, len = arr.length; i < len; i++) {
                var prop = arr[i];
                if (prop in obj) {
                  res[prop] = obj[prop];
                }
              }
              return res;
            }
            var MAX_NUM_CONCURRENT_REQUESTS = 6;
            function identityFunction(x) {
              return x;
            }
            function formatResultForOpenRevsGet(result) {
              return [{ ok: result }];
            }
            function bulkGet(db, opts, callback) {
              var requests = opts.docs;
              var requestsById = new ExportedMap();
              requests.forEach(function (request) {
                if (requestsById.has(request.id)) {
                  requestsById.get(request.id).push(request);
                } else {
                  requestsById.set(request.id, [request]);
                }
              });
              var numDocs = requestsById.size;
              var numDone = 0;
              var perDocResults = new Array(numDocs);
              function collapseResultsAndFinish() {
                var results = [];
                perDocResults.forEach(function (res) {
                  res.docs.forEach(function (info) {
                    results.push({
                      id: res.id,
                      docs: [info]
                    });
                  });
                });
                callback(null, { results: results });
              }
              function checkDone() {
                if (++numDone === numDocs) {
                  collapseResultsAndFinish();
                }
              }
              function gotResult(docIndex, id, docs) {
                perDocResults[docIndex] = {
                  id: id,
                  docs: docs
                };
                checkDone();
              }
              var allRequests = [];
              requestsById.forEach(function (value, key) {
                allRequests.push(key);
              });
              var i = 0;
              function nextBatch() {
                if (i >= allRequests.length) {
                  return;
                }
                var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);
                var batch = allRequests.slice(i, upTo);
                processBatch(batch, i);
                i += batch.length;
              }
              function processBatch(batch, offset) {
                batch.forEach(function (docId, j) {
                  var docIdx = offset + j;
                  var docRequests = requestsById.get(docId);
                  var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);
                  docOpts.open_revs = docRequests.map(function (request) {
                    return request.rev;
                  });
                  docOpts.open_revs = docOpts.open_revs.filter(identityFunction);
                  var formatResult = identityFunction;
                  if (docOpts.open_revs.length === 0) {
                    delete docOpts.open_revs;
                    formatResult = formatResultForOpenRevsGet;
                  }
                  ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {
                    if (param in opts) {
                      docOpts[param] = opts[param];
                    }
                  });
                  db.get(docId, docOpts, function (err, res) {
                    var result;
                    if (err) {
                      result = [{ error: err }];
                    } else {
                      result = formatResult(res);
                    }
                    gotResult(docIdx, docId, result);
                    nextBatch();
                  });
                });
              }
              nextBatch();
            }
            function isChromeApp() {
              return typeof chrome !== "undefined" && typeof chrome.storage !== "undefined" && typeof chrome.storage.local !== "undefined";
            }
            var hasLocal;
            if (isChromeApp()) {
              hasLocal = false;
            } else {
              try {
                localStorage.setItem('_pouch_check_localstorage', 1);
                hasLocal = !!localStorage.getItem('_pouch_check_localstorage');
              } catch (e) {
                hasLocal = false;
              }
            }
            function hasLocalStorage() {
              return hasLocal;
            }
            inherits(Changes, events.EventEmitter);
            function attachBrowserEvents(self) {
              if (isChromeApp()) {
                chrome.storage.onChanged.addListener(function (e) {
                  if (e.db_name != null) {
                    self.emit(e.dbName.newValue);
                  }
                });
              } else if (hasLocalStorage()) {
                if (typeof addEventListener !== 'undefined') {
                  addEventListener("storage", function (e) {
                    self.emit(e.key);
                  });
                } else {
                  window.attachEvent("storage", function (e) {
                    self.emit(e.key);
                  });
                }
              }
            }
            function Changes() {
              events.EventEmitter.call(this);
              this._listeners = {};
              attachBrowserEvents(this);
            }
            Changes.prototype.addListener = function (dbName, id, db, opts) {
              if (this._listeners[id]) {
                return;
              }
              var self = this;
              var inprogress = false;
              function eventFunction() {
                if (!self._listeners[id]) {
                  return;
                }
                if (inprogress) {
                  inprogress = 'waiting';
                  return;
                }
                inprogress = true;
                var changesOpts = pick(opts, ['style', 'include_docs', 'attachments', 'conflicts', 'filter', 'doc_ids', 'view', 'since', 'query_params', 'binary']);
                function onError() {
                  inprogress = false;
                }
                db.changes(changesOpts).on('change', function (c) {
                  if (c.seq > opts.since && !opts.cancelled) {
                    opts.since = c.seq;
                    opts.onChange(c);
                  }
                }).on('complete', function () {
                  if (inprogress === 'waiting') {
                    nextTick(eventFunction);
                  }
                  inprogress = false;
                }).on('error', onError);
              }
              this._listeners[id] = eventFunction;
              this.on(dbName, eventFunction);
            };
            Changes.prototype.removeListener = function (dbName, id) {
              if (!(id in this._listeners)) {
                return;
              }
              events.EventEmitter.prototype.removeListener.call(this, dbName, this._listeners[id]);
              delete this._listeners[id];
            };
            Changes.prototype.notifyLocalWindows = function (dbName) {
              if (isChromeApp()) {
                chrome.storage.local.set({ dbName: dbName });
              } else if (hasLocalStorage()) {
                localStorage[dbName] = localStorage[dbName] === "a" ? "b" : "a";
              }
            };
            Changes.prototype.notify = function (dbName) {
              this.emit(dbName);
              this.notifyLocalWindows(dbName);
            };
            function guardedConsole(method) {
              if (console !== 'undefined' && method in console) {
                var args = Array.prototype.slice.call(arguments, 1);
                console[method].apply(console, args);
              }
            }
            function randomNumber(min, max) {
              var maxTimeout = 600000;
              min = parseInt(min, 10) || 0;
              max = parseInt(max, 10);
              if (max !== max || max <= min) {
                max = (min || 1) << 1;
              } else {
                max = max + 1;
              }
              if (max > maxTimeout) {
                min = maxTimeout >> 1;
                max = maxTimeout;
              }
              var ratio = Math.random();
              var range = max - min;
              return ~~(range * ratio + min);
            }
            function defaultBackOff(min) {
              var max = 0;
              if (!min) {
                max = 2000;
              }
              return randomNumber(min, max);
            }
            function explainError(status, str) {
              guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);
            }
            var assign;
            {
              if (typeof Object.assign === 'function') {
                assign = Object.assign;
              } else {
                assign = function (target) {
                  var to = Object(target);
                  for (var index = 1; index < arguments.length; index++) {
                    var nextSource = arguments[index];
                    if (nextSource != null) {
                      for (var nextKey in nextSource) {
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                          to[nextKey] = nextSource[nextKey];
                        }
                      }
                    }
                  }
                  return to;
                };
              }
            }
            var $inject_Object_assign = assign;
            inherits(PouchError, Error);
            function PouchError(status, error, reason) {
              Error.call(this, reason);
              this.status = status;
              this.name = error;
              this.message = reason;
              this.error = true;
            }
            PouchError.prototype.toString = function () {
              return JSON.stringify({
                status: this.status,
                name: this.name,
                message: this.message,
                reason: this.reason
              });
            };
            var UNAUTHORIZED = new PouchError(401, 'unauthorized', "Name or password is incorrect.");
            var MISSING_BULK_DOCS = new PouchError(400, 'bad_request', "Missing JSON list of 'docs'");
            var MISSING_DOC = new PouchError(404, 'not_found', 'missing');
            var REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');
            var INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');
            var MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');
            var RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');
            var NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');
            var UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');
            var BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');
            var INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');
            var QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');
            var DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');
            var BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');
            var NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');
            var DB_MISSING = new PouchError(404, 'not_found', 'Database not found');
            var IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');
            var WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');
            var LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');
            var FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');
            var INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');
            var FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');
            var MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\'t found');
            var INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');
            function createError(error, reason) {
              function CustomPouchError(reason) {
                for (var p in error) {
                  if (typeof error[p] !== 'function') {
                    this[p] = error[p];
                  }
                }
                if (reason !== undefined) {
                  this.reason = reason;
                }
              }
              CustomPouchError.prototype = PouchError.prototype;
              return new CustomPouchError(reason);
            }
            function generateErrorFromResponse(err) {
              if (typeof err !== 'object') {
                var data = err;
                err = UNKNOWN_ERROR;
                err.data = data;
              }
              if ('error' in err && err.error === 'conflict') {
                err.name = 'conflict';
                err.status = 409;
              }
              if (!('name' in err)) {
                err.name = err.error || 'unknown';
              }
              if (!('status' in err)) {
                err.status = 500;
              }
              if (!('message' in err)) {
                err.message = err.message || err.reason;
              }
              return err;
            }
            function tryFilter(filter, doc, req) {
              try {
                return !filter(doc, req);
              } catch (err) {
                var msg = 'Filter function threw: ' + err.toString();
                return createError(BAD_REQUEST, msg);
              }
            }
            function filterChange(opts) {
              var req = {};
              var hasFilter = opts.filter && typeof opts.filter === 'function';
              req.query = opts.query_params;
              return function filter(change) {
                if (!change.doc) {
                  change.doc = {};
                }
                var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);
                if (typeof filterReturn === 'object') {
                  return filterReturn;
                }
                if (filterReturn) {
                  return false;
                }
                if (!opts.include_docs) {
                  delete change.doc;
                } else if (!opts.attachments) {
                  for (var att in change.doc._attachments) {
                    if (change.doc._attachments.hasOwnProperty(att)) {
                      change.doc._attachments[att].stub = true;
                    }
                  }
                }
                return true;
              };
            }
            function flatten(arrs) {
              var res = [];
              for (var i = 0, len = arrs.length; i < len; i++) {
                res = res.concat(arrs[i]);
              }
              return res;
            }
            function f() {}
            var hasName = f.name;
            var res;
            if (hasName) {
              res = function (fun) {
                return fun.name;
              };
            } else {
              res = function (fun) {
                return fun.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
              };
            }
            function invalidIdError(id) {
              var err;
              if (!id) {
                err = createError(MISSING_ID);
              } else if (typeof id !== 'string') {
                err = createError(INVALID_ID);
              } else if (/^_/.test(id) && !/^_(design|local)/.test(id)) {
                err = createError(RESERVED_ID);
              }
              if (err) {
                throw err;
              }
            }
            function isRemote(db) {
              if (typeof db._remote === 'boolean') {
                return db._remote;
              }
              if (typeof db.type === 'function') {
                guardedConsole('warn', 'db.type() is deprecated and will be removed in ' + 'a future version of PouchDB');
                return db.type() === 'http';
              }
              return false;
            }
            function listenerCount(ee, type) {
              return 'listenerCount' in ee ? ee.listenerCount(type) : events.EventEmitter.listenerCount(ee, type);
            }
            function parseDesignDocFunctionName(s) {
              if (!s) {
                return null;
              }
              var parts = s.split('/');
              if (parts.length === 2) {
                return parts;
              }
              if (parts.length === 1) {
                return [s, s];
              }
              return null;
            }
            function normalizeDesignDocFunctionName(s) {
              var normalized = parseDesignDocFunctionName(s);
              return normalized ? normalized.join('/') : null;
            }
            var keys = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
            var qName = "queryKey";
            var qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;
            var parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
            function parseUri(str) {
              var m = parser.exec(str);
              var uri = {};
              var i = 14;
              while (i--) {
                var key = keys[i];
                var value = m[i] || "";
                var encoded = ['user', 'password'].indexOf(key) !== -1;
                uri[key] = encoded ? decodeURIComponent(value) : value;
              }
              uri[qName] = {};
              uri[keys[12]].replace(qParser, function ($0, $1, $2) {
                if ($1) {
                  uri[qName][$1] = $2;
                }
              });
              return uri;
            }
            function scopeEval(source, scope) {
              var keys = [];
              var values = [];
              for (var key in scope) {
                if (scope.hasOwnProperty(key)) {
                  keys.push(key);
                  values.push(scope[key]);
                }
              }
              keys.push(source);
              return Function.apply(null, keys).apply(null, values);
            }
            function upsert(db, docId, diffFun) {
              return new PouchPromise$1(function (fulfill, reject) {
                db.get(docId, function (err, doc) {
                  if (err) {
                    if (err.status !== 404) {
                      return reject(err);
                    }
                    doc = {};
                  }
                  var docRev = doc._rev;
                  var newDoc = diffFun(doc);
                  if (!newDoc) {
                    return fulfill({
                      updated: false,
                      rev: docRev
                    });
                  }
                  newDoc._id = docId;
                  newDoc._rev = docRev;
                  fulfill(tryAndPut(db, newDoc, diffFun));
                });
              });
            }
            function tryAndPut(db, doc, diffFun) {
              return db.put(doc).then(function (res) {
                return {
                  updated: true,
                  rev: res.rev
                };
              }, function (err) {
                if (err.status !== 409) {
                  throw err;
                }
                return upsert(db, doc._id, diffFun);
              });
            }
            function rev() {
              return v4().replace(/-/g, '').toLowerCase();
            }
            var uuid = v4;
            function winningRev(metadata) {
              var winningId;
              var winningPos;
              var winningDeleted;
              var toVisit = metadata.rev_tree.slice();
              var node;
              while (node = toVisit.pop()) {
                var tree = node.ids;
                var branches = tree[2];
                var pos = node.pos;
                if (branches.length) {
                  for (var i = 0, len = branches.length; i < len; i++) {
                    toVisit.push({
                      pos: pos + 1,
                      ids: branches[i]
                    });
                  }
                  continue;
                }
                var deleted = !!tree[1].deleted;
                var id = tree[0];
                if (!winningId || (winningDeleted !== deleted ? winningDeleted : winningPos !== pos ? winningPos < pos : winningId < id)) {
                  winningId = id;
                  winningPos = pos;
                  winningDeleted = deleted;
                }
              }
              return winningPos + '-' + winningId;
            }
            function traverseRevTree(revs, callback) {
              var toVisit = revs.slice();
              var node;
              while (node = toVisit.pop()) {
                var pos = node.pos;
                var tree = node.ids;
                var branches = tree[2];
                var newCtx = callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);
                for (var i = 0, len = branches.length; i < len; i++) {
                  toVisit.push({
                    pos: pos + 1,
                    ids: branches[i],
                    ctx: newCtx
                  });
                }
              }
            }
            function sortByPos(a, b) {
              return a.pos - b.pos;
            }
            function collectLeaves(revs) {
              var leaves = [];
              traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {
                if (isLeaf) {
                  leaves.push({
                    rev: pos + "-" + id,
                    pos: pos,
                    opts: opts
                  });
                }
              });
              leaves.sort(sortByPos).reverse();
              for (var i = 0, len = leaves.length; i < len; i++) {
                delete leaves[i].pos;
              }
              return leaves;
            }
            function collectConflicts(metadata) {
              var win = winningRev(metadata);
              var leaves = collectLeaves(metadata.rev_tree);
              var conflicts = [];
              for (var i = 0, len = leaves.length; i < len; i++) {
                var leaf = leaves[i];
                if (leaf.rev !== win && !leaf.opts.deleted) {
                  conflicts.push(leaf.rev);
                }
              }
              return conflicts;
            }
            function compactTree(metadata) {
              var revs = [];
              traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {
                if (opts.status === 'available' && !isLeaf) {
                  revs.push(pos + '-' + revHash);
                  opts.status = 'missing';
                }
              });
              return revs;
            }
            function rootToLeaf(revs) {
              var paths = [];
              var toVisit = revs.slice();
              var node;
              while (node = toVisit.pop()) {
                var pos = node.pos;
                var tree = node.ids;
                var id = tree[0];
                var opts = tree[1];
                var branches = tree[2];
                var isLeaf = branches.length === 0;
                var history = node.history ? node.history.slice() : [];
                history.push({
                  id: id,
                  opts: opts
                });
                if (isLeaf) {
                  paths.push({
                    pos: pos + 1 - history.length,
                    ids: history
                  });
                }
                for (var i = 0, len = branches.length; i < len; i++) {
                  toVisit.push({
                    pos: pos + 1,
                    ids: branches[i],
                    history: history
                  });
                }
              }
              return paths.reverse();
            }
            function sortByPos$1(a, b) {
              return a.pos - b.pos;
            }
            function binarySearch(arr, item, comparator) {
              var low = 0;
              var high = arr.length;
              var mid;
              while (low < high) {
                mid = low + high >>> 1;
                if (comparator(arr[mid], item) < 0) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return low;
            }
            function insertSorted(arr, item, comparator) {
              var idx = binarySearch(arr, item, comparator);
              arr.splice(idx, 0, item);
            }
            function pathToTree(path, numStemmed) {
              var root;
              var leaf;
              for (var i = numStemmed, len = path.length; i < len; i++) {
                var node = path[i];
                var currentLeaf = [node.id, node.opts, []];
                if (leaf) {
                  leaf[2].push(currentLeaf);
                  leaf = currentLeaf;
                } else {
                  root = leaf = currentLeaf;
                }
              }
              return root;
            }
            function compareTree(a, b) {
              return a[0] < b[0] ? -1 : 1;
            }
            function mergeTree(in_tree1, in_tree2) {
              var queue = [{
                tree1: in_tree1,
                tree2: in_tree2
              }];
              var conflicts = false;
              while (queue.length > 0) {
                var item = queue.pop();
                var tree1 = item.tree1;
                var tree2 = item.tree2;
                if (tree1[1].status || tree2[1].status) {
                  tree1[1].status = tree1[1].status === 'available' || tree2[1].status === 'available' ? 'available' : 'missing';
                }
                for (var i = 0; i < tree2[2].length; i++) {
                  if (!tree1[2][0]) {
                    conflicts = 'new_leaf';
                    tree1[2][0] = tree2[2][i];
                    continue;
                  }
                  var merged = false;
                  for (var j = 0; j < tree1[2].length; j++) {
                    if (tree1[2][j][0] === tree2[2][i][0]) {
                      queue.push({
                        tree1: tree1[2][j],
                        tree2: tree2[2][i]
                      });
                      merged = true;
                    }
                  }
                  if (!merged) {
                    conflicts = 'new_branch';
                    insertSorted(tree1[2], tree2[2][i], compareTree);
                  }
                }
              }
              return {
                conflicts: conflicts,
                tree: in_tree1
              };
            }
            function doMerge(tree, path, dontExpand) {
              var restree = [];
              var conflicts = false;
              var merged = false;
              var res;
              if (!tree.length) {
                return {
                  tree: [path],
                  conflicts: 'new_leaf'
                };
              }
              for (var i = 0, len = tree.length; i < len; i++) {
                var branch = tree[i];
                if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {
                  res = mergeTree(branch.ids, path.ids);
                  restree.push({
                    pos: branch.pos,
                    ids: res.tree
                  });
                  conflicts = conflicts || res.conflicts;
                  merged = true;
                } else if (dontExpand !== true) {
                  var t1 = branch.pos < path.pos ? branch : path;
                  var t2 = branch.pos < path.pos ? path : branch;
                  var diff = t2.pos - t1.pos;
                  var candidateParents = [];
                  var trees = [];
                  trees.push({
                    ids: t1.ids,
                    diff: diff,
                    parent: null,
                    parentIdx: null
                  });
                  while (trees.length > 0) {
                    var item = trees.pop();
                    if (item.diff === 0) {
                      if (item.ids[0] === t2.ids[0]) {
                        candidateParents.push(item);
                      }
                      continue;
                    }
                    var elements = item.ids[2];
                    for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {
                      trees.push({
                        ids: elements[j],
                        diff: item.diff - 1,
                        parent: item.ids,
                        parentIdx: j
                      });
                    }
                  }
                  var el = candidateParents[0];
                  if (!el) {
                    restree.push(branch);
                  } else {
                    res = mergeTree(el.ids, t2.ids);
                    el.parent[2][el.parentIdx] = res.tree;
                    restree.push({
                      pos: t1.pos,
                      ids: t1.ids
                    });
                    conflicts = conflicts || res.conflicts;
                    merged = true;
                  }
                } else {
                  restree.push(branch);
                }
              }
              if (!merged) {
                restree.push(path);
              }
              restree.sort(sortByPos$1);
              return {
                tree: restree,
                conflicts: conflicts || 'internal_node'
              };
            }
            function stem(tree, depth) {
              var paths = rootToLeaf(tree);
              var stemmedRevs;
              var result;
              for (var i = 0, len = paths.length; i < len; i++) {
                var path = paths[i];
                var stemmed = path.ids;
                var node;
                if (stemmed.length > depth) {
                  if (!stemmedRevs) {
                    stemmedRevs = {};
                  }
                  var numStemmed = stemmed.length - depth;
                  node = {
                    pos: path.pos + numStemmed,
                    ids: pathToTree(stemmed, numStemmed)
                  };
                  for (var s = 0; s < numStemmed; s++) {
                    var rev = path.pos + s + '-' + stemmed[s].id;
                    stemmedRevs[rev] = true;
                  }
                } else {
                  node = {
                    pos: path.pos,
                    ids: pathToTree(stemmed, 0)
                  };
                }
                if (result) {
                  result = doMerge(result, node, true).tree;
                } else {
                  result = [node];
                }
              }
              if (stemmedRevs) {
                traverseRevTree(result, function (isLeaf, pos, revHash) {
                  delete stemmedRevs[pos + '-' + revHash];
                });
              }
              return {
                tree: result,
                revs: stemmedRevs ? Object.keys(stemmedRevs) : []
              };
            }
            function merge(tree, path, depth) {
              var newTree = doMerge(tree, path);
              var stemmed = stem(newTree.tree, depth);
              return {
                tree: stemmed.tree,
                stemmedRevs: stemmed.revs,
                conflicts: newTree.conflicts
              };
            }
            function revExists(revs, rev) {
              var toVisit = revs.slice();
              var splitRev = rev.split('-');
              var targetPos = parseInt(splitRev[0], 10);
              var targetId = splitRev[1];
              var node;
              while (node = toVisit.pop()) {
                if (node.pos === targetPos && node.ids[0] === targetId) {
                  return true;
                }
                var branches = node.ids[2];
                for (var i = 0, len = branches.length; i < len; i++) {
                  toVisit.push({
                    pos: node.pos + 1,
                    ids: branches[i]
                  });
                }
              }
              return false;
            }
            function getTrees(node) {
              return node.ids;
            }
            function isDeleted(metadata, rev) {
              if (!rev) {
                rev = winningRev(metadata);
              }
              var id = rev.substring(rev.indexOf('-') + 1);
              var toVisit = metadata.rev_tree.map(getTrees);
              var tree;
              while (tree = toVisit.pop()) {
                if (tree[0] === id) {
                  return !!tree[1].deleted;
                }
                toVisit = toVisit.concat(tree[2]);
              }
            }
            function isLocalId(id) {
              return (/^_local/.test(id)
              );
            }
            function latest(rev, metadata) {
              var toVisit = metadata.rev_tree.slice();
              var node;
              while (node = toVisit.pop()) {
                var pos = node.pos;
                var tree = node.ids;
                var id = tree[0];
                var opts = tree[1];
                var branches = tree[2];
                var isLeaf = branches.length === 0;
                var history = node.history ? node.history.slice() : [];
                history.push({
                  id: id,
                  pos: pos,
                  opts: opts
                });
                if (isLeaf) {
                  for (var i = 0, len = history.length; i < len; i++) {
                    var historyNode = history[i];
                    var historyRev = historyNode.pos + '-' + historyNode.id;
                    if (historyRev === rev) {
                      return pos + '-' + id;
                    }
                  }
                }
                for (var j = 0, l = branches.length; j < l; j++) {
                  toVisit.push({
                    pos: pos + 1,
                    ids: branches[j],
                    history: history
                  });
                }
              }
              throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);
            }
            inherits(Changes$2, events.EventEmitter);
            function tryCatchInChangeListener(self, change) {
              try {
                self.emit('change', change);
              } catch (e) {
                guardedConsole('error', 'Error in .on("change", function):', e);
              }
            }
            function Changes$2(db, opts, callback) {
              events.EventEmitter.call(this);
              var self = this;
              this.db = db;
              opts = opts ? clone(opts) : {};
              var complete = opts.complete = once(function (err, resp) {
                if (err) {
                  if (listenerCount(self, 'error') > 0) {
                    self.emit('error', err);
                  }
                } else {
                  self.emit('complete', resp);
                }
                self.removeAllListeners();
                db.removeListener('destroyed', onDestroy);
              });
              if (callback) {
                self.on('complete', function (resp) {
                  callback(null, resp);
                });
                self.on('error', callback);
              }
              function onDestroy() {
                self.cancel();
              }
              db.once('destroyed', onDestroy);
              opts.onChange = function (change) {
                if (self.isCancelled) {
                  return;
                }
                tryCatchInChangeListener(self, change);
              };
              var promise = new PouchPromise$1(function (fulfill, reject) {
                opts.complete = function (err, res) {
                  if (err) {
                    reject(err);
                  } else {
                    fulfill(res);
                  }
                };
              });
              self.once('cancel', function () {
                db.removeListener('destroyed', onDestroy);
                opts.complete(null, { status: 'cancelled' });
              });
              this.then = promise.then.bind(promise);
              this['catch'] = promise['catch'].bind(promise);
              this.then(function (result) {
                complete(null, result);
              }, complete);
              if (!db.taskqueue.isReady) {
                db.taskqueue.addTask(function (failed) {
                  if (failed) {
                    opts.complete(failed);
                  } else if (self.isCancelled) {
                    self.emit('cancel');
                  } else {
                    self.validateChanges(opts);
                  }
                });
              } else {
                self.validateChanges(opts);
              }
            }
            Changes$2.prototype.cancel = function () {
              this.isCancelled = true;
              if (this.db.taskqueue.isReady) {
                this.emit('cancel');
              }
            };
            function processChange(doc, metadata, opts) {
              var changeList = [{ rev: doc._rev }];
              if (opts.style === 'all_docs') {
                changeList = collectLeaves(metadata.rev_tree).map(function (x) {
                  return { rev: x.rev };
                });
              }
              var change = {
                id: metadata.id,
                changes: changeList,
                doc: doc
              };
              if (isDeleted(metadata, doc._rev)) {
                change.deleted = true;
              }
              if (opts.conflicts) {
                change.doc._conflicts = collectConflicts(metadata);
                if (!change.doc._conflicts.length) {
                  delete change.doc._conflicts;
                }
              }
              return change;
            }
            Changes$2.prototype.validateChanges = function (opts) {
              var callback = opts.complete;
              var self = this;
              if (PouchDB$5._changesFilterPlugin) {
                PouchDB$5._changesFilterPlugin.validate(opts, function (err) {
                  if (err) {
                    return callback(err);
                  }
                  self.doChanges(opts);
                });
              } else {
                self.doChanges(opts);
              }
            };
            Changes$2.prototype.doChanges = function (opts) {
              var self = this;
              var callback = opts.complete;
              opts = clone(opts);
              if ('live' in opts && !('continuous' in opts)) {
                opts.continuous = opts.live;
              }
              opts.processChange = processChange;
              if (opts.since === 'latest') {
                opts.since = 'now';
              }
              if (!opts.since) {
                opts.since = 0;
              }
              if (opts.since === 'now') {
                this.db.info().then(function (info) {
                  if (self.isCancelled) {
                    callback(null, { status: 'cancelled' });
                    return;
                  }
                  opts.since = info.update_seq;
                  self.doChanges(opts);
                }, callback);
                return;
              }
              if (PouchDB$5._changesFilterPlugin) {
                PouchDB$5._changesFilterPlugin.normalize(opts);
                if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {
                  return PouchDB$5._changesFilterPlugin.filter(this, opts);
                }
              } else {
                ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {
                  if (key in opts) {
                    guardedConsole('warn', 'The "' + key + '" option was passed in to changes/replicate, ' + 'but pouchdb-changes-filter plugin is not installed, so it ' + 'was ignored. Please install the plugin to enable filtering.');
                  }
                });
              }
              if (!('descending' in opts)) {
                opts.descending = false;
              }
              opts.limit = opts.limit === 0 ? 1 : opts.limit;
              opts.complete = callback;
              var newPromise = this.db._changes(opts);
              if (newPromise && typeof newPromise.cancel === 'function') {
                var cancel = self.cancel;
                self.cancel = getArguments(function (args) {
                  newPromise.cancel();
                  cancel.apply(this, args);
                });
              }
            };
            function compare(left, right) {
              return left < right ? -1 : left > right ? 1 : 0;
            }
            function yankError(callback, docId) {
              return function (err, results) {
                if (err || results[0] && results[0].error) {
                  err = err || results[0];
                  err.docId = docId;
                  callback(err);
                } else {
                  callback(null, results.length ? results[0] : results);
                }
              };
            }
            function cleanDocs(docs) {
              for (var i = 0; i < docs.length; i++) {
                var doc = docs[i];
                if (doc._deleted) {
                  delete doc._attachments;
                } else if (doc._attachments) {
                  var atts = Object.keys(doc._attachments);
                  for (var j = 0; j < atts.length; j++) {
                    var att = atts[j];
                    doc._attachments[att] = pick(doc._attachments[att], ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);
                  }
                }
              }
            }
            function compareByIdThenRev(a, b) {
              var idCompare = compare(a._id, b._id);
              if (idCompare !== 0) {
                return idCompare;
              }
              var aStart = a._revisions ? a._revisions.start : 0;
              var bStart = b._revisions ? b._revisions.start : 0;
              return compare(aStart, bStart);
            }
            function computeHeight(revs) {
              var height = {};
              var edges = [];
              traverseRevTree(revs, function (isLeaf, pos, id, prnt) {
                var rev$$1 = pos + "-" + id;
                if (isLeaf) {
                  height[rev$$1] = 0;
                }
                if (prnt !== undefined) {
                  edges.push({
                    from: prnt,
                    to: rev$$1
                  });
                }
                return rev$$1;
              });
              edges.reverse();
              edges.forEach(function (edge) {
                if (height[edge.from] === undefined) {
                  height[edge.from] = 1 + height[edge.to];
                } else {
                  height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);
                }
              });
              return height;
            }
            function allDocsKeysQuery(api, opts, callback) {
              var keys = 'limit' in opts ? opts.keys.slice(opts.skip, opts.limit + opts.skip) : opts.skip > 0 ? opts.keys.slice(opts.skip) : opts.keys;
              if (opts.descending) {
                keys.reverse();
              }
              if (!keys.length) {
                return api._allDocs({ limit: 0 }, callback);
              }
              var finalResults = { offset: opts.skip };
              return PouchPromise$1.all(keys.map(function (key) {
                var subOpts = $inject_Object_assign({
                  key: key,
                  deleted: 'ok'
                }, opts);
                ['limit', 'skip', 'keys'].forEach(function (optKey) {
                  delete subOpts[optKey];
                });
                return new PouchPromise$1(function (resolve, reject) {
                  api._allDocs(subOpts, function (err, res) {
                    if (err) {
                      return reject(err);
                    }
                    finalResults.total_rows = res.total_rows;
                    resolve(res.rows[0] || {
                      key: key,
                      error: 'not_found'
                    });
                  });
                });
              })).then(function (results) {
                finalResults.rows = results;
                return finalResults;
              });
            }
            function doNextCompaction(self) {
              var task = self._compactionQueue[0];
              var opts = task.opts;
              var callback = task.callback;
              self.get('_local/compaction')["catch"](function () {
                return false;
              }).then(function (doc) {
                if (doc && doc.last_seq) {
                  opts.last_seq = doc.last_seq;
                }
                self._compact(opts, function (err, res) {
                  if (err) {
                    callback(err);
                  } else {
                    callback(null, res);
                  }
                  nextTick(function () {
                    self._compactionQueue.shift();
                    if (self._compactionQueue.length) {
                      doNextCompaction(self);
                    }
                  });
                });
              });
            }
            function attachmentNameError(name) {
              if (name.charAt(0) === '_') {
                return name + ' is not a valid attachment name, attachment ' + 'names cannot start with \'_\'';
              }
              return false;
            }
            inherits(AbstractPouchDB, events.EventEmitter);
            function AbstractPouchDB() {
              events.EventEmitter.call(this);
            }
            AbstractPouchDB.prototype.post = adapterFun('post', function (doc, opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              if (typeof doc !== 'object' || Array.isArray(doc)) {
                return callback(createError(NOT_AN_OBJECT));
              }
              this.bulkDocs({ docs: [doc] }, opts, yankError(callback, doc._id));
            });
            AbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {
              if (typeof opts === 'function') {
                cb = opts;
                opts = {};
              }
              if (typeof doc !== 'object' || Array.isArray(doc)) {
                return cb(createError(NOT_AN_OBJECT));
              }
              invalidIdError(doc._id);
              if (isLocalId(doc._id) && typeof this._putLocal === 'function') {
                if (doc._deleted) {
                  return this._removeLocal(doc, cb);
                } else {
                  return this._putLocal(doc, cb);
                }
              }
              var self = this;
              if (opts.force && doc._rev) {
                transformForceOptionToNewEditsOption();
                putDoc(function (err) {
                  var result = err ? null : {
                    ok: true,
                    id: doc._id,
                    rev: doc._rev
                  };
                  cb(err, result);
                });
              } else {
                putDoc(cb);
              }
              function transformForceOptionToNewEditsOption() {
                var parts = doc._rev.split('-');
                var oldRevId = parts[1];
                var oldRevNum = parseInt(parts[0], 10);
                var newRevNum = oldRevNum + 1;
                var newRevId = rev();
                doc._revisions = {
                  start: newRevNum,
                  ids: [newRevId, oldRevId]
                };
                doc._rev = newRevNum + '-' + newRevId;
                opts.new_edits = false;
              }
              function putDoc(next) {
                if (typeof self._put === 'function' && opts.new_edits !== false) {
                  self._put(doc, opts, next);
                } else {
                  self.bulkDocs({ docs: [doc] }, opts, yankError(next, doc._id));
                }
              }
            });
            AbstractPouchDB.prototype.putAttachment = adapterFun('putAttachment', function (docId, attachmentId, rev$$1, blob, type) {
              var api = this;
              if (typeof type === 'function') {
                type = blob;
                blob = rev$$1;
                rev$$1 = null;
              }
              if (typeof type === 'undefined') {
                type = blob;
                blob = rev$$1;
                rev$$1 = null;
              }
              if (!type) {
                guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');
              }
              function createAttachment(doc) {
                var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;
                doc._attachments = doc._attachments || {};
                doc._attachments[attachmentId] = {
                  content_type: type,
                  data: blob,
                  revpos: ++prevrevpos
                };
                return api.put(doc);
              }
              return api.get(docId).then(function (doc) {
                if (doc._rev !== rev$$1) {
                  throw createError(REV_CONFLICT);
                }
                return createAttachment(doc);
              }, function (err) {
                if (err.reason === MISSING_DOC.message) {
                  return createAttachment({ _id: docId });
                } else {
                  throw err;
                }
              });
            });
            AbstractPouchDB.prototype.removeAttachment = adapterFun('removeAttachment', function (docId, attachmentId, rev$$1, callback) {
              var self = this;
              self.get(docId, function (err, obj) {
                if (err) {
                  callback(err);
                  return;
                }
                if (obj._rev !== rev$$1) {
                  callback(createError(REV_CONFLICT));
                  return;
                }
                if (!obj._attachments) {
                  return callback();
                }
                delete obj._attachments[attachmentId];
                if (Object.keys(obj._attachments).length === 0) {
                  delete obj._attachments;
                }
                self.put(obj, callback);
              });
            });
            AbstractPouchDB.prototype.remove = adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {
              var doc;
              if (typeof optsOrRev === 'string') {
                doc = {
                  _id: docOrId,
                  _rev: optsOrRev
                };
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
              } else {
                doc = docOrId;
                if (typeof optsOrRev === 'function') {
                  callback = optsOrRev;
                  opts = {};
                } else {
                  callback = opts;
                  opts = optsOrRev;
                }
              }
              opts = opts || {};
              opts.was_delete = true;
              var newDoc = {
                _id: doc._id,
                _rev: doc._rev || opts.rev
              };
              newDoc._deleted = true;
              if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {
                return this._removeLocal(doc, callback);
              }
              this.bulkDocs({ docs: [newDoc] }, opts, yankError(callback, newDoc._id));
            });
            AbstractPouchDB.prototype.revsDiff = adapterFun('revsDiff', function (req, opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              var ids = Object.keys(req);
              if (!ids.length) {
                return callback(null, {});
              }
              var count = 0;
              var missing = new ExportedMap();
              function addToMissing(id, revId) {
                if (!missing.has(id)) {
                  missing.set(id, { missing: [] });
                }
                missing.get(id).missing.push(revId);
              }
              function processDoc(id, rev_tree) {
                var missingForId = req[id].slice(0);
                traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx, opts) {
                  var rev$$1 = pos + '-' + revHash;
                  var idx = missingForId.indexOf(rev$$1);
                  if (idx === -1) {
                    return;
                  }
                  missingForId.splice(idx, 1);
                  if (opts.status !== 'available') {
                    addToMissing(id, rev$$1);
                  }
                });
                missingForId.forEach(function (rev$$1) {
                  addToMissing(id, rev$$1);
                });
              }
              ids.map(function (id) {
                this._getRevisionTree(id, function (err, rev_tree) {
                  if (err && err.status === 404 && err.message === 'missing') {
                    missing.set(id, { missing: req[id] });
                  } else if (err) {
                    return callback(err);
                  } else {
                    processDoc(id, rev_tree);
                  }
                  if (++count === ids.length) {
                    var missingObj = {};
                    missing.forEach(function (value, key) {
                      missingObj[key] = value;
                    });
                    return callback(null, missingObj);
                  }
                });
              }, this);
            });
            AbstractPouchDB.prototype.bulkGet = adapterFun('bulkGet', function (opts, callback) {
              bulkGet(this, opts, callback);
            });
            AbstractPouchDB.prototype.compactDocument = adapterFun('compactDocument', function (docId, maxHeight, callback) {
              var self = this;
              this._getRevisionTree(docId, function (err, revTree) {
                if (err) {
                  return callback(err);
                }
                var height = computeHeight(revTree);
                var candidates = [];
                var revs = [];
                Object.keys(height).forEach(function (rev$$1) {
                  if (height[rev$$1] > maxHeight) {
                    candidates.push(rev$$1);
                  }
                });
                traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {
                  var rev$$1 = pos + '-' + revHash;
                  if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {
                    revs.push(rev$$1);
                  }
                });
                self._doCompaction(docId, revs, callback);
              });
            });
            AbstractPouchDB.prototype.compact = adapterFun('compact', function (opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              var self = this;
              opts = opts || {};
              self._compactionQueue = self._compactionQueue || [];
              self._compactionQueue.push({
                opts: opts,
                callback: callback
              });
              if (self._compactionQueue.length === 1) {
                doNextCompaction(self);
              }
            });
            AbstractPouchDB.prototype._compact = function (opts, callback) {
              var self = this;
              var changesOpts = {
                return_docs: false,
                last_seq: opts.last_seq || 0
              };
              var promises = [];
              function onChange(row) {
                promises.push(self.compactDocument(row.id, 0));
              }
              function onComplete(resp) {
                var lastSeq = resp.last_seq;
                PouchPromise$1.all(promises).then(function () {
                  return upsert(self, '_local/compaction', function deltaFunc(doc) {
                    if (!doc.last_seq || doc.last_seq < lastSeq) {
                      doc.last_seq = lastSeq;
                      return doc;
                    }
                    return false;
                  });
                }).then(function () {
                  callback(null, { ok: true });
                })["catch"](callback);
              }
              self.changes(changesOpts).on('change', onChange).on('complete', onComplete).on('error', callback);
            };
            AbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {
              if (typeof opts === 'function') {
                cb = opts;
                opts = {};
              }
              if (typeof id !== 'string') {
                return cb(createError(INVALID_ID));
              }
              if (isLocalId(id) && typeof this._getLocal === 'function') {
                return this._getLocal(id, cb);
              }
              var leaves = [],
                  self = this;
              function finishOpenRevs() {
                var result = [];
                var count = leaves.length;
                if (!count) {
                  return cb(null, result);
                }
                leaves.forEach(function (leaf) {
                  self.get(id, {
                    rev: leaf,
                    revs: opts.revs,
                    latest: opts.latest,
                    attachments: opts.attachments
                  }, function (err, doc) {
                    if (!err) {
                      var existing;
                      for (var i = 0, l = result.length; i < l; i++) {
                        if (result[i].ok && result[i].ok._rev === doc._rev) {
                          existing = true;
                          break;
                        }
                      }
                      if (!existing) {
                        result.push({ ok: doc });
                      }
                    } else {
                      result.push({ missing: leaf });
                    }
                    count--;
                    if (!count) {
                      cb(null, result);
                    }
                  });
                });
              }
              if (opts.open_revs) {
                if (opts.open_revs === "all") {
                  this._getRevisionTree(id, function (err, rev_tree) {
                    if (err) {
                      return cb(err);
                    }
                    leaves = collectLeaves(rev_tree).map(function (leaf) {
                      return leaf.rev;
                    });
                    finishOpenRevs();
                  });
                } else {
                  if (Array.isArray(opts.open_revs)) {
                    leaves = opts.open_revs;
                    for (var i = 0; i < leaves.length; i++) {
                      var l = leaves[i];
                      if (!(typeof l === "string" && /^\d+-/.test(l))) {
                        return cb(createError(INVALID_REV));
                      }
                    }
                    finishOpenRevs();
                  } else {
                    return cb(createError(UNKNOWN_ERROR, 'function_clause'));
                  }
                }
                return;
              }
              return this._get(id, opts, function (err, result) {
                if (err) {
                  err.docId = id;
                  return cb(err);
                }
                var doc = result.doc;
                var metadata = result.metadata;
                var ctx = result.ctx;
                if (opts.conflicts) {
                  var conflicts = collectConflicts(metadata);
                  if (conflicts.length) {
                    doc._conflicts = conflicts;
                  }
                }
                if (isDeleted(metadata, doc._rev)) {
                  doc._deleted = true;
                }
                if (opts.revs || opts.revs_info) {
                  var splittedRev = doc._rev.split('-');
                  var revNo = parseInt(splittedRev[0], 10);
                  var revHash = splittedRev[1];
                  var paths = rootToLeaf(metadata.rev_tree);
                  var path = null;
                  for (var i = 0; i < paths.length; i++) {
                    var currentPath = paths[i];
                    var hashIndex = currentPath.ids.map(function (x) {
                      return x.id;
                    }).indexOf(revHash);
                    var hashFoundAtRevPos = hashIndex === revNo - 1;
                    if (hashFoundAtRevPos || !path && hashIndex !== -1) {
                      path = currentPath;
                    }
                  }
                  var indexOfRev = path.ids.map(function (x) {
                    return x.id;
                  }).indexOf(doc._rev.split('-')[1]) + 1;
                  var howMany = path.ids.length - indexOfRev;
                  path.ids.splice(indexOfRev, howMany);
                  path.ids.reverse();
                  if (opts.revs) {
                    doc._revisions = {
                      start: path.pos + path.ids.length - 1,
                      ids: path.ids.map(function (rev$$1) {
                        return rev$$1.id;
                      })
                    };
                  }
                  if (opts.revs_info) {
                    var pos = path.pos + path.ids.length;
                    doc._revs_info = path.ids.map(function (rev$$1) {
                      pos--;
                      return {
                        rev: pos + '-' + rev$$1.id,
                        status: rev$$1.opts.status
                      };
                    });
                  }
                }
                if (opts.attachments && doc._attachments) {
                  var attachments = doc._attachments;
                  var count = Object.keys(attachments).length;
                  if (count === 0) {
                    return cb(null, doc);
                  }
                  Object.keys(attachments).forEach(function (key) {
                    this._getAttachment(doc._id, key, attachments[key], {
                      rev: doc._rev,
                      binary: opts.binary,
                      ctx: ctx
                    }, function (err, data) {
                      var att = doc._attachments[key];
                      att.data = data;
                      delete att.stub;
                      delete att.length;
                      if (! --count) {
                        cb(null, doc);
                      }
                    });
                  }, self);
                } else {
                  if (doc._attachments) {
                    for (var key in doc._attachments) {
                      if (doc._attachments.hasOwnProperty(key)) {
                        doc._attachments[key].stub = true;
                      }
                    }
                  }
                  cb(null, doc);
                }
              });
            });
            AbstractPouchDB.prototype.getAttachment = adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {
              var self = this;
              if (opts instanceof Function) {
                callback = opts;
                opts = {};
              }
              this._get(docId, opts, function (err, res) {
                if (err) {
                  return callback(err);
                }
                if (res.doc._attachments && res.doc._attachments[attachmentId]) {
                  opts.ctx = res.ctx;
                  opts.binary = true;
                  self._getAttachment(docId, attachmentId, res.doc._attachments[attachmentId], opts, callback);
                } else {
                  return callback(createError(MISSING_DOC));
                }
              });
            });
            AbstractPouchDB.prototype.allDocs = adapterFun('allDocs', function (opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;
              if (opts.start_key) {
                opts.startkey = opts.start_key;
              }
              if (opts.end_key) {
                opts.endkey = opts.end_key;
              }
              if ('keys' in opts) {
                if (!Array.isArray(opts.keys)) {
                  return callback(new TypeError('options.keys must be an array'));
                }
                var incompatibleOpt = ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {
                  return incompatibleOpt in opts;
                })[0];
                if (incompatibleOpt) {
                  callback(createError(QUERY_PARSE_ERROR, 'Query parameter `' + incompatibleOpt + '` is not compatible with multi-get'));
                  return;
                }
                if (!isRemote(this)) {
                  return allDocsKeysQuery(this, opts, callback);
                }
              }
              return this._allDocs(opts, callback);
            });
            AbstractPouchDB.prototype.changes = function (opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              return new Changes$2(this, opts, callback);
            };
            AbstractPouchDB.prototype.close = adapterFun('close', function (callback) {
              this._closed = true;
              this.emit('closed');
              return this._close(callback);
            });
            AbstractPouchDB.prototype.info = adapterFun('info', function (callback) {
              var self = this;
              this._info(function (err, info) {
                if (err) {
                  return callback(err);
                }
                info.db_name = info.db_name || self.name;
                info.auto_compaction = !!(self.auto_compaction && !isRemote(self));
                info.adapter = self.adapter;
                callback(null, info);
              });
            });
            AbstractPouchDB.prototype.id = adapterFun('id', function (callback) {
              return this._id(callback);
            });
            AbstractPouchDB.prototype.type = function () {
              return typeof this._type === 'function' ? this._type() : this.adapter;
            };
            AbstractPouchDB.prototype.bulkDocs = adapterFun('bulkDocs', function (req, opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              opts = opts || {};
              if (Array.isArray(req)) {
                req = { docs: req };
              }
              if (!req || !req.docs || !Array.isArray(req.docs)) {
                return callback(createError(MISSING_BULK_DOCS));
              }
              for (var i = 0; i < req.docs.length; ++i) {
                if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {
                  return callback(createError(NOT_AN_OBJECT));
                }
              }
              var attachmentError;
              req.docs.forEach(function (doc) {
                if (doc._attachments) {
                  Object.keys(doc._attachments).forEach(function (name) {
                    attachmentError = attachmentError || attachmentNameError(name);
                    if (!doc._attachments[name].content_type) {
                      guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');
                    }
                  });
                }
              });
              if (attachmentError) {
                return callback(createError(BAD_REQUEST, attachmentError));
              }
              if (!('new_edits' in opts)) {
                if ('new_edits' in req) {
                  opts.new_edits = req.new_edits;
                } else {
                  opts.new_edits = true;
                }
              }
              var adapter = this;
              if (!opts.new_edits && !isRemote(adapter)) {
                req.docs.sort(compareByIdThenRev);
              }
              cleanDocs(req.docs);
              var ids = req.docs.map(function (doc) {
                return doc._id;
              });
              return this._bulkDocs(req, opts, function (err, res) {
                if (err) {
                  return callback(err);
                }
                if (!opts.new_edits) {
                  res = res.filter(function (x) {
                    return x.error;
                  });
                }
                if (!isRemote(adapter)) {
                  for (var i = 0, l = res.length; i < l; i++) {
                    res[i].id = res[i].id || ids[i];
                  }
                }
                callback(null, res);
              });
            });
            AbstractPouchDB.prototype.registerDependentDatabase = adapterFun('registerDependentDatabase', function (dependentDb, callback) {
              var depDB = new this.constructor(dependentDb, this.__opts);
              function diffFun(doc) {
                doc.dependentDbs = doc.dependentDbs || {};
                if (doc.dependentDbs[dependentDb]) {
                  return false;
                }
                doc.dependentDbs[dependentDb] = true;
                return doc;
              }
              upsert(this, '_local/_pouch_dependentDbs', diffFun).then(function () {
                callback(null, { db: depDB });
              })["catch"](callback);
            });
            AbstractPouchDB.prototype.destroy = adapterFun('destroy', function (opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              var self = this;
              var usePrefix = 'use_prefix' in self ? self.use_prefix : true;
              function destroyDb() {
                self._destroy(opts, function (err, resp) {
                  if (err) {
                    return callback(err);
                  }
                  self._destroyed = true;
                  self.emit('destroyed');
                  callback(null, resp || { 'ok': true });
                });
              }
              if (isRemote(self)) {
                return destroyDb();
              }
              self.get('_local/_pouch_dependentDbs', function (err, localDoc) {
                if (err) {
                  if (err.status !== 404) {
                    return callback(err);
                  } else {
                    return destroyDb();
                  }
                }
                var dependentDbs = localDoc.dependentDbs;
                var PouchDB = self.constructor;
                var deletedMap = Object.keys(dependentDbs).map(function (name) {
                  var trueName = usePrefix ? name.replace(new RegExp('^' + PouchDB.prefix), '') : name;
                  return new PouchDB(trueName, self.__opts).destroy();
                });
                PouchPromise$1.all(deletedMap).then(destroyDb, callback);
              });
            });
            function TaskQueue$1() {
              this.isReady = false;
              this.failed = false;
              this.queue = [];
            }
            TaskQueue$1.prototype.execute = function () {
              var fun;
              if (this.failed) {
                while (fun = this.queue.shift()) {
                  fun(this.failed);
                }
              } else {
                while (fun = this.queue.shift()) {
                  fun();
                }
              }
            };
            TaskQueue$1.prototype.fail = function (err) {
              this.failed = err;
              this.execute();
            };
            TaskQueue$1.prototype.ready = function (db) {
              this.isReady = true;
              this.db = db;
              this.execute();
            };
            TaskQueue$1.prototype.addTask = function (fun) {
              this.queue.push(fun);
              if (this.failed) {
                this.execute();
              }
            };
            function parseAdapter(name, opts) {
              var match = name.match(/([a-z-]*):\/\/(.*)/);
              if (match) {
                return {
                  name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],
                  adapter: match[1]
                };
              }
              var adapters = PouchDB$5.adapters;
              var preferredAdapters = PouchDB$5.preferredAdapters;
              var prefix = PouchDB$5.prefix;
              var adapterName = opts.adapter;
              if (!adapterName) {
                for (var i = 0; i < preferredAdapters.length; ++i) {
                  adapterName = preferredAdapters[i];
                  if (adapterName === 'idb' && 'websql' in adapters && hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {
                    guardedConsole('log', 'PouchDB is downgrading "' + name + '" to WebSQL to' + ' avoid data loss, because it was already opened with WebSQL.');
                    continue;
                  }
                  break;
                }
              }
              var adapter = adapters[adapterName];
              var usePrefix = adapter && 'use_prefix' in adapter ? adapter.use_prefix : true;
              return {
                name: usePrefix ? prefix + name : name,
                adapter: adapterName
              };
            }
            function prepareForDestruction(self) {
              function onDestroyed(from_constructor) {
                self.removeListener('closed', onClosed);
                if (!from_constructor) {
                  self.constructor.emit('destroyed', self.name);
                }
              }
              function onClosed() {
                self.removeListener('destroyed', onDestroyed);
                self.constructor.emit('unref', self);
              }
              self.once('destroyed', onDestroyed);
              self.once('closed', onClosed);
              self.constructor.emit('ref', self);
            }
            inherits(PouchDB$5, AbstractPouchDB);
            function PouchDB$5(name, opts) {
              if (!(this instanceof PouchDB$5)) {
                return new PouchDB$5(name, opts);
              }
              var self = this;
              opts = opts || {};
              if (name && typeof name === 'object') {
                opts = name;
                name = opts.name;
                delete opts.name;
              }
              this.__opts = opts = clone(opts);
              self.auto_compaction = opts.auto_compaction;
              self.prefix = PouchDB$5.prefix;
              if (typeof name !== 'string') {
                throw new Error('Missing/invalid DB name');
              }
              var prefixedName = (opts.prefix || '') + name;
              var backend = parseAdapter(prefixedName, opts);
              opts.name = backend.name;
              opts.adapter = opts.adapter || backend.adapter;
              self.name = name;
              self._adapter = opts.adapter;
              PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);
              if (!PouchDB$5.adapters[opts.adapter] || !PouchDB$5.adapters[opts.adapter].valid()) {
                throw new Error('Invalid Adapter: ' + opts.adapter);
              }
              AbstractPouchDB.call(self);
              self.taskqueue = new TaskQueue$1();
              self.adapter = opts.adapter;
              PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {
                if (err) {
                  return self.taskqueue.fail(err);
                }
                prepareForDestruction(self);
                self.emit('created', self);
                PouchDB$5.emit('created', self.name);
                self.taskqueue.ready(self);
              });
            }
            PouchDB$5.adapters = {};
            PouchDB$5.preferredAdapters = [];
            PouchDB$5.prefix = '_pouch_';
            var eventEmitter = new events.EventEmitter();
            function setUpEventEmitter(Pouch) {
              Object.keys(events.EventEmitter.prototype).forEach(function (key) {
                if (typeof events.EventEmitter.prototype[key] === 'function') {
                  Pouch[key] = eventEmitter[key].bind(eventEmitter);
                }
              });
              var destructListeners = Pouch._destructionListeners = new ExportedMap();
              Pouch.on('ref', function onConstructorRef(db) {
                if (!destructListeners.has(db.name)) {
                  destructListeners.set(db.name, []);
                }
                destructListeners.get(db.name).push(db);
              });
              Pouch.on('unref', function onConstructorUnref(db) {
                if (!destructListeners.has(db.name)) {
                  return;
                }
                var dbList = destructListeners.get(db.name);
                var pos = dbList.indexOf(db);
                if (pos < 0) {
                  return;
                }
                dbList.splice(pos, 1);
                if (dbList.length > 1) {
                  destructListeners.set(db.name, dbList);
                } else {
                  destructListeners["delete"](db.name);
                }
              });
              Pouch.on('destroyed', function onConstructorDestroyed(name) {
                if (!destructListeners.has(name)) {
                  return;
                }
                var dbList = destructListeners.get(name);
                destructListeners["delete"](name);
                dbList.forEach(function (db) {
                  db.emit('destroyed', true);
                });
              });
            }
            setUpEventEmitter(PouchDB$5);
            PouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {
              if (obj.valid()) {
                PouchDB$5.adapters[id] = obj;
                if (addToPreferredAdapters) {
                  PouchDB$5.preferredAdapters.push(id);
                }
              }
            };
            PouchDB$5.plugin = function (obj) {
              if (typeof obj === 'function') {
                obj(PouchDB$5);
              } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {
                throw new Error('Invalid plugin: got "' + obj + '", expected an object or a function');
              } else {
                Object.keys(obj).forEach(function (id) {
                  PouchDB$5.prototype[id] = obj[id];
                });
              }
              if (this.__defaults) {
                PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);
              }
              return PouchDB$5;
            };
            PouchDB$5.defaults = function (defaultOpts) {
              function PouchAlt(name, opts) {
                if (!(this instanceof PouchAlt)) {
                  return new PouchAlt(name, opts);
                }
                opts = opts || {};
                if (name && typeof name === 'object') {
                  opts = name;
                  name = opts.name;
                  delete opts.name;
                }
                opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);
                PouchDB$5.call(this, name, opts);
              }
              inherits(PouchAlt, PouchDB$5);
              PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();
              Object.keys(PouchDB$5).forEach(function (key) {
                if (!(key in PouchAlt)) {
                  PouchAlt[key] = PouchDB$5[key];
                }
              });
              PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);
              return PouchAlt;
            };
            var version = "6.3.2";
            function debugPouch(PouchDB) {
              PouchDB.debug = debug;
              var logs = {};
              PouchDB.on('debug', function (args) {
                var logId = args[0];
                var logArgs = args.slice(1);
                if (!logs[logId]) {
                  logs[logId] = debug('pouchdb:' + logId);
                }
                logs[logId].apply(null, logArgs);
              });
            }
            function getFieldFromDoc(doc, parsedField) {
              var value = doc;
              for (var i = 0, len = parsedField.length; i < len; i++) {
                var key = parsedField[i];
                value = value[key];
                if (!value) {
                  break;
                }
              }
              return value;
            }
            function compare$1(left, right) {
              return left < right ? -1 : left > right ? 1 : 0;
            }
            function parseField(fieldName) {
              var fields = [];
              var current = '';
              for (var i = 0, len = fieldName.length; i < len; i++) {
                var ch = fieldName[i];
                if (ch === '.') {
                  if (i > 0 && fieldName[i - 1] === '\\') {
                    current = current.substring(0, current.length - 1) + '.';
                  } else {
                    fields.push(current);
                    current = '';
                  }
                } else {
                  current += ch;
                }
              }
              fields.push(current);
              return fields;
            }
            var combinationFields = ['$or', '$nor', '$not'];
            function isCombinationalField(field) {
              return combinationFields.indexOf(field) > -1;
            }
            function getKey(obj) {
              return Object.keys(obj)[0];
            }
            function getValue(obj) {
              return obj[getKey(obj)];
            }
            function mergeAndedSelectors(selectors) {
              var res = {};
              selectors.forEach(function (selector) {
                Object.keys(selector).forEach(function (field) {
                  var matcher = selector[field];
                  if (typeof matcher !== 'object') {
                    matcher = { $eq: matcher };
                  }
                  if (isCombinationalField(field)) {
                    if (matcher instanceof Array) {
                      res[field] = matcher.map(function (m) {
                        return mergeAndedSelectors([m]);
                      });
                    } else {
                      res[field] = mergeAndedSelectors([matcher]);
                    }
                  } else {
                    var fieldMatchers = res[field] = res[field] || {};
                    Object.keys(matcher).forEach(function (operator) {
                      var value = matcher[operator];
                      if (operator === '$gt' || operator === '$gte') {
                        return mergeGtGte(operator, value, fieldMatchers);
                      } else if (operator === '$lt' || operator === '$lte') {
                        return mergeLtLte(operator, value, fieldMatchers);
                      } else if (operator === '$ne') {
                        return mergeNe(value, fieldMatchers);
                      } else if (operator === '$eq') {
                        return mergeEq(value, fieldMatchers);
                      }
                      fieldMatchers[operator] = value;
                    });
                  }
                });
              });
              return res;
            }
            function mergeGtGte(operator, value, fieldMatchers) {
              if (typeof fieldMatchers.$eq !== 'undefined') {
                return;
              }
              if (typeof fieldMatchers.$gte !== 'undefined') {
                if (operator === '$gte') {
                  if (value > fieldMatchers.$gte) {
                    fieldMatchers.$gte = value;
                  }
                } else {
                  if (value >= fieldMatchers.$gte) {
                    delete fieldMatchers.$gte;
                    fieldMatchers.$gt = value;
                  }
                }
              } else if (typeof fieldMatchers.$gt !== 'undefined') {
                if (operator === '$gte') {
                  if (value > fieldMatchers.$gt) {
                    delete fieldMatchers.$gt;
                    fieldMatchers.$gte = value;
                  }
                } else {
                  if (value > fieldMatchers.$gt) {
                    fieldMatchers.$gt = value;
                  }
                }
              } else {
                fieldMatchers[operator] = value;
              }
            }
            function mergeLtLte(operator, value, fieldMatchers) {
              if (typeof fieldMatchers.$eq !== 'undefined') {
                return;
              }
              if (typeof fieldMatchers.$lte !== 'undefined') {
                if (operator === '$lte') {
                  if (value < fieldMatchers.$lte) {
                    fieldMatchers.$lte = value;
                  }
                } else {
                  if (value <= fieldMatchers.$lte) {
                    delete fieldMatchers.$lte;
                    fieldMatchers.$lt = value;
                  }
                }
              } else if (typeof fieldMatchers.$lt !== 'undefined') {
                if (operator === '$lte') {
                  if (value < fieldMatchers.$lt) {
                    delete fieldMatchers.$lt;
                    fieldMatchers.$lte = value;
                  }
                } else {
                  if (value < fieldMatchers.$lt) {
                    fieldMatchers.$lt = value;
                  }
                }
              } else {
                fieldMatchers[operator] = value;
              }
            }
            function mergeNe(value, fieldMatchers) {
              if ('$ne' in fieldMatchers) {
                fieldMatchers.$ne.push(value);
              } else {
                fieldMatchers.$ne = [value];
              }
            }
            function mergeEq(value, fieldMatchers) {
              delete fieldMatchers.$gt;
              delete fieldMatchers.$gte;
              delete fieldMatchers.$lt;
              delete fieldMatchers.$lte;
              delete fieldMatchers.$ne;
              fieldMatchers.$eq = value;
            }
            function massageSelector(input) {
              var result = clone(input);
              var wasAnded = false;
              if ('$and' in result) {
                result = mergeAndedSelectors(result['$and']);
                wasAnded = true;
              }
              ['$or', '$nor'].forEach(function (orOrNor) {
                if (orOrNor in result) {
                  result[orOrNor].forEach(function (subSelector) {
                    var fields = Object.keys(subSelector);
                    for (var i = 0; i < fields.length; i++) {
                      var field = fields[i];
                      var matcher = subSelector[field];
                      if (typeof matcher !== 'object' || matcher === null) {
                        subSelector[field] = { $eq: matcher };
                      }
                    }
                  });
                }
              });
              if ('$not' in result) {
                result['$not'] = mergeAndedSelectors([result['$not']]);
              }
              var fields = Object.keys(result);
              for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                var matcher = result[field];
                if (typeof matcher !== 'object' || matcher === null) {
                  matcher = { $eq: matcher };
                } else if ('$ne' in matcher && !wasAnded) {
                  matcher.$ne = [matcher.$ne];
                }
                result[field] = matcher;
              }
              return result;
            }
            function pad(str, padWith, upToLength) {
              var padding = '';
              var targetLength = upToLength - str.length;
              while (padding.length < targetLength) {
                padding += padWith;
              }
              return padding;
            }
            function padLeft(str, padWith, upToLength) {
              var padding = pad(str, padWith, upToLength);
              return padding + str;
            }
            var MIN_MAGNITUDE = -324;
            var MAGNITUDE_DIGITS = 3;
            var SEP = '';
            function collate(a, b) {
              if (a === b) {
                return 0;
              }
              a = normalizeKey(a);
              b = normalizeKey(b);
              var ai = collationIndex(a);
              var bi = collationIndex(b);
              if (ai - bi !== 0) {
                return ai - bi;
              }
              switch (typeof a) {
                case 'number':
                  return a - b;
                case 'boolean':
                  return a < b ? -1 : 1;
                case 'string':
                  return stringCollate(a, b);
              }
              return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);
            }
            function normalizeKey(key) {
              switch (typeof key) {
                case 'undefined':
                  return null;
                case 'number':
                  if (key === Infinity || key === -Infinity || isNaN(key)) {
                    return null;
                  }
                  return key;
                case 'object':
                  var origKey = key;
                  if (Array.isArray(key)) {
                    var len = key.length;
                    key = new Array(len);
                    for (var i = 0; i < len; i++) {
                      key[i] = normalizeKey(origKey[i]);
                    }
                  } else if (key instanceof Date) {
                    return key.toJSON();
                  } else if (key !== null) {
                    key = {};
                    for (var k in origKey) {
                      if (origKey.hasOwnProperty(k)) {
                        var val = origKey[k];
                        if (typeof val !== 'undefined') {
                          key[k] = normalizeKey(val);
                        }
                      }
                    }
                  }
              }
              return key;
            }
            function indexify(key) {
              if (key !== null) {
                switch (typeof key) {
                  case 'boolean':
                    return key ? 1 : 0;
                  case 'number':
                    return numToIndexableString(key);
                  case 'string':
                    return key.replace(/\u0002/g, '\u0002\u0002').replace(/\u0001/g, '\u0001\u0002').replace(/\u0000/g, '\u0001\u0001');
                  case 'object':
                    var isArray = Array.isArray(key);
                    var arr = isArray ? key : Object.keys(key);
                    var i = -1;
                    var len = arr.length;
                    var result = '';
                    if (isArray) {
                      while (++i < len) {
                        result += toIndexableString(arr[i]);
                      }
                    } else {
                      while (++i < len) {
                        var objKey = arr[i];
                        result += toIndexableString(objKey) + toIndexableString(key[objKey]);
                      }
                    }
                    return result;
                }
              }
              return '';
            }
            function toIndexableString(key) {
              var zero = '\u0000';
              key = normalizeKey(key);
              return collationIndex(key) + SEP + indexify(key) + zero;
            }
            function parseNumber(str, i) {
              var originalIdx = i;
              var num;
              var zero = str[i] === '1';
              if (zero) {
                num = 0;
                i++;
              } else {
                var neg = str[i] === '0';
                i++;
                var numAsString = '';
                var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);
                var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;
                if (neg) {
                  magnitude = -magnitude;
                }
                i += MAGNITUDE_DIGITS;
                while (true) {
                  var ch = str[i];
                  if (ch === '\u0000') {
                    break;
                  } else {
                    numAsString += ch;
                  }
                  i++;
                }
                numAsString = numAsString.split('.');
                if (numAsString.length === 1) {
                  num = parseInt(numAsString, 10);
                } else {
                  num = parseFloat(numAsString[0] + '.' + numAsString[1]);
                }
                if (neg) {
                  num = num - 10;
                }
                if (magnitude !== 0) {
                  num = parseFloat(num + 'e' + magnitude);
                }
              }
              return {
                num: num,
                length: i - originalIdx
              };
            }
            function pop(stack, metaStack) {
              var obj = stack.pop();
              if (metaStack.length) {
                var lastMetaElement = metaStack[metaStack.length - 1];
                if (obj === lastMetaElement.element) {
                  metaStack.pop();
                  lastMetaElement = metaStack[metaStack.length - 1];
                }
                var element = lastMetaElement.element;
                var lastElementIndex = lastMetaElement.index;
                if (Array.isArray(element)) {
                  element.push(obj);
                } else if (lastElementIndex === stack.length - 2) {
                  var key = stack.pop();
                  element[key] = obj;
                } else {
                  stack.push(obj);
                }
              }
            }
            function parseIndexableString(str) {
              var stack = [];
              var metaStack = [];
              var i = 0;
              while (true) {
                var collationIndex = str[i++];
                if (collationIndex === '\u0000') {
                  if (stack.length === 1) {
                    return stack.pop();
                  } else {
                    pop(stack, metaStack);
                    continue;
                  }
                }
                switch (collationIndex) {
                  case '1':
                    stack.push(null);
                    break;
                  case '2':
                    stack.push(str[i] === '1');
                    i++;
                    break;
                  case '3':
                    var parsedNum = parseNumber(str, i);
                    stack.push(parsedNum.num);
                    i += parsedNum.length;
                    break;
                  case '4':
                    var parsedStr = '';
                    while (true) {
                      var ch = str[i];
                      if (ch === '\u0000') {
                        break;
                      }
                      parsedStr += ch;
                      i++;
                    }
                    parsedStr = parsedStr.replace(/\u0001\u0001/g, '\u0000').replace(/\u0001\u0002/g, '\u0001').replace(/\u0002\u0002/g, '\u0002');
                    stack.push(parsedStr);
                    break;
                  case '5':
                    var arrayElement = {
                      element: [],
                      index: stack.length
                    };
                    stack.push(arrayElement.element);
                    metaStack.push(arrayElement);
                    break;
                  case '6':
                    var objElement = {
                      element: {},
                      index: stack.length
                    };
                    stack.push(objElement.element);
                    metaStack.push(objElement);
                    break;
                  default:
                    throw new Error('bad collationIndex or unexpectedly reached end of input: ' + collationIndex);
                }
              }
            }
            function arrayCollate(a, b) {
              var len = Math.min(a.length, b.length);
              for (var i = 0; i < len; i++) {
                var sort = collate(a[i], b[i]);
                if (sort !== 0) {
                  return sort;
                }
              }
              return a.length === b.length ? 0 : a.length > b.length ? 1 : -1;
            }
            function stringCollate(a, b) {
              return a === b ? 0 : a > b ? 1 : -1;
            }
            function objectCollate(a, b) {
              var ak = Object.keys(a),
                  bk = Object.keys(b);
              var len = Math.min(ak.length, bk.length);
              for (var i = 0; i < len; i++) {
                var sort = collate(ak[i], bk[i]);
                if (sort !== 0) {
                  return sort;
                }
                sort = collate(a[ak[i]], b[bk[i]]);
                if (sort !== 0) {
                  return sort;
                }
              }
              return ak.length === bk.length ? 0 : ak.length > bk.length ? 1 : -1;
            }
            function collationIndex(x) {
              var id = ['boolean', 'number', 'string', 'object'];
              var idx = id.indexOf(typeof x);
              if (~idx) {
                if (x === null) {
                  return 1;
                }
                if (Array.isArray(x)) {
                  return 5;
                }
                return idx < 3 ? idx + 2 : idx + 3;
              }
              if (Array.isArray(x)) {
                return 5;
              }
            }
            function numToIndexableString(num) {
              if (num === 0) {
                return '1';
              }
              var expFormat = num.toExponential().split(/e\+?/);
              var magnitude = parseInt(expFormat[1], 10);
              var neg = num < 0;
              var result = neg ? '0' : '2';
              var magForComparison = (neg ? -magnitude : magnitude) - MIN_MAGNITUDE;
              var magString = padLeft(magForComparison.toString(), '0', MAGNITUDE_DIGITS);
              result += SEP + magString;
              var factor = Math.abs(parseFloat(expFormat[0]));
              if (neg) {
                factor = 10 - factor;
              }
              var factorStr = factor.toFixed(20);
              factorStr = factorStr.replace(/\.?0+$/, '');
              result += SEP + factorStr;
              return result;
            }
            function createFieldSorter(sort) {
              function getFieldValuesAsArray(doc) {
                return sort.map(function (sorting) {
                  var fieldName = getKey(sorting);
                  var parsedField = parseField(fieldName);
                  var docFieldValue = getFieldFromDoc(doc, parsedField);
                  return docFieldValue;
                });
              }
              return function (aRow, bRow) {
                var aFieldValues = getFieldValuesAsArray(aRow.doc);
                var bFieldValues = getFieldValuesAsArray(bRow.doc);
                var collation = collate(aFieldValues, bFieldValues);
                if (collation !== 0) {
                  return collation;
                }
                return compare$1(aRow.doc._id, bRow.doc._id);
              };
            }
            function filterInMemoryFields(rows, requestDef, inMemoryFields) {
              rows = rows.filter(function (row) {
                return rowFilter(row.doc, requestDef.selector, inMemoryFields);
              });
              if (requestDef.sort) {
                var fieldSorter = createFieldSorter(requestDef.sort);
                rows = rows.sort(fieldSorter);
                if (typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc') {
                  rows = rows.reverse();
                }
              }
              if ('limit' in requestDef || 'skip' in requestDef) {
                var skip = requestDef.skip || 0;
                var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;
                rows = rows.slice(skip, limit);
              }
              return rows;
            }
            function rowFilter(doc, selector, inMemoryFields) {
              return inMemoryFields.every(function (field) {
                var matcher = selector[field];
                var parsedField = parseField(field);
                var docFieldValue = getFieldFromDoc(doc, parsedField);
                if (isCombinationalField(field)) {
                  return matchCominationalSelector(field, matcher, doc);
                }
                return matchSelector(matcher, doc, parsedField, docFieldValue);
              });
            }
            function matchSelector(matcher, doc, parsedField, docFieldValue) {
              if (!matcher) {
                return true;
              }
              return Object.keys(matcher).every(function (userOperator) {
                var userValue = matcher[userOperator];
                return match(userOperator, doc, userValue, parsedField, docFieldValue);
              });
            }
            function matchCominationalSelector(field, matcher, doc) {
              if (field === '$or') {
                return matcher.some(function (orMatchers) {
                  return rowFilter(doc, orMatchers, Object.keys(orMatchers));
                });
              }
              if (field === '$not') {
                return !rowFilter(doc, matcher, Object.keys(matcher));
              }
              return !matcher.find(function (orMatchers) {
                return rowFilter(doc, orMatchers, Object.keys(orMatchers));
              });
            }
            function match(userOperator, doc, userValue, parsedField, docFieldValue) {
              if (!matchers[userOperator]) {
                throw new Error('unknown operator "' + userOperator + '" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' + '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');
              }
              return matchers[userOperator](doc, userValue, parsedField, docFieldValue);
            }
            function fieldExists(docFieldValue) {
              return typeof docFieldValue !== 'undefined' && docFieldValue !== null;
            }
            function fieldIsNotUndefined(docFieldValue) {
              return typeof docFieldValue !== 'undefined';
            }
            function modField(docFieldValue, userValue) {
              var divisor = userValue[0];
              var mod = userValue[1];
              if (divisor === 0) {
                throw new Error('Bad divisor, cannot divide by zero');
              }
              if (parseInt(divisor, 10) !== divisor) {
                throw new Error('Divisor is not an integer');
              }
              if (parseInt(mod, 10) !== mod) {
                throw new Error('Modulus is not an integer');
              }
              if (parseInt(docFieldValue, 10) !== docFieldValue) {
                return false;
              }
              return docFieldValue % divisor === mod;
            }
            function arrayContainsValue(docFieldValue, userValue) {
              return userValue.some(function (val) {
                if (docFieldValue instanceof Array) {
                  return docFieldValue.indexOf(val) > -1;
                }
                return docFieldValue === val;
              });
            }
            function arrayContainsAllValues(docFieldValue, userValue) {
              return userValue.every(function (val) {
                return docFieldValue.indexOf(val) > -1;
              });
            }
            function arraySize(docFieldValue, userValue) {
              return docFieldValue.length === userValue;
            }
            function regexMatch(docFieldValue, userValue) {
              var re = new RegExp(userValue);
              return re.test(docFieldValue);
            }
            function typeMatch(docFieldValue, userValue) {
              switch (userValue) {
                case 'null':
                  return docFieldValue === null;
                case 'boolean':
                  return typeof docFieldValue === 'boolean';
                case 'number':
                  return typeof docFieldValue === 'number';
                case 'string':
                  return typeof docFieldValue === 'string';
                case 'array':
                  return docFieldValue instanceof Array;
                case 'object':
                  return {}.toString.call(docFieldValue) === '[object Object]';
              }
              throw new Error(userValue + ' not supported as a type.' + 'Please use one of object, string, array, number, boolean or null.');
            }
            var matchers = {
              '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {
                if (!Array.isArray(docFieldValue)) {
                  return false;
                }
                if (docFieldValue.length === 0) {
                  return false;
                }
                if (typeof docFieldValue[0] === 'object') {
                  return docFieldValue.some(function (val) {
                    return rowFilter(val, userValue, Object.keys(userValue));
                  });
                }
                return docFieldValue.some(function (val) {
                  return matchSelector(userValue, doc, parsedField, val);
                });
              },
              '$allMatch': function (doc, userValue, parsedField, docFieldValue) {
                if (!Array.isArray(docFieldValue)) {
                  return false;
                }
                if (docFieldValue.length === 0) {
                  return false;
                }
                if (typeof docFieldValue[0] === 'object') {
                  return docFieldValue.every(function (val) {
                    return rowFilter(val, userValue, Object.keys(userValue));
                  });
                }
                return docFieldValue.every(function (val) {
                  return matchSelector(userValue, doc, parsedField, val);
                });
              },
              '$eq': function (doc, userValue, parsedField, docFieldValue) {
                return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;
              },
              '$gte': function (doc, userValue, parsedField, docFieldValue) {
                return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;
              },
              '$gt': function (doc, userValue, parsedField, docFieldValue) {
                return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;
              },
              '$lte': function (doc, userValue, parsedField, docFieldValue) {
                return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;
              },
              '$lt': function (doc, userValue, parsedField, docFieldValue) {
                return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;
              },
              '$exists': function (doc, userValue, parsedField, docFieldValue) {
                if (userValue) {
                  return fieldIsNotUndefined(docFieldValue);
                }
                return !fieldIsNotUndefined(docFieldValue);
              },
              '$mod': function (doc, userValue, parsedField, docFieldValue) {
                return fieldExists(docFieldValue) && modField(docFieldValue, userValue);
              },
              '$ne': function (doc, userValue, parsedField, docFieldValue) {
                return userValue.every(function (neValue) {
                  return collate(docFieldValue, neValue) !== 0;
                });
              },
              '$in': function (doc, userValue, parsedField, docFieldValue) {
                return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);
              },
              '$nin': function (doc, userValue, parsedField, docFieldValue) {
                return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);
              },
              '$size': function (doc, userValue, parsedField, docFieldValue) {
                return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);
              },
              '$all': function (doc, userValue, parsedField, docFieldValue) {
                return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);
              },
              '$regex': function (doc, userValue, parsedField, docFieldValue) {
                return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);
              },
              '$type': function (doc, userValue, parsedField, docFieldValue) {
                return typeMatch(docFieldValue, userValue);
              }
            };
            function matchesSelector(doc, selector) {
              if (typeof selector !== 'object') {
                throw new Error('Selector error: expected a JSON object');
              }
              selector = massageSelector(selector);
              var row = { 'doc': doc };
              var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));
              return rowsMatched && rowsMatched.length === 1;
            }
            function evalFilter(input) {
              return scopeEval('"use strict";\nreturn ' + input + ';', {});
            }
            function evalView(input) {
              var code = ['return function(doc) {', '  "use strict";', '  var emitted = false;', '  var emit = function (a, b) {', '    emitted = true;', '  };', '  var view = ' + input + ';', '  view(doc);', '  if (emitted) {', '    return true;', '  }', '};'].join('\n');
              return scopeEval(code, {});
            }
            function validate(opts, callback) {
              if (opts.selector) {
                if (opts.filter && opts.filter !== '_selector') {
                  var filterName = typeof opts.filter === 'string' ? opts.filter : 'function';
                  return callback(new Error('selector invalid for filter "' + filterName + '"'));
                }
              }
              callback();
            }
            function normalize(opts) {
              if (opts.view && !opts.filter) {
                opts.filter = '_view';
              }
              if (opts.selector && !opts.filter) {
                opts.filter = '_selector';
              }
              if (opts.filter && typeof opts.filter === 'string') {
                if (opts.filter === '_view') {
                  opts.view = normalizeDesignDocFunctionName(opts.view);
                } else {
                  opts.filter = normalizeDesignDocFunctionName(opts.filter);
                }
              }
            }
            function shouldFilter(changesHandler, opts) {
              return opts.filter && typeof opts.filter === 'string' && !opts.doc_ids && !isRemote(changesHandler.db);
            }
            function filter(changesHandler, opts) {
              var callback = opts.complete;
              if (opts.filter === '_view') {
                if (!opts.view || typeof opts.view !== 'string') {
                  var err = createError(BAD_REQUEST, '`view` filter parameter not found or invalid.');
                  return callback(err);
                }
                var viewName = parseDesignDocFunctionName(opts.view);
                changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {
                  if (changesHandler.isCancelled) {
                    return callback(null, { status: 'cancelled' });
                  }
                  if (err) {
                    return callback(generateErrorFromResponse(err));
                  }
                  var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] && ddoc.views[viewName[1]].map;
                  if (!mapFun) {
                    return callback(createError(MISSING_DOC, ddoc.views ? 'missing json key: ' + viewName[1] : 'missing json key: views'));
                  }
                  opts.filter = evalView(mapFun);
                  changesHandler.doChanges(opts);
                });
              } else if (opts.selector) {
                opts.filter = function (doc) {
                  return matchesSelector(doc, opts.selector);
                };
                changesHandler.doChanges(opts);
              } else {
                var filterName = parseDesignDocFunctionName(opts.filter);
                changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {
                  if (changesHandler.isCancelled) {
                    return callback(null, { status: 'cancelled' });
                  }
                  if (err) {
                    return callback(generateErrorFromResponse(err));
                  }
                  var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];
                  if (!filterFun) {
                    return callback(createError(MISSING_DOC, ddoc && ddoc.filters ? 'missing json key: ' + filterName[1] : 'missing json key: filters'));
                  }
                  opts.filter = evalFilter(filterFun);
                  changesHandler.doChanges(opts);
                });
              }
            }
            function applyChangesFilterPlugin(PouchDB) {
              PouchDB._changesFilterPlugin = {
                validate: validate,
                normalize: normalize,
                shouldFilter: shouldFilter,
                filter: filter
              };
            }
            PouchDB$5.plugin(debugPouch);
            PouchDB$5.plugin(applyChangesFilterPlugin);
            PouchDB$5.version = version;
            function toObject(array) {
              return array.reduce(function (obj, item) {
                obj[item] = true;
                return obj;
              }, {});
            }
            var reservedWords = toObject(['_id', '_rev', '_attachments', '_deleted', '_revisions', '_revs_info', '_conflicts', '_deleted_conflicts', '_local_seq', '_rev_tree', '_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats', '_removed']);
            var dataWords = toObject(['_attachments', '_replication_id', '_replication_state', '_replication_state_time', '_replication_state_reason', '_replication_stats']);
            function parseRevisionInfo(rev$$1) {
              if (!/^\d+-./.test(rev$$1)) {
                return createError(INVALID_REV);
              }
              var idx = rev$$1.indexOf('-');
              var left = rev$$1.substring(0, idx);
              var right = rev$$1.substring(idx + 1);
              return {
                prefix: parseInt(left, 10),
                id: right
              };
            }
            function makeRevTreeFromRevisions(revisions, opts) {
              var pos = revisions.start - revisions.ids.length + 1;
              var revisionIds = revisions.ids;
              var ids = [revisionIds[0], opts, []];
              for (var i = 1, len = revisionIds.length; i < len; i++) {
                ids = [revisionIds[i], { status: 'missing' }, [ids]];
              }
              return [{
                pos: pos,
                ids: ids
              }];
            }
            function parseDoc(doc, newEdits) {
              var nRevNum;
              var newRevId;
              var revInfo;
              var opts = { status: 'available' };
              if (doc._deleted) {
                opts.deleted = true;
              }
              if (newEdits) {
                if (!doc._id) {
                  doc._id = uuid();
                }
                newRevId = rev();
                if (doc._rev) {
                  revInfo = parseRevisionInfo(doc._rev);
                  if (revInfo.error) {
                    return revInfo;
                  }
                  doc._rev_tree = [{
                    pos: revInfo.prefix,
                    ids: [revInfo.id, { status: 'missing' }, [[newRevId, opts, []]]]
                  }];
                  nRevNum = revInfo.prefix + 1;
                } else {
                  doc._rev_tree = [{
                    pos: 1,
                    ids: [newRevId, opts, []]
                  }];
                  nRevNum = 1;
                }
              } else {
                if (doc._revisions) {
                  doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);
                  nRevNum = doc._revisions.start;
                  newRevId = doc._revisions.ids[0];
                }
                if (!doc._rev_tree) {
                  revInfo = parseRevisionInfo(doc._rev);
                  if (revInfo.error) {
                    return revInfo;
                  }
                  nRevNum = revInfo.prefix;
                  newRevId = revInfo.id;
                  doc._rev_tree = [{
                    pos: nRevNum,
                    ids: [newRevId, opts, []]
                  }];
                }
              }
              invalidIdError(doc._id);
              doc._rev = nRevNum + '-' + newRevId;
              var result = {
                metadata: {},
                data: {}
              };
              for (var key in doc) {
                if (Object.prototype.hasOwnProperty.call(doc, key)) {
                  var specialKey = key[0] === '_';
                  if (specialKey && !reservedWords[key]) {
                    var error = createError(DOC_VALIDATION, key);
                    error.message = DOC_VALIDATION.message + ': ' + key;
                    throw error;
                  } else if (specialKey && !dataWords[key]) {
                    result.metadata[key.slice(1)] = doc[key];
                  } else {
                    result.data[key] = doc[key];
                  }
                }
              }
              return result;
            }
            var thisAtob = function (str) {
              return atob(str);
            };
            var thisBtoa = function (str) {
              return btoa(str);
            };
            function createBlob(parts, properties) {
              parts = parts || [];
              properties = properties || {};
              try {
                return new Blob(parts, properties);
              } catch (e) {
                if (e.name !== "TypeError") {
                  throw e;
                }
                var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
                var builder = new Builder();
                for (var i = 0; i < parts.length; i += 1) {
                  builder.append(parts[i]);
                }
                return builder.getBlob(properties.type);
              }
            }
            function binaryStringToArrayBuffer(bin) {
              var length = bin.length;
              var buf = new ArrayBuffer(length);
              var arr = new Uint8Array(buf);
              for (var i = 0; i < length; i++) {
                arr[i] = bin.charCodeAt(i);
              }
              return buf;
            }
            function binStringToBluffer(binString, type) {
              return createBlob([binaryStringToArrayBuffer(binString)], { type: type });
            }
            function b64ToBluffer(b64, type) {
              return binStringToBluffer(thisAtob(b64), type);
            }
            function arrayBufferToBinaryString(buffer) {
              var binary = '';
              var bytes = new Uint8Array(buffer);
              var length = bytes.byteLength;
              for (var i = 0; i < length; i++) {
                binary += String.fromCharCode(bytes[i]);
              }
              return binary;
            }
            function readAsBinaryString(blob, callback) {
              if (typeof FileReader === 'undefined') {
                return callback(arrayBufferToBinaryString(new FileReaderSync().readAsArrayBuffer(blob)));
              }
              var reader = new FileReader();
              var hasBinaryString = typeof reader.readAsBinaryString === 'function';
              reader.onloadend = function (e) {
                var result = e.target.result || '';
                if (hasBinaryString) {
                  return callback(result);
                }
                callback(arrayBufferToBinaryString(result));
              };
              if (hasBinaryString) {
                reader.readAsBinaryString(blob);
              } else {
                reader.readAsArrayBuffer(blob);
              }
            }
            function blobToBinaryString(blobOrBuffer, callback) {
              readAsBinaryString(blobOrBuffer, function (bin) {
                callback(bin);
              });
            }
            function blobToBase64(blobOrBuffer, callback) {
              blobToBinaryString(blobOrBuffer, function (base64) {
                callback(thisBtoa(base64));
              });
            }
            function readAsArrayBuffer(blob, callback) {
              if (typeof FileReader === 'undefined') {
                return callback(new FileReaderSync().readAsArrayBuffer(blob));
              }
              var reader = new FileReader();
              reader.onloadend = function (e) {
                var result = e.target.result || new ArrayBuffer(0);
                callback(result);
              };
              reader.readAsArrayBuffer(blob);
            }
            var setImmediateShim = global.setImmediate || global.setTimeout;
            var MD5_CHUNK_SIZE = 32768;
            function rawToBase64(raw) {
              return thisBtoa(raw);
            }
            function sliceBlob(blob, start, end) {
              if (blob.webkitSlice) {
                return blob.webkitSlice(start, end);
              }
              return blob.slice(start, end);
            }
            function appendBlob(buffer, blob, start, end, callback) {
              if (start > 0 || end < blob.size) {
                blob = sliceBlob(blob, start, end);
              }
              readAsArrayBuffer(blob, function (arrayBuffer) {
                buffer.append(arrayBuffer);
                callback();
              });
            }
            function appendString(buffer, string, start, end, callback) {
              if (start > 0 || end < string.length) {
                string = string.substring(start, end);
              }
              buffer.appendBinary(string);
              callback();
            }
            function binaryMd5(data, callback) {
              var inputIsString = typeof data === 'string';
              var len = inputIsString ? data.length : data.size;
              var chunkSize = Math.min(MD5_CHUNK_SIZE, len);
              var chunks = Math.ceil(len / chunkSize);
              var currentChunk = 0;
              var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();
              var append = inputIsString ? appendString : appendBlob;
              function next() {
                setImmediateShim(loadNextChunk);
              }
              function done() {
                var raw = buffer.end(true);
                var base64 = rawToBase64(raw);
                callback(base64);
                buffer.destroy();
              }
              function loadNextChunk() {
                var start = currentChunk * chunkSize;
                var end = start + chunkSize;
                currentChunk++;
                if (currentChunk < chunks) {
                  append(buffer, data, start, end, next);
                } else {
                  append(buffer, data, start, end, done);
                }
              }
              loadNextChunk();
            }
            function stringMd5(string) {
              return Md5.hash(string);
            }
            function parseBase64(data) {
              try {
                return thisAtob(data);
              } catch (e) {
                var err = createError(BAD_ARG, 'Attachment is not a valid base64 string');
                return { error: err };
              }
            }
            function preprocessString(att, blobType, callback) {
              var asBinary = parseBase64(att.data);
              if (asBinary.error) {
                return callback(asBinary.error);
              }
              att.length = asBinary.length;
              if (blobType === 'blob') {
                att.data = binStringToBluffer(asBinary, att.content_type);
              } else if (blobType === 'base64') {
                att.data = thisBtoa(asBinary);
              } else {
                att.data = asBinary;
              }
              binaryMd5(asBinary, function (result) {
                att.digest = 'md5-' + result;
                callback();
              });
            }
            function preprocessBlob(att, blobType, callback) {
              binaryMd5(att.data, function (md5) {
                att.digest = 'md5-' + md5;
                att.length = att.data.size || att.data.length || 0;
                if (blobType === 'binary') {
                  blobToBinaryString(att.data, function (binString) {
                    att.data = binString;
                    callback();
                  });
                } else if (blobType === 'base64') {
                  blobToBase64(att.data, function (b64) {
                    att.data = b64;
                    callback();
                  });
                } else {
                  callback();
                }
              });
            }
            function preprocessAttachment(att, blobType, callback) {
              if (att.stub) {
                return callback();
              }
              if (typeof att.data === 'string') {
                preprocessString(att, blobType, callback);
              } else {
                preprocessBlob(att, blobType, callback);
              }
            }
            function preprocessAttachments(docInfos, blobType, callback) {
              if (!docInfos.length) {
                return callback();
              }
              var docv = 0;
              var overallErr;
              docInfos.forEach(function (docInfo) {
                var attachments = docInfo.data && docInfo.data._attachments ? Object.keys(docInfo.data._attachments) : [];
                var recv = 0;
                if (!attachments.length) {
                  return done();
                }
                function processedAttachment(err) {
                  overallErr = err;
                  recv++;
                  if (recv === attachments.length) {
                    done();
                  }
                }
                for (var key in docInfo.data._attachments) {
                  if (docInfo.data._attachments.hasOwnProperty(key)) {
                    preprocessAttachment(docInfo.data._attachments[key], blobType, processedAttachment);
                  }
                }
              });
              function done() {
                docv++;
                if (docInfos.length === docv) {
                  if (overallErr) {
                    callback(overallErr);
                  } else {
                    callback();
                  }
                }
              }
            }
            function updateDoc(revLimit, prev, docInfo, results, i, cb, writeDoc, newEdits) {
              if (revExists(prev.rev_tree, docInfo.metadata.rev)) {
                results[i] = docInfo;
                return cb();
              }
              var previousWinningRev = prev.winningRev || winningRev(prev);
              var previouslyDeleted = 'deleted' in prev ? prev.deleted : isDeleted(prev, previousWinningRev);
              var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted : isDeleted(docInfo.metadata);
              var isRoot = /^1-/.test(docInfo.metadata.rev);
              if (previouslyDeleted && !deleted && newEdits && isRoot) {
                var newDoc = docInfo.data;
                newDoc._rev = previousWinningRev;
                newDoc._id = docInfo.metadata.id;
                docInfo = parseDoc(newDoc, newEdits);
              }
              var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);
              var inConflict = newEdits && (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf' || !previouslyDeleted && merged.conflicts !== 'new_leaf' || previouslyDeleted && !deleted && merged.conflicts === 'new_branch');
              if (inConflict) {
                var err = createError(REV_CONFLICT);
                results[i] = err;
                return cb();
              }
              var newRev = docInfo.metadata.rev;
              docInfo.metadata.rev_tree = merged.tree;
              docInfo.stemmedRevs = merged.stemmedRevs || [];
              if (prev.rev_map) {
                docInfo.metadata.rev_map = prev.rev_map;
              }
              var winningRev$$1 = winningRev(docInfo.metadata);
              var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);
              var delta = previouslyDeleted === winningRevIsDeleted ? 0 : previouslyDeleted < winningRevIsDeleted ? -1 : 1;
              var newRevIsDeleted;
              if (newRev === winningRev$$1) {
                newRevIsDeleted = winningRevIsDeleted;
              } else {
                newRevIsDeleted = isDeleted(docInfo.metadata, newRev);
              }
              writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, true, delta, i, cb);
            }
            function rootIsMissing(docInfo) {
              return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';
            }
            function processDocs(revLimit, docInfos, api, fetchedDocs, tx, results, writeDoc, opts, overallCallback) {
              revLimit = revLimit || 1000;
              function insertDoc(docInfo, resultsIdx, callback) {
                var winningRev$$1 = winningRev(docInfo.metadata);
                var deleted = isDeleted(docInfo.metadata, winningRev$$1);
                if ('was_delete' in opts && deleted) {
                  results[resultsIdx] = createError(MISSING_DOC, 'deleted');
                  return callback();
                }
                var inConflict = newEdits && rootIsMissing(docInfo);
                if (inConflict) {
                  var err = createError(REV_CONFLICT);
                  results[resultsIdx] = err;
                  return callback();
                }
                var delta = deleted ? 0 : 1;
                writeDoc(docInfo, winningRev$$1, deleted, deleted, false, delta, resultsIdx, callback);
              }
              var newEdits = opts.new_edits;
              var idsToDocs = new ExportedMap();
              var docsDone = 0;
              var docsToDo = docInfos.length;
              function checkAllDocsDone() {
                if (++docsDone === docsToDo && overallCallback) {
                  overallCallback();
                }
              }
              docInfos.forEach(function (currentDoc, resultsIdx) {
                if (currentDoc._id && isLocalId(currentDoc._id)) {
                  var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';
                  api[fun](currentDoc, { ctx: tx }, function (err, res) {
                    results[resultsIdx] = err || res;
                    checkAllDocsDone();
                  });
                  return;
                }
                var id = currentDoc.metadata.id;
                if (idsToDocs.has(id)) {
                  docsToDo--;
                  idsToDocs.get(id).push([currentDoc, resultsIdx]);
                } else {
                  idsToDocs.set(id, [[currentDoc, resultsIdx]]);
                }
              });
              idsToDocs.forEach(function (docs, id) {
                var numDone = 0;
                function docWritten() {
                  if (++numDone < docs.length) {
                    nextDoc();
                  } else {
                    checkAllDocsDone();
                  }
                }
                function nextDoc() {
                  var value = docs[numDone];
                  var currentDoc = value[0];
                  var resultsIdx = value[1];
                  if (fetchedDocs.has(id)) {
                    updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results, resultsIdx, docWritten, writeDoc, newEdits);
                  } else {
                    var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);
                    currentDoc.metadata.rev_tree = merged.tree;
                    currentDoc.stemmedRevs = merged.stemmedRevs || [];
                    insertDoc(currentDoc, resultsIdx, docWritten);
                  }
                }
                nextDoc();
              });
            }
            var ADAPTER_VERSION = 5;
            var DOC_STORE = 'document-store';
            var BY_SEQ_STORE = 'by-sequence';
            var ATTACH_STORE = 'attach-store';
            var ATTACH_AND_SEQ_STORE = 'attach-seq-store';
            var META_STORE = 'meta-store';
            var LOCAL_STORE = 'local-store';
            var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';
            function safeJsonParse(str) {
              try {
                return JSON.parse(str);
              } catch (e) {
                return vuvuzela.parse(str);
              }
            }
            function safeJsonStringify(json) {
              try {
                return JSON.stringify(json);
              } catch (e) {
                return vuvuzela.stringify(json);
              }
            }
            function idbError(callback) {
              return function (evt) {
                var message = 'unknown_error';
                if (evt.target && evt.target.error) {
                  message = evt.target.error.name || evt.target.error.message;
                }
                callback(createError(IDB_ERROR, message, evt.type));
              };
            }
            function encodeMetadata(metadata, winningRev, deleted) {
              return {
                data: safeJsonStringify(metadata),
                winningRev: winningRev,
                deletedOrLocal: deleted ? '1' : '0',
                seq: metadata.seq,
                id: metadata.id
              };
            }
            function decodeMetadata(storedObject) {
              if (!storedObject) {
                return null;
              }
              var metadata = safeJsonParse(storedObject.data);
              metadata.winningRev = storedObject.winningRev;
              metadata.deleted = storedObject.deletedOrLocal === '1';
              metadata.seq = storedObject.seq;
              return metadata;
            }
            function decodeDoc(doc) {
              if (!doc) {
                return doc;
              }
              var idx = doc._doc_id_rev.lastIndexOf(':');
              doc._id = doc._doc_id_rev.substring(0, idx - 1);
              doc._rev = doc._doc_id_rev.substring(idx + 1);
              delete doc._doc_id_rev;
              return doc;
            }
            function readBlobData(body, type, asBlob, callback) {
              if (asBlob) {
                if (!body) {
                  callback(createBlob([''], { type: type }));
                } else if (typeof body !== 'string') {
                  callback(body);
                } else {
                  callback(b64ToBluffer(body, type));
                }
              } else {
                if (!body) {
                  callback('');
                } else if (typeof body !== 'string') {
                  readAsBinaryString(body, function (binary) {
                    callback(thisBtoa(binary));
                  });
                } else {
                  callback(body);
                }
              }
            }
            function fetchAttachmentsIfNecessary(doc, opts, txn, cb) {
              var attachments = Object.keys(doc._attachments || {});
              if (!attachments.length) {
                return cb && cb();
              }
              var numDone = 0;
              function checkDone() {
                if (++numDone === attachments.length && cb) {
                  cb();
                }
              }
              function fetchAttachment(doc, att) {
                var attObj = doc._attachments[att];
                var digest = attObj.digest;
                var req = txn.objectStore(ATTACH_STORE).get(digest);
                req.onsuccess = function (e) {
                  attObj.body = e.target.result.body;
                  checkDone();
                };
              }
              attachments.forEach(function (att) {
                if (opts.attachments && opts.include_docs) {
                  fetchAttachment(doc, att);
                } else {
                  doc._attachments[att].stub = true;
                  checkDone();
                }
              });
            }
            function postProcessAttachments(results, asBlob) {
              return PouchPromise$1.all(results.map(function (row) {
                if (row.doc && row.doc._attachments) {
                  var attNames = Object.keys(row.doc._attachments);
                  return PouchPromise$1.all(attNames.map(function (att) {
                    var attObj = row.doc._attachments[att];
                    if (!('body' in attObj)) {
                      return;
                    }
                    var body = attObj.body;
                    var type = attObj.content_type;
                    return new PouchPromise$1(function (resolve) {
                      readBlobData(body, type, asBlob, function (data) {
                        row.doc._attachments[att] = $inject_Object_assign(pick(attObj, ['digest', 'content_type']), { data: data });
                        resolve();
                      });
                    });
                  }));
                }
              }));
            }
            function compactRevs(revs, docId, txn) {
              var possiblyOrphanedDigests = [];
              var seqStore = txn.objectStore(BY_SEQ_STORE);
              var attStore = txn.objectStore(ATTACH_STORE);
              var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
              var count = revs.length;
              function checkDone() {
                count--;
                if (!count) {
                  deleteOrphanedAttachments();
                }
              }
              function deleteOrphanedAttachments() {
                if (!possiblyOrphanedDigests.length) {
                  return;
                }
                possiblyOrphanedDigests.forEach(function (digest) {
                  var countReq = attAndSeqStore.index('digestSeq').count(IDBKeyRange.bound(digest + '::', digest + '::\uffff', false, false));
                  countReq.onsuccess = function (e) {
                    var count = e.target.result;
                    if (!count) {
                      attStore["delete"](digest);
                    }
                  };
                });
              }
              revs.forEach(function (rev$$1) {
                var index = seqStore.index('_doc_id_rev');
                var key = docId + "::" + rev$$1;
                index.getKey(key).onsuccess = function (e) {
                  var seq = e.target.result;
                  if (typeof seq !== 'number') {
                    return checkDone();
                  }
                  seqStore["delete"](seq);
                  var cursor = attAndSeqStore.index('seq').openCursor(IDBKeyRange.only(seq));
                  cursor.onsuccess = function (event) {
                    var cursor = event.target.result;
                    if (cursor) {
                      var digest = cursor.value.digestSeq.split('::')[0];
                      possiblyOrphanedDigests.push(digest);
                      attAndSeqStore["delete"](cursor.primaryKey);
                      cursor["continue"]();
                    } else {
                      checkDone();
                    }
                  };
                };
              });
            }
            function openTransactionSafely(idb, stores, mode) {
              try {
                return { txn: idb.transaction(stores, mode) };
              } catch (err) {
                return { error: err };
              }
            }
            var changesHandler = new Changes();
            function idbBulkDocs(dbOpts, req, opts, api, idb, callback) {
              var docInfos = req.docs;
              var txn;
              var docStore;
              var bySeqStore;
              var attachStore;
              var attachAndSeqStore;
              var metaStore;
              var docInfoError;
              var metaDoc;
              for (var i = 0, len = docInfos.length; i < len; i++) {
                var doc = docInfos[i];
                if (doc._id && isLocalId(doc._id)) {
                  continue;
                }
                doc = docInfos[i] = parseDoc(doc, opts.new_edits);
                if (doc.error && !docInfoError) {
                  docInfoError = doc;
                }
              }
              if (docInfoError) {
                return callback(docInfoError);
              }
              var allDocsProcessed = false;
              var docCountDelta = 0;
              var results = new Array(docInfos.length);
              var fetchedDocs = new ExportedMap();
              var preconditionErrored = false;
              var blobType = api._meta.blobSupport ? 'blob' : 'base64';
              preprocessAttachments(docInfos, blobType, function (err) {
                if (err) {
                  return callback(err);
                }
                startTransaction();
              });
              function startTransaction() {
                var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, LOCAL_STORE, ATTACH_AND_SEQ_STORE, META_STORE];
                var txnResult = openTransactionSafely(idb, stores, 'readwrite');
                if (txnResult.error) {
                  return callback(txnResult.error);
                }
                txn = txnResult.txn;
                txn.onabort = idbError(callback);
                txn.ontimeout = idbError(callback);
                txn.oncomplete = complete;
                docStore = txn.objectStore(DOC_STORE);
                bySeqStore = txn.objectStore(BY_SEQ_STORE);
                attachStore = txn.objectStore(ATTACH_STORE);
                attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
                metaStore = txn.objectStore(META_STORE);
                metaStore.get(META_STORE).onsuccess = function (e) {
                  metaDoc = e.target.result;
                  updateDocCountIfReady();
                };
                verifyAttachments(function (err) {
                  if (err) {
                    preconditionErrored = true;
                    return callback(err);
                  }
                  fetchExistingDocs();
                });
              }
              function onAllDocsProcessed() {
                allDocsProcessed = true;
                updateDocCountIfReady();
              }
              function idbProcessDocs() {
                processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, txn, results, writeDoc, opts, onAllDocsProcessed);
              }
              function updateDocCountIfReady() {
                if (!metaDoc || !allDocsProcessed) {
                  return;
                }
                metaDoc.docCount += docCountDelta;
                metaStore.put(metaDoc);
              }
              function fetchExistingDocs() {
                if (!docInfos.length) {
                  return;
                }
                var numFetched = 0;
                function checkDone() {
                  if (++numFetched === docInfos.length) {
                    idbProcessDocs();
                  }
                }
                function readMetadata(event) {
                  var metadata = decodeMetadata(event.target.result);
                  if (metadata) {
                    fetchedDocs.set(metadata.id, metadata);
                  }
                  checkDone();
                }
                for (var i = 0, len = docInfos.length; i < len; i++) {
                  var docInfo = docInfos[i];
                  if (docInfo._id && isLocalId(docInfo._id)) {
                    checkDone();
                    continue;
                  }
                  var req = docStore.get(docInfo.metadata.id);
                  req.onsuccess = readMetadata;
                }
              }
              function complete() {
                if (preconditionErrored) {
                  return;
                }
                changesHandler.notify(api._meta.name);
                callback(null, results);
              }
              function verifyAttachment(digest, callback) {
                var req = attachStore.get(digest);
                req.onsuccess = function (e) {
                  if (!e.target.result) {
                    var err = createError(MISSING_STUB, 'unknown stub attachment with digest ' + digest);
                    err.status = 412;
                    callback(err);
                  } else {
                    callback();
                  }
                };
              }
              function verifyAttachments(finish) {
                var digests = [];
                docInfos.forEach(function (docInfo) {
                  if (docInfo.data && docInfo.data._attachments) {
                    Object.keys(docInfo.data._attachments).forEach(function (filename) {
                      var att = docInfo.data._attachments[filename];
                      if (att.stub) {
                        digests.push(att.digest);
                      }
                    });
                  }
                });
                if (!digests.length) {
                  return finish();
                }
                var numDone = 0;
                var err;
                function checkDone() {
                  if (++numDone === digests.length) {
                    finish(err);
                  }
                }
                digests.forEach(function (digest) {
                  verifyAttachment(digest, function (attErr) {
                    if (attErr && !err) {
                      err = attErr;
                    }
                    checkDone();
                  });
                });
              }
              function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, isUpdate, delta, resultsIdx, callback) {
                docInfo.metadata.winningRev = winningRev$$1;
                docInfo.metadata.deleted = winningRevIsDeleted;
                var doc = docInfo.data;
                doc._id = docInfo.metadata.id;
                doc._rev = docInfo.metadata.rev;
                if (newRevIsDeleted) {
                  doc._deleted = true;
                }
                var hasAttachments = doc._attachments && Object.keys(doc._attachments).length;
                if (hasAttachments) {
                  return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);
                }
                docCountDelta += delta;
                updateDocCountIfReady();
                finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);
              }
              function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {
                var doc = docInfo.data;
                var metadata = docInfo.metadata;
                doc._doc_id_rev = metadata.id + '::' + metadata.rev;
                delete doc._id;
                delete doc._rev;
                function afterPutDoc(e) {
                  var revsToDelete = docInfo.stemmedRevs || [];
                  if (isUpdate && api.auto_compaction) {
                    revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));
                  }
                  if (revsToDelete && revsToDelete.length) {
                    compactRevs(revsToDelete, docInfo.metadata.id, txn);
                  }
                  metadata.seq = e.target.result;
                  var metadataToStore = encodeMetadata(metadata, winningRev$$1, winningRevIsDeleted);
                  var metaDataReq = docStore.put(metadataToStore);
                  metaDataReq.onsuccess = afterPutMetadata;
                }
                function afterPutDocError(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  var index = bySeqStore.index('_doc_id_rev');
                  var getKeyReq = index.getKey(doc._doc_id_rev);
                  getKeyReq.onsuccess = function (e) {
                    var putReq = bySeqStore.put(doc, e.target.result);
                    putReq.onsuccess = afterPutDoc;
                  };
                }
                function afterPutMetadata() {
                  results[resultsIdx] = {
                    ok: true,
                    id: metadata.id,
                    rev: metadata.rev
                  };
                  fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);
                  insertAttachmentMappings(docInfo, metadata.seq, callback);
                }
                var putReq = bySeqStore.put(doc);
                putReq.onsuccess = afterPutDoc;
                putReq.onerror = afterPutDocError;
              }
              function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback) {
                var doc = docInfo.data;
                var numDone = 0;
                var attachments = Object.keys(doc._attachments);
                function collectResults() {
                  if (numDone === attachments.length) {
                    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted, isUpdate, resultsIdx, callback);
                  }
                }
                function attachmentSaved() {
                  numDone++;
                  collectResults();
                }
                attachments.forEach(function (key) {
                  var att = docInfo.data._attachments[key];
                  if (!att.stub) {
                    var data = att.data;
                    delete att.data;
                    att.revpos = parseInt(winningRev$$1, 10);
                    var digest = att.digest;
                    saveAttachment(digest, data, attachmentSaved);
                  } else {
                    numDone++;
                    collectResults();
                  }
                });
              }
              function insertAttachmentMappings(docInfo, seq, callback) {
                var attsAdded = 0;
                var attsToAdd = Object.keys(docInfo.data._attachments || {});
                if (!attsToAdd.length) {
                  return callback();
                }
                function checkDone() {
                  if (++attsAdded === attsToAdd.length) {
                    callback();
                  }
                }
                function add(att) {
                  var digest = docInfo.data._attachments[att].digest;
                  var req = attachAndSeqStore.put({
                    seq: seq,
                    digestSeq: digest + '::' + seq
                  });
                  req.onsuccess = checkDone;
                  req.onerror = function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    checkDone();
                  };
                }
                for (var i = 0; i < attsToAdd.length; i++) {
                  add(attsToAdd[i]);
                }
              }
              function saveAttachment(digest, data, callback) {
                var getKeyReq = attachStore.count(digest);
                getKeyReq.onsuccess = function (e) {
                  var count = e.target.result;
                  if (count) {
                    return callback();
                  }
                  var newAtt = {
                    digest: digest,
                    body: data
                  };
                  var putReq = attachStore.put(newAtt);
                  putReq.onsuccess = callback;
                };
              }
            }
            function runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {
              var useGetAll = typeof objectStore.getAll === 'function' && typeof objectStore.getAllKeys === 'function' && batchSize > 1 && !descending;
              var keysBatch;
              var valuesBatch;
              var pseudoCursor;
              function onGetAll(e) {
                valuesBatch = e.target.result;
                if (keysBatch) {
                  onBatch(keysBatch, valuesBatch, pseudoCursor);
                }
              }
              function onGetAllKeys(e) {
                keysBatch = e.target.result;
                if (valuesBatch) {
                  onBatch(keysBatch, valuesBatch, pseudoCursor);
                }
              }
              function continuePseudoCursor() {
                if (!keysBatch.length) {
                  return onBatch();
                }
                var lastKey = keysBatch[keysBatch.length - 1];
                var newKeyRange;
                if (keyRange && keyRange.upper) {
                  try {
                    newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper, true, keyRange.upperOpen);
                  } catch (e) {
                    if (e.name === "DataError" && e.code === 0) {
                      return onBatch();
                    }
                  }
                } else {
                  newKeyRange = IDBKeyRange.lowerBound(lastKey, true);
                }
                keyRange = newKeyRange;
                keysBatch = null;
                valuesBatch = null;
                objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
                objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
              }
              function onCursor(e) {
                var cursor = e.target.result;
                if (!cursor) {
                  return onBatch();
                }
                onBatch([cursor.key], [cursor.value], cursor);
              }
              if (useGetAll) {
                pseudoCursor = { "continue": continuePseudoCursor };
                objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;
                objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;
              } else if (descending) {
                objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;
              } else {
                objectStore.openCursor(keyRange).onsuccess = onCursor;
              }
            }
            function getAll(objectStore, keyRange, onSuccess) {
              if (typeof objectStore.getAll === 'function') {
                objectStore.getAll(keyRange).onsuccess = onSuccess;
                return;
              }
              var values = [];
              function onCursor(e) {
                var cursor = e.target.result;
                if (cursor) {
                  values.push(cursor.value);
                  cursor["continue"]();
                } else {
                  onSuccess({ target: { result: values } });
                }
              }
              objectStore.openCursor(keyRange).onsuccess = onCursor;
            }
            function createKeyRange(start, end, inclusiveEnd, key, descending) {
              try {
                if (start && end) {
                  if (descending) {
                    return IDBKeyRange.bound(end, start, !inclusiveEnd, false);
                  } else {
                    return IDBKeyRange.bound(start, end, false, !inclusiveEnd);
                  }
                } else if (start) {
                  if (descending) {
                    return IDBKeyRange.upperBound(start);
                  } else {
                    return IDBKeyRange.lowerBound(start);
                  }
                } else if (end) {
                  if (descending) {
                    return IDBKeyRange.lowerBound(end, !inclusiveEnd);
                  } else {
                    return IDBKeyRange.upperBound(end, !inclusiveEnd);
                  }
                } else if (key) {
                  return IDBKeyRange.only(key);
                }
              } catch (e) {
                return { error: e };
              }
              return null;
            }
            function idbAllDocs(opts, idb, callback) {
              var start = 'startkey' in opts ? opts.startkey : false;
              var end = 'endkey' in opts ? opts.endkey : false;
              var key = 'key' in opts ? opts.key : false;
              var skip = opts.skip || 0;
              var limit = typeof opts.limit === 'number' ? opts.limit : -1;
              var inclusiveEnd = opts.inclusive_end !== false;
              var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);
              var keyRangeError = keyRange && keyRange.error;
              if (keyRangeError && !(keyRangeError.name === "DataError" && keyRangeError.code === 0)) {
                return callback(createError(IDB_ERROR, keyRangeError.name, keyRangeError.message));
              }
              var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];
              if (opts.attachments) {
                stores.push(ATTACH_STORE);
              }
              var txnResult = openTransactionSafely(idb, stores, 'readonly');
              if (txnResult.error) {
                return callback(txnResult.error);
              }
              var txn = txnResult.txn;
              txn.oncomplete = onTxnComplete;
              txn.onabort = idbError(callback);
              var docStore = txn.objectStore(DOC_STORE);
              var seqStore = txn.objectStore(BY_SEQ_STORE);
              var metaStore = txn.objectStore(META_STORE);
              var docIdRevIndex = seqStore.index('_doc_id_rev');
              var results = [];
              var docCount;
              metaStore.get(META_STORE).onsuccess = function (e) {
                docCount = e.target.result.docCount;
              };
              function fetchDocAsynchronously(metadata, row, winningRev$$1) {
                var key = metadata.id + "::" + winningRev$$1;
                docIdRevIndex.get(key).onsuccess = function onGetDoc(e) {
                  row.doc = decodeDoc(e.target.result);
                  if (opts.conflicts) {
                    var conflicts = collectConflicts(metadata);
                    if (conflicts.length) {
                      row.doc._conflicts = conflicts;
                    }
                  }
                  fetchAttachmentsIfNecessary(row.doc, opts, txn);
                };
              }
              function allDocsInner(winningRev$$1, metadata) {
                var row = {
                  id: metadata.id,
                  key: metadata.id,
                  value: { rev: winningRev$$1 }
                };
                var deleted = metadata.deleted;
                if (opts.deleted === 'ok') {
                  results.push(row);
                  if (deleted) {
                    row.value.deleted = true;
                    row.doc = null;
                  } else if (opts.include_docs) {
                    fetchDocAsynchronously(metadata, row, winningRev$$1);
                  }
                } else if (!deleted && skip-- <= 0) {
                  results.push(row);
                  if (opts.include_docs) {
                    fetchDocAsynchronously(metadata, row, winningRev$$1);
                  }
                }
              }
              function processBatch(batchValues) {
                for (var i = 0, len = batchValues.length; i < len; i++) {
                  if (results.length === limit) {
                    break;
                  }
                  var batchValue = batchValues[i];
                  var metadata = decodeMetadata(batchValue);
                  var winningRev$$1 = metadata.winningRev;
                  allDocsInner(winningRev$$1, metadata);
                }
              }
              function onBatch(batchKeys, batchValues, cursor) {
                if (!cursor) {
                  return;
                }
                processBatch(batchValues);
                if (results.length < limit) {
                  cursor["continue"]();
                }
              }
              function onGetAll(e) {
                var values = e.target.result;
                if (opts.descending) {
                  values = values.reverse();
                }
                processBatch(values);
              }
              function onResultsReady() {
                callback(null, {
                  total_rows: docCount,
                  offset: opts.skip,
                  rows: results
                });
              }
              function onTxnComplete() {
                if (opts.attachments) {
                  postProcessAttachments(results, opts.binary).then(onResultsReady);
                } else {
                  onResultsReady();
                }
              }
              if (keyRangeError || limit === 0) {
                return;
              }
              if (limit === -1) {
                return getAll(docStore, keyRange, onGetAll);
              }
              runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);
            }
            function checkBlobSupport(txn) {
              return new PouchPromise$1(function (resolve) {
                var blob = createBlob(['']);
                var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
                req.onsuccess = function () {
                  var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                  var matchedEdge = navigator.userAgent.match(/Edge\//);
                  resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
                };
                txn.onabort = function (e) {
                  e.preventDefault();
                  e.stopPropagation();
                  resolve(false);
                };
              })["catch"](function () {
                return false;
              });
            }
            function countDocs(txn, cb) {
              var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');
              index.count(IDBKeyRange.only('0')).onsuccess = function (e) {
                cb(e.target.result);
              };
            }
            var running = false;
            var queue = [];
            function tryCode(fun, err, res, PouchDB) {
              try {
                fun(err, res);
              } catch (err) {
                PouchDB.emit('error', err);
              }
            }
            function applyNext() {
              if (running || !queue.length) {
                return;
              }
              running = true;
              queue.shift()();
            }
            function enqueueTask(action, callback, PouchDB) {
              queue.push(function runAction() {
                action(function runCallback(err, res) {
                  tryCode(callback, err, res, PouchDB);
                  running = false;
                  nextTick(function runNext() {
                    applyNext(PouchDB);
                  });
                });
              });
              applyNext();
            }
            function changes(opts, api, dbName, idb) {
              opts = clone(opts);
              if (opts.continuous) {
                var id = dbName + ':' + uuid();
                changesHandler.addListener(dbName, id, api, opts);
                changesHandler.notify(dbName);
                return { cancel: function () {
                    changesHandler.removeListener(dbName, id);
                  } };
              }
              var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);
              opts.since = opts.since || 0;
              var lastSeq = opts.since;
              var limit = 'limit' in opts ? opts.limit : -1;
              if (limit === 0) {
                limit = 1;
              }
              var returnDocs;
              if ('return_docs' in opts) {
                returnDocs = opts.return_docs;
              } else if ('returnDocs' in opts) {
                returnDocs = opts.returnDocs;
              } else {
                returnDocs = true;
              }
              var results = [];
              var numResults = 0;
              var filter = filterChange(opts);
              var docIdsToMetadata = new ExportedMap();
              var txn;
              var bySeqStore;
              var docStore;
              var docIdRevIndex;
              function onBatch(batchKeys, batchValues, cursor) {
                if (!cursor || !batchKeys.length) {
                  return;
                }
                var winningDocs = new Array(batchKeys.length);
                var metadatas = new Array(batchKeys.length);
                function processMetadataAndWinningDoc(metadata, winningDoc) {
                  var change = opts.processChange(winningDoc, metadata, opts);
                  lastSeq = change.seq = metadata.seq;
                  var filtered = filter(change);
                  if (typeof filtered === 'object') {
                    return opts.complete(filtered);
                  }
                  if (filtered) {
                    numResults++;
                    if (returnDocs) {
                      results.push(change);
                    }
                    if (opts.attachments && opts.include_docs) {
                      fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {
                        postProcessAttachments([change], opts.binary).then(function () {
                          opts.onChange(change);
                        });
                      });
                    } else {
                      opts.onChange(change);
                    }
                  }
                }
                function onBatchDone() {
                  for (var i = 0, len = winningDocs.length; i < len; i++) {
                    if (numResults === limit) {
                      break;
                    }
                    var winningDoc = winningDocs[i];
                    if (!winningDoc) {
                      continue;
                    }
                    var metadata = metadatas[i];
                    processMetadataAndWinningDoc(metadata, winningDoc);
                  }
                  if (numResults !== limit) {
                    cursor["continue"]();
                  }
                }
                var numDone = 0;
                batchValues.forEach(function (value, i) {
                  var doc = decodeDoc(value);
                  var seq = batchKeys[i];
                  fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {
                    metadatas[i] = metadata;
                    winningDocs[i] = winningDoc;
                    if (++numDone === batchKeys.length) {
                      onBatchDone();
                    }
                  });
                });
              }
              function onGetMetadata(doc, seq, metadata, cb) {
                if (metadata.seq !== seq) {
                  return cb();
                }
                if (metadata.winningRev === doc._rev) {
                  return cb(metadata, doc);
                }
                var docIdRev = doc._id + '::' + metadata.winningRev;
                var req = docIdRevIndex.get(docIdRev);
                req.onsuccess = function (e) {
                  cb(metadata, decodeDoc(e.target.result));
                };
              }
              function fetchWinningDocAndMetadata(doc, seq, cb) {
                if (docIds && !docIds.has(doc._id)) {
                  return cb();
                }
                var metadata = docIdsToMetadata.get(doc._id);
                if (metadata) {
                  return onGetMetadata(doc, seq, metadata, cb);
                }
                docStore.get(doc._id).onsuccess = function (e) {
                  metadata = decodeMetadata(e.target.result);
                  docIdsToMetadata.set(doc._id, metadata);
                  onGetMetadata(doc, seq, metadata, cb);
                };
              }
              function finish() {
                opts.complete(null, {
                  results: results,
                  last_seq: lastSeq
                });
              }
              function onTxnComplete() {
                if (!opts.continuous && opts.attachments) {
                  postProcessAttachments(results).then(finish);
                } else {
                  finish();
                }
              }
              var objectStores = [DOC_STORE, BY_SEQ_STORE];
              if (opts.attachments) {
                objectStores.push(ATTACH_STORE);
              }
              var txnResult = openTransactionSafely(idb, objectStores, 'readonly');
              if (txnResult.error) {
                return opts.complete(txnResult.error);
              }
              txn = txnResult.txn;
              txn.onabort = idbError(opts.complete);
              txn.oncomplete = onTxnComplete;
              bySeqStore = txn.objectStore(BY_SEQ_STORE);
              docStore = txn.objectStore(DOC_STORE);
              docIdRevIndex = bySeqStore.index('_doc_id_rev');
              var keyRange = opts.since && !opts.descending ? IDBKeyRange.lowerBound(opts.since, true) : null;
              runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);
            }
            var cachedDBs = new ExportedMap();
            var blobSupportPromise;
            var openReqList = new ExportedMap();
            function IdbPouch(opts, callback) {
              var api = this;
              enqueueTask(function (thisCallback) {
                init(api, opts, thisCallback);
              }, callback, api.constructor);
            }
            function init(api, opts, callback) {
              var dbName = opts.name;
              var idb = null;
              api._meta = null;
              function createSchema(db) {
                var docStore = db.createObjectStore(DOC_STORE, { keyPath: 'id' });
                db.createObjectStore(BY_SEQ_STORE, { autoIncrement: true }).createIndex('_doc_id_rev', '_doc_id_rev', { unique: true });
                db.createObjectStore(ATTACH_STORE, { keyPath: 'digest' });
                db.createObjectStore(META_STORE, {
                  keyPath: 'id',
                  autoIncrement: false
                });
                db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                docStore.createIndex('deletedOrLocal', 'deletedOrLocal', { unique: false });
                db.createObjectStore(LOCAL_STORE, { keyPath: '_id' });
                var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, { autoIncrement: true });
                attAndSeqStore.createIndex('seq', 'seq');
                attAndSeqStore.createIndex('digestSeq', 'digestSeq', { unique: true });
              }
              function addDeletedOrLocalIndex(txn, callback) {
                var docStore = txn.objectStore(DOC_STORE);
                docStore.createIndex('deletedOrLocal', 'deletedOrLocal', { unique: false });
                docStore.openCursor().onsuccess = function (event) {
                  var cursor = event.target.result;
                  if (cursor) {
                    var metadata = cursor.value;
                    var deleted = isDeleted(metadata);
                    metadata.deletedOrLocal = deleted ? "1" : "0";
                    docStore.put(metadata);
                    cursor["continue"]();
                  } else {
                    callback();
                  }
                };
              }
              function createLocalStoreSchema(db) {
                db.createObjectStore(LOCAL_STORE, { keyPath: '_id' }).createIndex('_doc_id_rev', '_doc_id_rev', { unique: true });
              }
              function migrateLocalStore(txn, cb) {
                var localStore = txn.objectStore(LOCAL_STORE);
                var docStore = txn.objectStore(DOC_STORE);
                var seqStore = txn.objectStore(BY_SEQ_STORE);
                var cursor = docStore.openCursor();
                cursor.onsuccess = function (event) {
                  var cursor = event.target.result;
                  if (cursor) {
                    var metadata = cursor.value;
                    var docId = metadata.id;
                    var local = isLocalId(docId);
                    var rev$$1 = winningRev(metadata);
                    if (local) {
                      var docIdRev = docId + "::" + rev$$1;
                      var start = docId + "::";
                      var end = docId + "::~";
                      var index = seqStore.index('_doc_id_rev');
                      var range = IDBKeyRange.bound(start, end, false, false);
                      var seqCursor = index.openCursor(range);
                      seqCursor.onsuccess = function (e) {
                        seqCursor = e.target.result;
                        if (!seqCursor) {
                          docStore["delete"](cursor.primaryKey);
                          cursor["continue"]();
                        } else {
                          var data = seqCursor.value;
                          if (data._doc_id_rev === docIdRev) {
                            localStore.put(data);
                          }
                          seqStore["delete"](seqCursor.primaryKey);
                          seqCursor["continue"]();
                        }
                      };
                    } else {
                      cursor["continue"]();
                    }
                  } else if (cb) {
                    cb();
                  }
                };
              }
              function addAttachAndSeqStore(db) {
                var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE, { autoIncrement: true });
                attAndSeqStore.createIndex('seq', 'seq');
                attAndSeqStore.createIndex('digestSeq', 'digestSeq', { unique: true });
              }
              function migrateAttsAndSeqs(txn, callback) {
                var seqStore = txn.objectStore(BY_SEQ_STORE);
                var attStore = txn.objectStore(ATTACH_STORE);
                var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);
                var req = attStore.count();
                req.onsuccess = function (e) {
                  var count = e.target.result;
                  if (!count) {
                    return callback();
                  }
                  seqStore.openCursor().onsuccess = function (e) {
                    var cursor = e.target.result;
                    if (!cursor) {
                      return callback();
                    }
                    var doc = cursor.value;
                    var seq = cursor.primaryKey;
                    var atts = Object.keys(doc._attachments || {});
                    var digestMap = {};
                    for (var j = 0; j < atts.length; j++) {
                      var att = doc._attachments[atts[j]];
                      digestMap[att.digest] = true;
                    }
                    var digests = Object.keys(digestMap);
                    for (j = 0; j < digests.length; j++) {
                      var digest = digests[j];
                      attAndSeqStore.put({
                        seq: seq,
                        digestSeq: digest + '::' + seq
                      });
                    }
                    cursor["continue"]();
                  };
                };
              }
              function migrateMetadata(txn) {
                function decodeMetadataCompat(storedObject) {
                  if (!storedObject.data) {
                    storedObject.deleted = storedObject.deletedOrLocal === '1';
                    return storedObject;
                  }
                  return decodeMetadata(storedObject);
                }
                var bySeqStore = txn.objectStore(BY_SEQ_STORE);
                var docStore = txn.objectStore(DOC_STORE);
                var cursor = docStore.openCursor();
                cursor.onsuccess = function (e) {
                  var cursor = e.target.result;
                  if (!cursor) {
                    return;
                  }
                  var metadata = decodeMetadataCompat(cursor.value);
                  metadata.winningRev = metadata.winningRev || winningRev(metadata);
                  function fetchMetadataSeq() {
                    var start = metadata.id + '::';
                    var end = metadata.id + '::\uffff';
                    var req = bySeqStore.index('_doc_id_rev').openCursor(IDBKeyRange.bound(start, end));
                    var metadataSeq = 0;
                    req.onsuccess = function (e) {
                      var cursor = e.target.result;
                      if (!cursor) {
                        metadata.seq = metadataSeq;
                        return onGetMetadataSeq();
                      }
                      var seq = cursor.primaryKey;
                      if (seq > metadataSeq) {
                        metadataSeq = seq;
                      }
                      cursor["continue"]();
                    };
                  }
                  function onGetMetadataSeq() {
                    var metadataToStore = encodeMetadata(metadata, metadata.winningRev, metadata.deleted);
                    var req = docStore.put(metadataToStore);
                    req.onsuccess = function () {
                      cursor["continue"]();
                    };
                  }
                  if (metadata.seq) {
                    return onGetMetadataSeq();
                  }
                  fetchMetadataSeq();
                };
              }
              api._remote = false;
              api.type = function () {
                return 'idb';
              };
              api._id = toPromise(function (callback) {
                callback(null, api._meta.instanceId);
              });
              api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {
                idbBulkDocs(opts, req, reqOpts, api, idb, callback);
              };
              api._get = function idb_get(id, opts, callback) {
                var doc;
                var metadata;
                var err;
                var txn = opts.ctx;
                if (!txn) {
                  var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
                  if (txnResult.error) {
                    return callback(txnResult.error);
                  }
                  txn = txnResult.txn;
                }
                function finish() {
                  callback(err, {
                    doc: doc,
                    metadata: metadata,
                    ctx: txn
                  });
                }
                txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {
                  metadata = decodeMetadata(e.target.result);
                  if (!metadata) {
                    err = createError(MISSING_DOC, 'missing');
                    return finish();
                  }
                  var rev$$1;
                  if (!opts.rev) {
                    rev$$1 = metadata.winningRev;
                    var deleted = isDeleted(metadata);
                    if (deleted) {
                      err = createError(MISSING_DOC, "deleted");
                      return finish();
                    }
                  } else {
                    rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;
                  }
                  var objectStore = txn.objectStore(BY_SEQ_STORE);
                  var key = metadata.id + '::' + rev$$1;
                  objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {
                    doc = e.target.result;
                    if (doc) {
                      doc = decodeDoc(doc);
                    }
                    if (!doc) {
                      err = createError(MISSING_DOC, 'missing');
                      return finish();
                    }
                    finish();
                  };
                };
              };
              api._getAttachment = function (docId, attachId, attachment, opts, callback) {
                var txn;
                if (opts.ctx) {
                  txn = opts.ctx;
                } else {
                  var txnResult = openTransactionSafely(idb, [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');
                  if (txnResult.error) {
                    return callback(txnResult.error);
                  }
                  txn = txnResult.txn;
                }
                var digest = attachment.digest;
                var type = attachment.content_type;
                txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {
                  var body = e.target.result.body;
                  readBlobData(body, type, opts.binary, function (blobData) {
                    callback(null, blobData);
                  });
                };
              };
              api._info = function idb_info(callback) {
                var updateSeq;
                var docCount;
                var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');
                if (txnResult.error) {
                  return callback(txnResult.error);
                }
                var txn = txnResult.txn;
                txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
                  docCount = e.target.result.docCount;
                };
                txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {
                  var cursor = e.target.result;
                  updateSeq = cursor ? cursor.key : 0;
                };
                txn.oncomplete = function () {
                  callback(null, {
                    doc_count: docCount,
                    update_seq: updateSeq,
                    idb_attachment_format: api._meta.blobSupport ? 'binary' : 'base64'
                  });
                };
              };
              api._allDocs = function idb_allDocs(opts, callback) {
                idbAllDocs(opts, idb, callback);
              };
              api._changes = function idbChanges(opts) {
                return changes(opts, api, dbName, idb);
              };
              api._close = function (callback) {
                idb.close();
                cachedDBs["delete"](dbName);
                callback();
              };
              api._getRevisionTree = function (docId, callback) {
                var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');
                if (txnResult.error) {
                  return callback(txnResult.error);
                }
                var txn = txnResult.txn;
                var req = txn.objectStore(DOC_STORE).get(docId);
                req.onsuccess = function (event) {
                  var doc = decodeMetadata(event.target.result);
                  if (!doc) {
                    callback(createError(MISSING_DOC));
                  } else {
                    callback(null, doc.rev_tree);
                  }
                };
              };
              api._doCompaction = function (docId, revs, callback) {
                var stores = [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, ATTACH_AND_SEQ_STORE];
                var txnResult = openTransactionSafely(idb, stores, 'readwrite');
                if (txnResult.error) {
                  return callback(txnResult.error);
                }
                var txn = txnResult.txn;
                var docStore = txn.objectStore(DOC_STORE);
                docStore.get(docId).onsuccess = function (event) {
                  var metadata = decodeMetadata(event.target.result);
                  traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {
                    var rev$$1 = pos + '-' + revHash;
                    if (revs.indexOf(rev$$1) !== -1) {
                      opts.status = 'missing';
                    }
                  });
                  compactRevs(revs, docId, txn);
                  var winningRev$$1 = metadata.winningRev;
                  var deleted = metadata.deleted;
                  txn.objectStore(DOC_STORE).put(encodeMetadata(metadata, winningRev$$1, deleted));
                };
                txn.onabort = idbError(callback);
                txn.oncomplete = function () {
                  callback();
                };
              };
              api._getLocal = function (id, callback) {
                var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');
                if (txnResult.error) {
                  return callback(txnResult.error);
                }
                var tx = txnResult.txn;
                var req = tx.objectStore(LOCAL_STORE).get(id);
                req.onerror = idbError(callback);
                req.onsuccess = function (e) {
                  var doc = e.target.result;
                  if (!doc) {
                    callback(createError(MISSING_DOC));
                  } else {
                    delete doc['_doc_id_rev'];
                    callback(null, doc);
                  }
                };
              };
              api._putLocal = function (doc, opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                delete doc._revisions;
                var oldRev = doc._rev;
                var id = doc._id;
                if (!oldRev) {
                  doc._rev = '0-1';
                } else {
                  doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
                }
                var tx = opts.ctx;
                var ret;
                if (!tx) {
                  var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
                  if (txnResult.error) {
                    return callback(txnResult.error);
                  }
                  tx = txnResult.txn;
                  tx.onerror = idbError(callback);
                  tx.oncomplete = function () {
                    if (ret) {
                      callback(null, ret);
                    }
                  };
                }
                var oStore = tx.objectStore(LOCAL_STORE);
                var req;
                if (oldRev) {
                  req = oStore.get(id);
                  req.onsuccess = function (e) {
                    var oldDoc = e.target.result;
                    if (!oldDoc || oldDoc._rev !== oldRev) {
                      callback(createError(REV_CONFLICT));
                    } else {
                      var req = oStore.put(doc);
                      req.onsuccess = function () {
                        ret = {
                          ok: true,
                          id: doc._id,
                          rev: doc._rev
                        };
                        if (opts.ctx) {
                          callback(null, ret);
                        }
                      };
                    }
                  };
                } else {
                  req = oStore.add(doc);
                  req.onerror = function (e) {
                    callback(createError(REV_CONFLICT));
                    e.preventDefault();
                    e.stopPropagation();
                  };
                  req.onsuccess = function () {
                    ret = {
                      ok: true,
                      id: doc._id,
                      rev: doc._rev
                    };
                    if (opts.ctx) {
                      callback(null, ret);
                    }
                  };
                }
              };
              api._removeLocal = function (doc, opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                var tx = opts.ctx;
                if (!tx) {
                  var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');
                  if (txnResult.error) {
                    return callback(txnResult.error);
                  }
                  tx = txnResult.txn;
                  tx.oncomplete = function () {
                    if (ret) {
                      callback(null, ret);
                    }
                  };
                }
                var ret;
                var id = doc._id;
                var oStore = tx.objectStore(LOCAL_STORE);
                var req = oStore.get(id);
                req.onerror = idbError(callback);
                req.onsuccess = function (e) {
                  var oldDoc = e.target.result;
                  if (!oldDoc || oldDoc._rev !== doc._rev) {
                    callback(createError(MISSING_DOC));
                  } else {
                    oStore["delete"](id);
                    ret = {
                      ok: true,
                      id: id,
                      rev: '0-0'
                    };
                    if (opts.ctx) {
                      callback(null, ret);
                    }
                  }
                };
              };
              api._destroy = function (opts, callback) {
                changesHandler.removeAllListeners(dbName);
                var openReq = openReqList.get(dbName);
                if (openReq && openReq.result) {
                  openReq.result.close();
                  cachedDBs["delete"](dbName);
                }
                var req = indexedDB.deleteDatabase(dbName);
                req.onsuccess = function () {
                  openReqList["delete"](dbName);
                  if (hasLocalStorage() && dbName in localStorage) {
                    delete localStorage[dbName];
                  }
                  callback(null, { 'ok': true });
                };
                req.onerror = idbError(callback);
              };
              var cached = cachedDBs.get(dbName);
              if (cached) {
                idb = cached.idb;
                api._meta = cached.global;
                return nextTick(function () {
                  callback(null, api);
                });
              }
              var req;
              if (opts.storage) {
                req = tryStorageOption(dbName, opts.storage);
              } else {
                req = indexedDB.open(dbName, ADAPTER_VERSION);
              }
              openReqList.set(dbName, req);
              req.onupgradeneeded = function (e) {
                var db = e.target.result;
                if (e.oldVersion < 1) {
                  return createSchema(db);
                }
                var txn = e.currentTarget.transaction;
                if (e.oldVersion < 3) {
                  createLocalStoreSchema(db);
                }
                if (e.oldVersion < 4) {
                  addAttachAndSeqStore(db);
                }
                var migrations = [addDeletedOrLocalIndex, migrateLocalStore, migrateAttsAndSeqs, migrateMetadata];
                var i = e.oldVersion;
                function next() {
                  var migration = migrations[i - 1];
                  i++;
                  if (migration) {
                    migration(txn, next);
                  }
                }
                next();
              };
              req.onsuccess = function (e) {
                idb = e.target.result;
                idb.onversionchange = function () {
                  idb.close();
                  cachedDBs["delete"](dbName);
                };
                idb.onabort = function (e) {
                  guardedConsole('error', 'Database has a global failure', e.target.error);
                  idb.close();
                  cachedDBs["delete"](dbName);
                };
                var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE, DOC_STORE], 'readwrite');
                var storedMetaDoc = false;
                var metaDoc;
                var docCount;
                var blobSupport;
                var instanceId;
                function completeSetup() {
                  if (typeof blobSupport === 'undefined' || !storedMetaDoc) {
                    return;
                  }
                  api._meta = {
                    name: dbName,
                    instanceId: instanceId,
                    blobSupport: blobSupport
                  };
                  cachedDBs.set(dbName, {
                    idb: idb,
                    global: api._meta
                  });
                  callback(null, api);
                }
                function storeMetaDocIfReady() {
                  if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {
                    return;
                  }
                  var instanceKey = dbName + '_id';
                  if (instanceKey in metaDoc) {
                    instanceId = metaDoc[instanceKey];
                  } else {
                    metaDoc[instanceKey] = instanceId = uuid();
                  }
                  metaDoc.docCount = docCount;
                  txn.objectStore(META_STORE).put(metaDoc);
                }
                txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {
                  metaDoc = e.target.result || { id: META_STORE };
                  storeMetaDocIfReady();
                };
                countDocs(txn, function (count) {
                  docCount = count;
                  storeMetaDocIfReady();
                });
                if (!blobSupportPromise) {
                  blobSupportPromise = checkBlobSupport(txn);
                }
                blobSupportPromise.then(function (val) {
                  blobSupport = val;
                  completeSetup();
                });
                txn.oncomplete = function () {
                  storedMetaDoc = true;
                  completeSetup();
                };
              };
              req.onerror = function () {
                var msg = 'Failed to open indexedDB, are you in private browsing mode?';
                guardedConsole('error', msg);
                callback(createError(IDB_ERROR, msg));
              };
            }
            IdbPouch.valid = function () {
              var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
              return !isSafari && typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
            };
            function tryStorageOption(dbName, storage) {
              try {
                return indexedDB.open(dbName, {
                  version: ADAPTER_VERSION,
                  storage: storage
                });
              } catch (err) {
                return indexedDB.open(dbName, ADAPTER_VERSION);
              }
            }
            var IDBPouch = function (PouchDB) {
              PouchDB.adapter('idb', IdbPouch, true);
            };
            function decodeUtf8(str) {
              return decodeURIComponent(escape(str));
            }
            function hexToInt(charCode) {
              return charCode < 65 ? charCode - 48 : charCode - 55;
            }
            function parseHexUtf8(str, start, end) {
              var result = '';
              while (start < end) {
                result += String.fromCharCode(hexToInt(str.charCodeAt(start++)) << 4 | hexToInt(str.charCodeAt(start++)));
              }
              return result;
            }
            function parseHexUtf16(str, start, end) {
              var result = '';
              while (start < end) {
                result += String.fromCharCode(hexToInt(str.charCodeAt(start + 2)) << 12 | hexToInt(str.charCodeAt(start + 3)) << 8 | hexToInt(str.charCodeAt(start)) << 4 | hexToInt(str.charCodeAt(start + 1)));
                start += 4;
              }
              return result;
            }
            function parseHexString(str, encoding) {
              if (encoding === 'UTF-8') {
                return decodeUtf8(parseHexUtf8(str, 0, str.length));
              } else {
                return parseHexUtf16(str, 0, str.length);
              }
            }
            function quote(str) {
              return "'" + str + "'";
            }
            var ADAPTER_VERSION$1 = 7;
            var DOC_STORE$1 = quote('document-store');
            var BY_SEQ_STORE$1 = quote('by-sequence');
            var ATTACH_STORE$1 = quote('attach-store');
            var LOCAL_STORE$1 = quote('local-store');
            var META_STORE$1 = quote('metadata-store');
            var ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');
            function escapeBlob(str) {
              return str.replace(/\u0002/g, '\u0002\u0002').replace(/\u0001/g, '\u0001\u0002').replace(/\u0000/g, '\u0001\u0001');
            }
            function unescapeBlob(str) {
              return str.replace(/\u0001\u0001/g, '\u0000').replace(/\u0001\u0002/g, '\u0001').replace(/\u0002\u0002/g, '\u0002');
            }
            function stringifyDoc(doc) {
              delete doc._id;
              delete doc._rev;
              return JSON.stringify(doc);
            }
            function unstringifyDoc(doc, id, rev$$1) {
              doc = JSON.parse(doc);
              doc._id = id;
              doc._rev = rev$$1;
              return doc;
            }
            function qMarks(num) {
              var s = '(';
              while (num--) {
                s += '?';
                if (num) {
                  s += ',';
                }
              }
              return s + ')';
            }
            function select(selector, table, joiner, where, orderBy) {
              return 'SELECT ' + selector + ' FROM ' + (typeof table === 'string' ? table : table.join(' JOIN ')) + (joiner ? ' ON ' + joiner : '') + (where ? ' WHERE ' + (typeof where === 'string' ? where : where.join(' AND ')) : '') + (orderBy ? ' ORDER BY ' + orderBy : '');
            }
            function compactRevs$1(revs, docId, tx) {
              if (!revs.length) {
                return;
              }
              var numDone = 0;
              var seqs = [];
              function checkDone() {
                if (++numDone === revs.length) {
                  deleteOrphans();
                }
              }
              function deleteOrphans() {
                if (!seqs.length) {
                  return;
                }
                var sql = 'SELECT DISTINCT digest AS digest FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);
                tx.executeSql(sql, seqs, function (tx, res) {
                  var digestsToCheck = [];
                  for (var i = 0; i < res.rows.length; i++) {
                    digestsToCheck.push(res.rows.item(i).digest);
                  }
                  if (!digestsToCheck.length) {
                    return;
                  }
                  var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN (' + seqs.map(function () {
                    return '?';
                  }).join(',') + ')';
                  tx.executeSql(sql, seqs, function (tx) {
                    var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest IN (' + digestsToCheck.map(function () {
                      return '?';
                    }).join(',') + ')';
                    tx.executeSql(sql, digestsToCheck, function (tx, res) {
                      var nonOrphanedDigests = new ExportedSet();
                      for (var i = 0; i < res.rows.length; i++) {
                        nonOrphanedDigests.add(res.rows.item(i).digest);
                      }
                      digestsToCheck.forEach(function (digest) {
                        if (nonOrphanedDigests.has(digest)) {
                          return;
                        }
                        tx.executeSql('DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?', [digest]);
                        tx.executeSql('DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);
                      });
                    });
                  });
                });
              }
              revs.forEach(function (rev$$1) {
                var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 + ' WHERE doc_id=? AND rev=?';
                tx.executeSql(sql, [docId, rev$$1], function (tx, res) {
                  if (!res.rows.length) {
                    return checkDone();
                  }
                  var seq = res.rows.item(0).seq;
                  seqs.push(seq);
                  tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);
                });
              });
            }
            function websqlError(callback) {
              return function (event) {
                guardedConsole('error', 'WebSQL threw an error', event);
                var errorNameMatch = event && event.constructor.toString().match(/function ([^(]+)/);
                var errorName = errorNameMatch && errorNameMatch[1] || event.type;
                var errorReason = event.target || event.message;
                callback(createError(WSQ_ERROR, errorReason, errorName));
              };
            }
            function getSize(opts) {
              if ('size' in opts) {
                return opts.size * 1000000;
              }
              var isAndroid = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);
              return isAndroid ? 5000000 : 1;
            }
            function websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {
              var newEdits = opts.new_edits;
              var userDocs = req.docs;
              var docInfos = userDocs.map(function (doc) {
                if (doc._id && isLocalId(doc._id)) {
                  return doc;
                }
                var newDoc = parseDoc(doc, newEdits);
                return newDoc;
              });
              var docInfoErrors = docInfos.filter(function (docInfo) {
                return docInfo.error;
              });
              if (docInfoErrors.length) {
                return callback(docInfoErrors[0]);
              }
              var tx;
              var results = new Array(docInfos.length);
              var fetchedDocs = new ExportedMap();
              var preconditionErrored;
              function complete() {
                if (preconditionErrored) {
                  return callback(preconditionErrored);
                }
                websqlChanges.notify(api._name);
                callback(null, results);
              }
              function verifyAttachment(digest, callback) {
                var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';
                tx.executeSql(sql, [digest], function (tx, result) {
                  if (result.rows.item(0).cnt === 0) {
                    var err = createError(MISSING_STUB, 'unknown stub attachment with digest ' + digest);
                    callback(err);
                  } else {
                    callback();
                  }
                });
              }
              function verifyAttachments(finish) {
                var digests = [];
                docInfos.forEach(function (docInfo) {
                  if (docInfo.data && docInfo.data._attachments) {
                    Object.keys(docInfo.data._attachments).forEach(function (filename) {
                      var att = docInfo.data._attachments[filename];
                      if (att.stub) {
                        digests.push(att.digest);
                      }
                    });
                  }
                });
                if (!digests.length) {
                  return finish();
                }
                var numDone = 0;
                var err;
                function checkDone() {
                  if (++numDone === digests.length) {
                    finish(err);
                  }
                }
                digests.forEach(function (digest) {
                  verifyAttachment(digest, function (attErr) {
                    if (attErr && !err) {
                      err = attErr;
                    }
                    checkDone();
                  });
                });
              }
              function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted, isUpdate, delta, resultsIdx, callback) {
                function finish() {
                  var data = docInfo.data;
                  var deletedInt = newRevIsDeleted ? 1 : 0;
                  var id = data._id;
                  var rev = data._rev;
                  var json = stringifyDoc(data);
                  var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 + ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';
                  var sqlArgs = [id, rev, json, deletedInt];
                  function insertAttachmentMappings(seq, callback) {
                    var attsAdded = 0;
                    var attsToAdd = Object.keys(data._attachments || {});
                    if (!attsToAdd.length) {
                      return callback();
                    }
                    function checkDone() {
                      if (++attsAdded === attsToAdd.length) {
                        callback();
                      }
                      return false;
                    }
                    function add(att) {
                      var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq) VALUES (?,?)';
                      var sqlArgs = [data._attachments[att].digest, seq];
                      tx.executeSql(sql, sqlArgs, checkDone, checkDone);
                    }
                    for (var i = 0; i < attsToAdd.length; i++) {
                      add(attsToAdd[i]);
                    }
                  }
                  tx.executeSql(sql, sqlArgs, function (tx, result) {
                    var seq = result.insertId;
                    insertAttachmentMappings(seq, function () {
                      dataWritten(tx, seq);
                    });
                  }, function () {
                    var fetchSql = select('seq', BY_SEQ_STORE$1, null, 'doc_id=? AND rev=?');
                    tx.executeSql(fetchSql, [id, rev], function (tx, res) {
                      var seq = res.rows.item(0).seq;
                      var sql = 'UPDATE ' + BY_SEQ_STORE$1 + ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';
                      var sqlArgs = [json, deletedInt, id, rev];
                      tx.executeSql(sql, sqlArgs, function (tx) {
                        insertAttachmentMappings(seq, function () {
                          dataWritten(tx, seq);
                        });
                      });
                    });
                    return false;
                  });
                }
                function collectResults(attachmentErr) {
                  if (!err) {
                    if (attachmentErr) {
                      err = attachmentErr;
                      callback(err);
                    } else if (recv === attachments.length) {
                      finish();
                    }
                  }
                }
                var err = null;
                var recv = 0;
                docInfo.data._id = docInfo.metadata.id;
                docInfo.data._rev = docInfo.metadata.rev;
                var attachments = Object.keys(docInfo.data._attachments || {});
                if (newRevIsDeleted) {
                  docInfo.data._deleted = true;
                }
                function attachmentSaved(err) {
                  recv++;
                  collectResults(err);
                }
                attachments.forEach(function (key) {
                  var att = docInfo.data._attachments[key];
                  if (!att.stub) {
                    var data = att.data;
                    delete att.data;
                    att.revpos = parseInt(winningRev$$1, 10);
                    var digest = att.digest;
                    saveAttachment(digest, data, attachmentSaved);
                  } else {
                    recv++;
                    collectResults();
                  }
                });
                if (!attachments.length) {
                  finish();
                }
                function dataWritten(tx, seq) {
                  var id = docInfo.metadata.id;
                  var revsToCompact = docInfo.stemmedRevs || [];
                  if (isUpdate && api.auto_compaction) {
                    revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);
                  }
                  if (revsToCompact.length) {
                    compactRevs$1(revsToCompact, id, tx);
                  }
                  docInfo.metadata.seq = seq;
                  var rev = docInfo.metadata.rev;
                  delete docInfo.metadata.rev;
                  var sql = isUpdate ? 'UPDATE ' + DOC_STORE$1 + ' SET json=?, max_seq=?, winningseq=' + '(SELECT seq FROM ' + BY_SEQ_STORE$1 + ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?' : 'INSERT INTO ' + DOC_STORE$1 + ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';
                  var metadataStr = safeJsonStringify(docInfo.metadata);
                  var params = isUpdate ? [metadataStr, seq, winningRev$$1, id] : [id, seq, seq, metadataStr];
                  tx.executeSql(sql, params, function () {
                    results[resultsIdx] = {
                      ok: true,
                      id: docInfo.metadata.id,
                      rev: rev
                    };
                    fetchedDocs.set(id, docInfo.metadata);
                    callback();
                  });
                }
              }
              function websqlProcessDocs() {
                processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx, results, writeDoc, opts);
              }
              function fetchExistingDocs(callback) {
                if (!docInfos.length) {
                  return callback();
                }
                var numFetched = 0;
                function checkDone() {
                  if (++numFetched === docInfos.length) {
                    callback();
                  }
                }
                docInfos.forEach(function (docInfo) {
                  if (docInfo._id && isLocalId(docInfo._id)) {
                    return checkDone();
                  }
                  var id = docInfo.metadata.id;
                  tx.executeSql('SELECT json FROM ' + DOC_STORE$1 + ' WHERE id = ?', [id], function (tx, result) {
                    if (result.rows.length) {
                      var metadata = safeJsonParse(result.rows.item(0).json);
                      fetchedDocs.set(id, metadata);
                    }
                    checkDone();
                  });
                });
              }
              function saveAttachment(digest, data, callback) {
                var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';
                tx.executeSql(sql, [digest], function (tx, result) {
                  if (result.rows.length) {
                    return callback();
                  }
                  sql = 'INSERT INTO ' + ATTACH_STORE$1 + ' (digest, body, escaped) VALUES (?,?,1)';
                  tx.executeSql(sql, [digest, escapeBlob(data)], function () {
                    callback();
                  }, function () {
                    callback();
                    return false;
                  });
                });
              }
              preprocessAttachments(docInfos, 'binary', function (err) {
                if (err) {
                  return callback(err);
                }
                db.transaction(function (txn) {
                  tx = txn;
                  verifyAttachments(function (err) {
                    if (err) {
                      preconditionErrored = err;
                    } else {
                      fetchExistingDocs(websqlProcessDocs);
                    }
                  });
                }, websqlError(callback), complete);
              });
            }
            var cachedDatabases = new ExportedMap();
            function openDatabaseWithOpts(opts) {
              return opts.websql(opts.name, opts.version, opts.description, opts.size);
            }
            function openDBSafely(opts) {
              try {
                return { db: openDatabaseWithOpts(opts) };
              } catch (err) {
                return { error: err };
              }
            }
            function openDB$1(opts) {
              var cachedResult = cachedDatabases.get(opts.name);
              if (!cachedResult) {
                cachedResult = openDBSafely(opts);
                cachedDatabases.set(opts.name, cachedResult);
              }
              return cachedResult;
            }
            var websqlChanges = new Changes();
            function fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {
              var attachments = Object.keys(doc._attachments || {});
              if (!attachments.length) {
                return cb && cb();
              }
              var numDone = 0;
              function checkDone() {
                if (++numDone === attachments.length && cb) {
                  cb();
                }
              }
              function fetchAttachment(doc, att) {
                var attObj = doc._attachments[att];
                var attOpts = {
                  binary: opts.binary,
                  ctx: txn
                };
                api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {
                  doc._attachments[att] = $inject_Object_assign(pick(attObj, ['digest', 'content_type']), { data: data });
                  checkDone();
                });
              }
              attachments.forEach(function (att) {
                if (opts.attachments && opts.include_docs) {
                  fetchAttachment(doc, att);
                } else {
                  doc._attachments[att].stub = true;
                  checkDone();
                }
              });
            }
            var POUCH_VERSION = 1;
            var BY_SEQ_STORE_DELETED_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \'by-seq-deleted-idx\' ON ' + BY_SEQ_STORE$1 + ' (seq, deleted)';
            var BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL = 'CREATE UNIQUE INDEX IF NOT EXISTS \'by-seq-doc-id-rev\' ON ' + BY_SEQ_STORE$1 + ' (doc_id, rev)';
            var DOC_STORE_WINNINGSEQ_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \'doc-winningseq-idx\' ON ' + DOC_STORE$1 + ' (winningseq)';
            var ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL = 'CREATE INDEX IF NOT EXISTS \'attach-seq-seq-idx\' ON ' + ATTACH_AND_SEQ_STORE$1 + ' (seq)';
            var ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL = 'CREATE UNIQUE INDEX IF NOT EXISTS \'attach-seq-digest-idx\' ON ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';
            var DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';
            var SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' + BY_SEQ_STORE$1 + '.deleted AS deleted, ' + BY_SEQ_STORE$1 + '.json AS data, ' + BY_SEQ_STORE$1 + '.rev AS rev, ' + DOC_STORE$1 + '.json AS metadata';
            function WebSqlPouch$1(opts, callback) {
              var api = this;
              var instanceId = null;
              var size = getSize(opts);
              var idRequests = [];
              var encoding;
              api._name = opts.name;
              var websqlOpts = $inject_Object_assign({}, opts, {
                version: POUCH_VERSION,
                description: opts.name,
                size: size
              });
              var openDBResult = openDB$1(websqlOpts);
              if (openDBResult.error) {
                return websqlError(callback)(openDBResult.error);
              }
              var db = openDBResult.db;
              if (typeof db.readTransaction !== 'function') {
                db.readTransaction = db.transaction;
              }
              function dbCreated() {
                if (hasLocalStorage()) {
                  window.localStorage['_pouch__websqldb_' + api._name] = true;
                }
                callback(null, api);
              }
              function runMigration2(tx, callback) {
                tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);
                tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {
                  tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
                  tx.executeSql('ALTER TABLE ' + DOC_STORE$1 + ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {
                    tx.executeSql('CREATE INDEX IF NOT EXISTS \'doc-store-local-idx\' ON ' + DOC_STORE$1 + ' (local, id)');
                    var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 + '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';
                    tx.executeSql(sql, [], function (tx, result) {
                      var deleted = [];
                      var local = [];
                      for (var i = 0; i < result.rows.length; i++) {
                        var item = result.rows.item(i);
                        var seq = item.seq;
                        var metadata = JSON.parse(item.metadata);
                        if (isDeleted(metadata)) {
                          deleted.push(seq);
                        }
                        if (isLocalId(metadata.id)) {
                          local.push(metadata.id);
                        }
                      }
                      tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' + qMarks(local.length), local, function () {
                        tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 + ' SET deleted = 1 WHERE seq IN ' + qMarks(deleted.length), deleted, callback);
                      });
                    });
                  });
                });
              }
              function runMigration3(tx, callback) {
                var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 + ' (id UNIQUE, rev, json)';
                tx.executeSql(local, [], function () {
                  var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' + BY_SEQ_STORE$1 + '.json AS data ' + 'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq WHERE local = 1';
                  tx.executeSql(sql, [], function (tx, res) {
                    var rows = [];
                    for (var i = 0; i < res.rows.length; i++) {
                      rows.push(res.rows.item(i));
                    }
                    function doNext() {
                      if (!rows.length) {
                        return callback(tx);
                      }
                      var row = rows.shift();
                      var rev$$1 = JSON.parse(row.data)._rev;
                      tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)', [row.id, rev$$1, row.data], function (tx) {
                        tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?', [row.id], function (tx) {
                          tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [row.seq], function () {
                            doNext();
                          });
                        });
                      });
                    }
                    doNext();
                  });
                });
              }
              function runMigration4(tx, callback) {
                function updateRows(rows) {
                  function doNext() {
                    if (!rows.length) {
                      return callback(tx);
                    }
                    var row = rows.shift();
                    var doc_id_rev = parseHexString(row.hex, encoding);
                    var idx = doc_id_rev.lastIndexOf('::');
                    var doc_id = doc_id_rev.substring(0, idx);
                    var rev$$1 = doc_id_rev.substring(idx + 2);
                    var sql = 'UPDATE ' + BY_SEQ_STORE$1 + ' SET doc_id=?, rev=? WHERE doc_id_rev=?';
                    tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {
                      doNext();
                    });
                  }
                  doNext();
                }
                var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';
                tx.executeSql(sql, [], function (tx) {
                  var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';
                  tx.executeSql(sql, [], function (tx) {
                    tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {
                      var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;
                      tx.executeSql(sql, [], function (tx, res) {
                        var rows = [];
                        for (var i = 0; i < res.rows.length; i++) {
                          rows.push(res.rows.item(i));
                        }
                        updateRows(rows);
                      });
                    });
                  });
                });
              }
              function runMigration5(tx, callback) {
                function migrateAttsAndSeqs(tx) {
                  var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;
                  tx.executeSql(sql, [], function (tx, res) {
                    var count = res.rows.item(0).cnt;
                    if (!count) {
                      return callback(tx);
                    }
                    var offset = 0;
                    var pageSize = 10;
                    function nextPage() {
                      var sql = select(SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id', [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, null, DOC_STORE$1 + '.id ');
                      sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;
                      offset += pageSize;
                      tx.executeSql(sql, [], function (tx, res) {
                        if (!res.rows.length) {
                          return callback(tx);
                        }
                        var digestSeqs = {};
                        function addDigestSeq(digest, seq) {
                          var seqs = digestSeqs[digest] = digestSeqs[digest] || [];
                          if (seqs.indexOf(seq) === -1) {
                            seqs.push(seq);
                          }
                        }
                        for (var i = 0; i < res.rows.length; i++) {
                          var row = res.rows.item(i);
                          var doc = unstringifyDoc(row.data, row.id, row.rev);
                          var atts = Object.keys(doc._attachments || {});
                          for (var j = 0; j < atts.length; j++) {
                            var att = doc._attachments[atts[j]];
                            addDigestSeq(att.digest, row.seq);
                          }
                        }
                        var digestSeqPairs = [];
                        Object.keys(digestSeqs).forEach(function (digest) {
                          var seqs = digestSeqs[digest];
                          seqs.forEach(function (seq) {
                            digestSeqPairs.push([digest, seq]);
                          });
                        });
                        if (!digestSeqPairs.length) {
                          return nextPage();
                        }
                        var numDone = 0;
                        digestSeqPairs.forEach(function (pair) {
                          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq) VALUES (?,?)';
                          tx.executeSql(sql, pair, function () {
                            if (++numDone === digestSeqPairs.length) {
                              nextPage();
                            }
                          });
                        });
                      });
                    }
                    nextPage();
                  });
                }
                var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';
                tx.executeSql(attachAndRev, [], function (tx) {
                  tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {
                    tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [], migrateAttsAndSeqs);
                  });
                });
              }
              function runMigration6(tx, callback) {
                var sql = 'ALTER TABLE ' + ATTACH_STORE$1 + ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';
                tx.executeSql(sql, [], callback);
              }
              function runMigration7(tx, callback) {
                var sql = 'ALTER TABLE ' + DOC_STORE$1 + ' ADD COLUMN max_seq INTEGER';
                tx.executeSql(sql, [], function (tx) {
                  var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' + BY_SEQ_STORE$1 + ' WHERE doc_id=id)';
                  tx.executeSql(sql, [], function (tx) {
                    var sql = 'CREATE UNIQUE INDEX IF NOT EXISTS \'doc-max-seq-idx\' ON ' + DOC_STORE$1 + ' (max_seq)';
                    tx.executeSql(sql, [], callback);
                  });
                });
              }
              function checkEncoding(tx, cb) {
                tx.executeSql('SELECT HEX("a") AS hex', [], function (tx, res) {
                  var hex = res.rows.item(0).hex;
                  encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';
                  cb();
                });
              }
              function onGetInstanceId() {
                while (idRequests.length > 0) {
                  var idCallback = idRequests.pop();
                  idCallback(null, instanceId);
                }
              }
              function onGetVersion(tx, dbVersion) {
                if (dbVersion === 0) {
                  var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 + ' (dbid, db_version INTEGER)';
                  var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 + ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';
                  var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';
                  var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 + ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';
                  var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 + ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' + 'json, deleted TINYINT(1), doc_id, rev)';
                  var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 + ' (id UNIQUE, rev, json)';
                  tx.executeSql(attach);
                  tx.executeSql(local);
                  tx.executeSql(attachAndRev, [], function () {
                    tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);
                    tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);
                  });
                  tx.executeSql(doc, [], function () {
                    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);
                    tx.executeSql(seq, [], function () {
                      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);
                      tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);
                      tx.executeSql(meta, [], function () {
                        var initSeq = 'INSERT INTO ' + META_STORE$1 + ' (db_version, dbid) VALUES (?,?)';
                        instanceId = uuid();
                        var initSeqArgs = [ADAPTER_VERSION$1, instanceId];
                        tx.executeSql(initSeq, initSeqArgs, function () {
                          onGetInstanceId();
                        });
                      });
                    });
                  });
                } else {
                  var setupDone = function () {
                    var migrated = dbVersion < ADAPTER_VERSION$1;
                    if (migrated) {
                      tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' + ADAPTER_VERSION$1);
                    }
                    var sql = 'SELECT dbid FROM ' + META_STORE$1;
                    tx.executeSql(sql, [], function (tx, result) {
                      instanceId = result.rows.item(0).dbid;
                      onGetInstanceId();
                    });
                  };
                  var tasks = [runMigration2, runMigration3, runMigration4, runMigration5, runMigration6, runMigration7, setupDone];
                  var i = dbVersion;
                  var nextMigration = function (tx) {
                    tasks[i - 1](tx, nextMigration);
                    i++;
                  };
                  nextMigration(tx);
                }
              }
              function setup() {
                db.transaction(function (tx) {
                  checkEncoding(tx, function () {
                    fetchVersion(tx);
                  });
                }, websqlError(callback), dbCreated);
              }
              function fetchVersion(tx) {
                var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;
                tx.executeSql(sql, [], function (tx, result) {
                  if (!result.rows.length) {
                    onGetVersion(tx, 0);
                  } else if (!/db_version/.test(result.rows.item(0).sql)) {
                    tx.executeSql('ALTER TABLE ' + META_STORE$1 + ' ADD COLUMN db_version INTEGER', [], function () {
                      onGetVersion(tx, 1);
                    });
                  } else {
                    tx.executeSql('SELECT db_version FROM ' + META_STORE$1, [], function (tx, result) {
                      var dbVersion = result.rows.item(0).db_version;
                      onGetVersion(tx, dbVersion);
                    });
                  }
                });
              }
              setup();
              function getMaxSeq(tx, callback) {
                var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;
                tx.executeSql(sql, [], function (tx, res) {
                  var updateSeq = res.rows.item(0).seq || 0;
                  callback(updateSeq);
                });
              }
              function countDocs(tx, callback) {
                var sql = select('COUNT(' + DOC_STORE$1 + '.id) AS \'num\'', [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, BY_SEQ_STORE$1 + '.deleted=0');
                tx.executeSql(sql, [], function (tx, result) {
                  callback(result.rows.item(0).num);
                });
              }
              api._remote = false;
              api.type = function () {
                return 'websql';
              };
              api._id = toPromise(function (callback) {
                callback(null, instanceId);
              });
              api._info = function (callback) {
                var seq;
                var docCount;
                db.readTransaction(function (tx) {
                  getMaxSeq(tx, function (theSeq) {
                    seq = theSeq;
                  });
                  countDocs(tx, function (theDocCount) {
                    docCount = theDocCount;
                  });
                }, websqlError(callback), function () {
                  callback(null, {
                    doc_count: docCount,
                    update_seq: seq,
                    websql_encoding: encoding
                  });
                });
              };
              api._bulkDocs = function (req, reqOpts, callback) {
                websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);
              };
              function latest$$1(tx, id, rev$$1, callback, finish) {
                var sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, DOC_STORE$1 + '.id=?');
                var sqlArgs = [id];
                tx.executeSql(sql, sqlArgs, function (a, results) {
                  if (!results.rows.length) {
                    var err = createError(MISSING_DOC, 'missing');
                    return finish(err);
                  }
                  var item = results.rows.item(0);
                  var metadata = safeJsonParse(item.metadata);
                  callback(latest(rev$$1, metadata));
                });
              }
              api._get = function (id, opts, callback) {
                var doc;
                var metadata;
                var tx = opts.ctx;
                if (!tx) {
                  return db.readTransaction(function (txn) {
                    api._get(id, $inject_Object_assign({ ctx: txn }, opts), callback);
                  });
                }
                function finish(err) {
                  callback(err, {
                    doc: doc,
                    metadata: metadata,
                    ctx: tx
                  });
                }
                var sql;
                var sqlArgs;
                if (!opts.rev) {
                  sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, DOC_STORE$1 + '.id=?');
                  sqlArgs = [id];
                } else if (opts.latest) {
                  latest$$1(tx, id, opts.rev, function (latestRev) {
                    opts.latest = false;
                    opts.rev = latestRev;
                    api._get(id, opts, callback);
                  }, finish);
                  return;
                } else {
                  sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id', [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);
                  sqlArgs = [id, opts.rev];
                }
                tx.executeSql(sql, sqlArgs, function (a, results) {
                  if (!results.rows.length) {
                    var missingErr = createError(MISSING_DOC, 'missing');
                    return finish(missingErr);
                  }
                  var item = results.rows.item(0);
                  metadata = safeJsonParse(item.metadata);
                  if (item.deleted && !opts.rev) {
                    var deletedErr = createError(MISSING_DOC, 'deleted');
                    return finish(deletedErr);
                  }
                  doc = unstringifyDoc(item.data, metadata.id, item.rev);
                  finish();
                });
              };
              api._allDocs = function (opts, callback) {
                var results = [];
                var totalRows;
                var start = 'startkey' in opts ? opts.startkey : false;
                var end = 'endkey' in opts ? opts.endkey : false;
                var key = 'key' in opts ? opts.key : false;
                var descending = 'descending' in opts ? opts.descending : false;
                var limit = 'limit' in opts ? opts.limit : -1;
                var offset = 'skip' in opts ? opts.skip : 0;
                var inclusiveEnd = opts.inclusive_end !== false;
                var sqlArgs = [];
                var criteria = [];
                if (key !== false) {
                  criteria.push(DOC_STORE$1 + '.id = ?');
                  sqlArgs.push(key);
                } else if (start !== false || end !== false) {
                  if (start !== false) {
                    criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');
                    sqlArgs.push(start);
                  }
                  if (end !== false) {
                    var comparator = descending ? '>' : '<';
                    if (inclusiveEnd) {
                      comparator += '=';
                    }
                    criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');
                    sqlArgs.push(end);
                  }
                  if (key !== false) {
                    criteria.push(DOC_STORE$1 + '.id = ?');
                    sqlArgs.push(key);
                  }
                }
                if (opts.deleted !== 'ok') {
                  criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');
                }
                db.readTransaction(function (tx) {
                  countDocs(tx, function (docCount) {
                    totalRows = docCount;
                  });
                  if (limit === 0) {
                    return;
                  }
                  var sql = select(SELECT_DOCS, [DOC_STORE$1, BY_SEQ_STORE$1], DOC_STORE_AND_BY_SEQ_JOINER, criteria, DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC'));
                  sql += ' LIMIT ' + limit + ' OFFSET ' + offset;
                  tx.executeSql(sql, sqlArgs, function (tx, result) {
                    for (var i = 0, l = result.rows.length; i < l; i++) {
                      var item = result.rows.item(i);
                      var metadata = safeJsonParse(item.metadata);
                      var id = metadata.id;
                      var data = unstringifyDoc(item.data, id, item.rev);
                      var winningRev$$1 = data._rev;
                      var doc = {
                        id: id,
                        key: id,
                        value: { rev: winningRev$$1 }
                      };
                      if (opts.include_docs) {
                        doc.doc = data;
                        doc.doc._rev = winningRev$$1;
                        if (opts.conflicts) {
                          var conflicts = collectConflicts(metadata);
                          if (conflicts.length) {
                            doc.doc._conflicts = conflicts;
                          }
                        }
                        fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);
                      }
                      if (item.deleted) {
                        if (opts.deleted === 'ok') {
                          doc.value.deleted = true;
                          doc.doc = null;
                        } else {
                          continue;
                        }
                      }
                      results.push(doc);
                    }
                  });
                }, websqlError(callback), function () {
                  callback(null, {
                    total_rows: totalRows,
                    offset: opts.skip,
                    rows: results
                  });
                });
              };
              api._changes = function (opts) {
                opts = clone(opts);
                if (opts.continuous) {
                  var id = api._name + ':' + uuid();
                  websqlChanges.addListener(api._name, id, api, opts);
                  websqlChanges.notify(api._name);
                  return { cancel: function () {
                      websqlChanges.removeListener(api._name, id);
                    } };
                }
                var descending = opts.descending;
                opts.since = opts.since && !descending ? opts.since : 0;
                var limit = 'limit' in opts ? opts.limit : -1;
                if (limit === 0) {
                  limit = 1;
                }
                var returnDocs;
                if ('return_docs' in opts) {
                  returnDocs = opts.return_docs;
                } else if ('returnDocs' in opts) {
                  returnDocs = opts.returnDocs;
                } else {
                  returnDocs = true;
                }
                var results = [];
                var numResults = 0;
                function fetchChanges() {
                  var selectStmt = DOC_STORE$1 + '.json AS metadata, ' + DOC_STORE$1 + '.max_seq AS maxSeq, ' + BY_SEQ_STORE$1 + '.json AS winningDoc, ' + BY_SEQ_STORE$1 + '.rev AS winningRev ';
                  var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;
                  var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' + ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';
                  var criteria = ['maxSeq > ?'];
                  var sqlArgs = [opts.since];
                  if (opts.doc_ids) {
                    criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));
                    sqlArgs = sqlArgs.concat(opts.doc_ids);
                  }
                  var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');
                  var sql = select(selectStmt, from, joiner, criteria, orderBy);
                  var filter = filterChange(opts);
                  if (!opts.view && !opts.filter) {
                    sql += ' LIMIT ' + limit;
                  }
                  var lastSeq = opts.since || 0;
                  db.readTransaction(function (tx) {
                    tx.executeSql(sql, sqlArgs, function (tx, result) {
                      function reportChange(change) {
                        return function () {
                          opts.onChange(change);
                        };
                      }
                      for (var i = 0, l = result.rows.length; i < l; i++) {
                        var item = result.rows.item(i);
                        var metadata = safeJsonParse(item.metadata);
                        lastSeq = item.maxSeq;
                        var doc = unstringifyDoc(item.winningDoc, metadata.id, item.winningRev);
                        var change = opts.processChange(doc, metadata, opts);
                        change.seq = item.maxSeq;
                        var filtered = filter(change);
                        if (typeof filtered === 'object') {
                          return opts.complete(filtered);
                        }
                        if (filtered) {
                          numResults++;
                          if (returnDocs) {
                            results.push(change);
                          }
                          if (opts.attachments && opts.include_docs) {
                            fetchAttachmentsIfNecessary$1(doc, opts, api, tx, reportChange(change));
                          } else {
                            reportChange(change)();
                          }
                        }
                        if (numResults === limit) {
                          break;
                        }
                      }
                    });
                  }, websqlError(opts.complete), function () {
                    if (!opts.continuous) {
                      opts.complete(null, {
                        results: results,
                        last_seq: lastSeq
                      });
                    }
                  });
                }
                fetchChanges();
              };
              api._close = function (callback) {
                callback();
              };
              api._getAttachment = function (docId, attachId, attachment, opts, callback) {
                var res;
                var tx = opts.ctx;
                var digest = attachment.digest;
                var type = attachment.content_type;
                var sql = 'SELECT escaped, ' + 'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';
                tx.executeSql(sql, [digest], function (tx, result) {
                  var item = result.rows.item(0);
                  var data = item.escaped ? unescapeBlob(item.body) : parseHexString(item.body, encoding);
                  if (opts.binary) {
                    res = binStringToBluffer(data, type);
                  } else {
                    res = thisBtoa(data);
                  }
                  callback(null, res);
                });
              };
              api._getRevisionTree = function (docId, callback) {
                db.readTransaction(function (tx) {
                  var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';
                  tx.executeSql(sql, [docId], function (tx, result) {
                    if (!result.rows.length) {
                      callback(createError(MISSING_DOC));
                    } else {
                      var data = safeJsonParse(result.rows.item(0).metadata);
                      callback(null, data.rev_tree);
                    }
                  });
                });
              };
              api._doCompaction = function (docId, revs, callback) {
                if (!revs.length) {
                  return callback();
                }
                db.transaction(function (tx) {
                  var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';
                  tx.executeSql(sql, [docId], function (tx, result) {
                    var metadata = safeJsonParse(result.rows.item(0).metadata);
                    traverseRevTree(metadata.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {
                      var rev$$1 = pos + '-' + revHash;
                      if (revs.indexOf(rev$$1) !== -1) {
                        opts.status = 'missing';
                      }
                    });
                    var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';
                    tx.executeSql(sql, [safeJsonStringify(metadata), docId]);
                  });
                  compactRevs$1(revs, docId, tx);
                }, websqlError(callback), function () {
                  callback();
                });
              };
              api._getLocal = function (id, callback) {
                db.readTransaction(function (tx) {
                  var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';
                  tx.executeSql(sql, [id], function (tx, res) {
                    if (res.rows.length) {
                      var item = res.rows.item(0);
                      var doc = unstringifyDoc(item.json, id, item.rev);
                      callback(null, doc);
                    } else {
                      callback(createError(MISSING_DOC));
                    }
                  });
                });
              };
              api._putLocal = function (doc, opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                delete doc._revisions;
                var oldRev = doc._rev;
                var id = doc._id;
                var newRev;
                if (!oldRev) {
                  newRev = doc._rev = '0-1';
                } else {
                  newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);
                }
                var json = stringifyDoc(doc);
                var ret;
                function putLocal(tx) {
                  var sql;
                  var values;
                  if (oldRev) {
                    sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' + 'WHERE id=? AND rev=?';
                    values = [newRev, json, id, oldRev];
                  } else {
                    sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';
                    values = [id, newRev, json];
                  }
                  tx.executeSql(sql, values, function (tx, res) {
                    if (res.rowsAffected) {
                      ret = {
                        ok: true,
                        id: id,
                        rev: newRev
                      };
                      if (opts.ctx) {
                        callback(null, ret);
                      }
                    } else {
                      callback(createError(REV_CONFLICT));
                    }
                  }, function () {
                    callback(createError(REV_CONFLICT));
                    return false;
                  });
                }
                if (opts.ctx) {
                  putLocal(opts.ctx);
                } else {
                  db.transaction(putLocal, websqlError(callback), function () {
                    if (ret) {
                      callback(null, ret);
                    }
                  });
                }
              };
              api._removeLocal = function (doc, opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                var ret;
                function removeLocal(tx) {
                  var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';
                  var params = [doc._id, doc._rev];
                  tx.executeSql(sql, params, function (tx, res) {
                    if (!res.rowsAffected) {
                      return callback(createError(MISSING_DOC));
                    }
                    ret = {
                      ok: true,
                      id: doc._id,
                      rev: '0-0'
                    };
                    if (opts.ctx) {
                      callback(null, ret);
                    }
                  });
                }
                if (opts.ctx) {
                  removeLocal(opts.ctx);
                } else {
                  db.transaction(removeLocal, websqlError(callback), function () {
                    if (ret) {
                      callback(null, ret);
                    }
                  });
                }
              };
              api._destroy = function (opts, callback) {
                websqlChanges.removeAllListeners(api._name);
                db.transaction(function (tx) {
                  var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1, LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];
                  stores.forEach(function (store) {
                    tx.executeSql('DROP TABLE IF EXISTS ' + store, []);
                  });
                }, websqlError(callback), function () {
                  if (hasLocalStorage()) {
                    delete window.localStorage['_pouch__websqldb_' + api._name];
                    delete window.localStorage[api._name];
                  }
                  callback(null, { 'ok': true });
                });
              };
            }
            function canOpenTestDB() {
              try {
                openDatabase('_pouch_validate_websql', 1, '', 1);
                return true;
              } catch (err) {
                return false;
              }
            }
            function isValidWebSQL() {
              if (typeof indexedDB === 'undefined' || indexedDB === null || !/iP(hone|od|ad)/.test(navigator.userAgent)) {
                return true;
              }
              var hasLS = hasLocalStorage();
              var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;
              if (hasLS && localStorage[localStorageKey]) {
                return localStorage[localStorageKey] === '1';
              }
              var openedTestDB = canOpenTestDB();
              if (hasLS) {
                localStorage[localStorageKey] = openedTestDB ? '1' : '0';
              }
              return openedTestDB;
            }
            function valid() {
              if (typeof openDatabase !== 'function') {
                return false;
              }
              return isValidWebSQL();
            }
            function openDB(name, version, description, size) {
              return openDatabase(name, version, description, size);
            }
            function WebSQLPouch(opts, callback) {
              var _opts = $inject_Object_assign({ websql: openDB }, opts);
              WebSqlPouch$1.call(this, _opts, callback);
            }
            WebSQLPouch.valid = valid;
            WebSQLPouch.use_prefix = true;
            var WebSqlPouch = function (PouchDB) {
              PouchDB.adapter('websql', WebSQLPouch, true);
            };
            function wrappedFetch() {
              var wrappedPromise = {};
              var promise = new PouchPromise$1(function (resolve, reject) {
                wrappedPromise.resolve = resolve;
                wrappedPromise.reject = reject;
              });
              var args = new Array(arguments.length);
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i];
              }
              wrappedPromise.promise = promise;
              PouchPromise$1.resolve().then(function () {
                return fetch.apply(null, args);
              }).then(function (response) {
                wrappedPromise.resolve(response);
              })["catch"](function (error) {
                wrappedPromise.reject(error);
              });
              return wrappedPromise;
            }
            function fetchRequest(options, callback) {
              var wrappedPromise, timer, response;
              var headers = new Headers();
              var fetchOptions = {
                method: options.method,
                credentials: 'include',
                headers: headers
              };
              if (options.json) {
                headers.set('Accept', 'application/json');
                headers.set('Content-Type', options.headers['Content-Type'] || 'application/json');
              }
              if (options.body && options.processData && typeof options.body !== 'string') {
                fetchOptions.body = JSON.stringify(options.body);
              } else if ('body' in options) {
                fetchOptions.body = options.body;
              } else {
                fetchOptions.body = null;
              }
              Object.keys(options.headers).forEach(function (key) {
                if (options.headers.hasOwnProperty(key)) {
                  headers.set(key, options.headers[key]);
                }
              });
              wrappedPromise = wrappedFetch(options.url, fetchOptions);
              if (options.timeout > 0) {
                timer = setTimeout(function () {
                  wrappedPromise.reject(new Error('Load timeout for resource: ' + options.url));
                }, options.timeout);
              }
              wrappedPromise.promise.then(function (fetchResponse) {
                response = { statusCode: fetchResponse.status };
                if (options.timeout > 0) {
                  clearTimeout(timer);
                }
                if (response.statusCode >= 200 && response.statusCode < 300) {
                  return options.binary ? fetchResponse.blob() : fetchResponse.text();
                }
                return fetchResponse.json();
              }).then(function (result) {
                if (response.statusCode >= 200 && response.statusCode < 300) {
                  callback(null, response, result);
                } else {
                  result.status = response.statusCode;
                  callback(result);
                }
              })["catch"](function (error) {
                if (!error) {
                  error = new Error('canceled');
                }
                callback(error);
              });
              return { abort: wrappedPromise.reject };
            }
            function xhRequest(options, callback) {
              var xhr, timer;
              var timedout = false;
              var abortReq = function () {
                xhr.abort();
                cleanUp();
              };
              var timeoutReq = function () {
                timedout = true;
                xhr.abort();
                cleanUp();
              };
              var ret = { abort: abortReq };
              var cleanUp = function () {
                clearTimeout(timer);
                ret.abort = function () {};
                if (xhr) {
                  xhr.onprogress = undefined;
                  if (xhr.upload) {
                    xhr.upload.onprogress = undefined;
                  }
                  xhr.onreadystatechange = undefined;
                  xhr = undefined;
                }
              };
              if (options.xhr) {
                xhr = new options.xhr();
              } else {
                xhr = new XMLHttpRequest();
              }
              try {
                xhr.open(options.method, options.url);
              } catch (exception) {
                return callback(new Error(exception.name || 'Url is invalid'));
              }
              xhr.withCredentials = 'withCredentials' in options ? options.withCredentials : true;
              if (options.method === 'GET') {
                delete options.headers['Content-Type'];
              } else if (options.json) {
                options.headers.Accept = 'application/json';
                options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';
                if (options.body && options.processData && typeof options.body !== "string") {
                  options.body = JSON.stringify(options.body);
                }
              }
              if (options.binary) {
                xhr.responseType = 'arraybuffer';
              }
              if (!('body' in options)) {
                options.body = null;
              }
              for (var key in options.headers) {
                if (options.headers.hasOwnProperty(key)) {
                  xhr.setRequestHeader(key, options.headers[key]);
                }
              }
              if (options.timeout > 0) {
                timer = setTimeout(timeoutReq, options.timeout);
                xhr.onprogress = function () {
                  clearTimeout(timer);
                  if (xhr.readyState !== 4) {
                    timer = setTimeout(timeoutReq, options.timeout);
                  }
                };
                if (typeof xhr.upload !== 'undefined') {
                  xhr.upload.onprogress = xhr.onprogress;
                }
              }
              xhr.onreadystatechange = function () {
                if (xhr.readyState !== 4) {
                  return;
                }
                var response = { statusCode: xhr.status };
                if (xhr.status >= 200 && xhr.status < 300) {
                  var data;
                  if (options.binary) {
                    data = createBlob([xhr.response || ''], { type: xhr.getResponseHeader('Content-Type') });
                  } else {
                    data = xhr.responseText;
                  }
                  callback(null, response, data);
                } else {
                  var err = {};
                  if (timedout) {
                    err = new Error('ETIMEDOUT');
                    err.code = 'ETIMEDOUT';
                  } else if (typeof xhr.response === 'string') {
                    try {
                      err = JSON.parse(xhr.response);
                    } catch (e) {}
                  }
                  err.status = xhr.status;
                  callback(err);
                }
                cleanUp();
              };
              if (options.body && options.body instanceof Blob) {
                readAsArrayBuffer(options.body, function (arrayBuffer) {
                  xhr.send(arrayBuffer);
                });
              } else {
                xhr.send(options.body);
              }
              return ret;
            }
            function testXhr() {
              try {
                new XMLHttpRequest();
                return true;
              } catch (err) {
                return false;
              }
            }
            var hasXhr = testXhr();
            function ajax$1(options, callback) {
              if (!false && (hasXhr || options.xhr)) {
                return xhRequest(options, callback);
              } else {
                return fetchRequest(options, callback);
              }
            }
            var res$2 = function () {};
            function defaultBody() {
              return '';
            }
            function ajaxCore$1(options, callback) {
              options = clone(options);
              var defaultOptions = {
                method: "GET",
                headers: {},
                json: true,
                processData: true,
                timeout: 10000,
                cache: false
              };
              options = $inject_Object_assign(defaultOptions, options);
              function onSuccess(obj, resp, cb) {
                if (!options.binary && options.json && typeof obj === 'string') {
                  try {
                    obj = JSON.parse(obj);
                  } catch (e) {
                    return cb(e);
                  }
                }
                if (Array.isArray(obj)) {
                  obj = obj.map(function (v) {
                    if (v.error || v.missing) {
                      return generateErrorFromResponse(v);
                    } else {
                      return v;
                    }
                  });
                }
                if (options.binary) {
                  res$2(obj, resp);
                }
                cb(null, obj, resp);
              }
              if (options.json) {
                if (!options.binary) {
                  options.headers.Accept = 'application/json';
                }
                options.headers['Content-Type'] = options.headers['Content-Type'] || 'application/json';
              }
              if (options.binary) {
                options.encoding = null;
                options.json = false;
              }
              if (!options.processData) {
                options.json = false;
              }
              return ajax$1(options, function (err, response, body) {
                if (err) {
                  return callback(generateErrorFromResponse(err));
                }
                var error;
                var content_type = response.headers && response.headers['content-type'];
                var data = body || defaultBody();
                if (!options.binary && (options.json || !options.processData) && typeof data !== 'object' && (/json/.test(content_type) || /^[\s]*\{/.test(data) && /\}[\s]*$/.test(data))) {
                  try {
                    data = JSON.parse(data.toString());
                  } catch (e) {}
                }
                if (response.statusCode >= 200 && response.statusCode < 300) {
                  onSuccess(data, response, callback);
                } else {
                  error = generateErrorFromResponse(data);
                  error.status = response.statusCode;
                  callback(error);
                }
              });
            }
            function ajax(opts, callback) {
              var ua = navigator && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
              var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;
              var isIE = ua.indexOf('msie') !== -1;
              var isEdge = ua.indexOf('edge') !== -1;
              var shouldCacheBust = isSafari || (isIE || isEdge) && opts.method === 'GET';
              var cache = 'cache' in opts ? opts.cache : true;
              var isBlobUrl = /^blob:/.test(opts.url);
              if (!isBlobUrl && (shouldCacheBust || !cache)) {
                var hasArgs = opts.url.indexOf('?') !== -1;
                opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();
              }
              return ajaxCore$1(opts, callback);
            }
            function pool(promiseFactories, limit) {
              return new PouchPromise$1(function (resolve, reject) {
                var running = 0;
                var current = 0;
                var done = 0;
                var len = promiseFactories.length;
                var err;
                function runNext() {
                  running++;
                  promiseFactories[current++]().then(onSuccess, onError);
                }
                function doNext() {
                  if (++done === len) {
                    if (err) {
                      reject(err);
                    } else {
                      resolve();
                    }
                  } else {
                    runNextBatch();
                  }
                }
                function onSuccess() {
                  running--;
                  doNext();
                }
                function onError(thisErr) {
                  running--;
                  err = err || thisErr;
                  doNext();
                }
                function runNextBatch() {
                  while (running < limit && current < len) {
                    runNext();
                  }
                }
                runNextBatch();
              });
            }
            var CHANGES_BATCH_SIZE = 25;
            var MAX_SIMULTANEOUS_REVS = 50;
            var CHANGES_TIMEOUT_BUFFER = 5000;
            var DEFAULT_HEARTBEAT = 10000;
            var supportsBulkGetMap = {};
            function readAttachmentsAsBlobOrBuffer(row) {
              var atts = row.doc && row.doc._attachments;
              if (!atts) {
                return;
              }
              Object.keys(atts).forEach(function (filename) {
                var att = atts[filename];
                att.data = b64ToBluffer(att.data, att.content_type);
              });
            }
            function encodeDocId(id) {
              if (/^_design/.test(id)) {
                return '_design/' + encodeURIComponent(id.slice(8));
              }
              if (/^_local/.test(id)) {
                return '_local/' + encodeURIComponent(id.slice(7));
              }
              return encodeURIComponent(id);
            }
            function preprocessAttachments$2(doc) {
              if (!doc._attachments || !Object.keys(doc._attachments)) {
                return PouchPromise$1.resolve();
              }
              return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {
                var attachment = doc._attachments[key];
                if (attachment.data && typeof attachment.data !== 'string') {
                  return new PouchPromise$1(function (resolve) {
                    blobToBase64(attachment.data, resolve);
                  }).then(function (b64) {
                    attachment.data = b64;
                  });
                }
              }));
            }
            function hasUrlPrefix(opts) {
              if (!opts.prefix) {
                return false;
              }
              var protocol = parseUri(opts.prefix).protocol;
              return protocol === 'http' || protocol === 'https';
            }
            function getHost(name, opts) {
              if (hasUrlPrefix(opts)) {
                var dbName = opts.name.substr(opts.prefix.length);
                name = opts.prefix + encodeURIComponent(dbName);
              }
              var uri = parseUri(name);
              if (uri.user || uri.password) {
                uri.auth = {
                  username: uri.user,
                  password: uri.password
                };
              }
              var parts = uri.path.replace(/(^\/|\/$)/g, '').split('/');
              uri.db = parts.pop();
              if (uri.db.indexOf('%') === -1) {
                uri.db = encodeURIComponent(uri.db);
              }
              uri.path = parts.join('/');
              return uri;
            }
            function genDBUrl(opts, path) {
              return genUrl(opts, opts.db + '/' + path);
            }
            function genUrl(opts, path) {
              var pathDel = !opts.path ? '' : '/';
              return opts.protocol + '://' + opts.host + (opts.port ? ':' + opts.port : '') + '/' + opts.path + pathDel + path;
            }
            function paramsToStr(params) {
              return '?' + Object.keys(params).map(function (k) {
                return k + '=' + encodeURIComponent(params[k]);
              }).join('&');
            }
            function HttpPouch(opts, callback) {
              var api = this;
              var host = getHost(opts.name, opts);
              var dbUrl = genDBUrl(host, '');
              opts = clone(opts);
              var ajaxOpts = opts.ajax || {};
              if (opts.auth || host.auth) {
                var nAuth = opts.auth || host.auth;
                var str = nAuth.username + ':' + nAuth.password;
                var token = thisBtoa(unescape(encodeURIComponent(str)));
                ajaxOpts.headers = ajaxOpts.headers || {};
                ajaxOpts.headers.Authorization = 'Basic ' + token;
              }
              api._ajax = ajax;
              function ajax$$1(userOpts, options, callback) {
                var reqAjax = userOpts.ajax || {};
                var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);
                var defaultHeaders = clone(ajaxOpts.headers || {});
                reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers, options.headers || {});
                if (api.constructor.listeners('debug').length) {
                  api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);
                }
                return api._ajax(reqOpts, callback);
              }
              function ajaxPromise(userOpts, opts) {
                return new PouchPromise$1(function (resolve, reject) {
                  ajax$$1(userOpts, opts, function (err, res) {
                    if (err) {
                      return reject(err);
                    }
                    resolve(res);
                  });
                });
              }
              function adapterFun$$1(name, fun) {
                return adapterFun(name, getArguments(function (args) {
                  setup().then(function () {
                    return fun.apply(this, args);
                  })["catch"](function (e) {
                    var callback = args.pop();
                    callback(e);
                  });
                }));
              }
              var setupPromise;
              function setup() {
                if (opts.skipSetup || opts.skip_setup) {
                  return PouchPromise$1.resolve();
                }
                if (setupPromise) {
                  return setupPromise;
                }
                var checkExists = {
                  method: 'GET',
                  url: dbUrl
                };
                setupPromise = ajaxPromise({}, checkExists)["catch"](function (err) {
                  if (err && err.status && err.status === 404) {
                    explainError(404, 'PouchDB is just detecting if the remote exists.');
                    return ajaxPromise({}, {
                      method: 'PUT',
                      url: dbUrl
                    });
                  } else {
                    return PouchPromise$1.reject(err);
                  }
                })["catch"](function (err) {
                  if (err && err.status && err.status === 412) {
                    return true;
                  }
                  return PouchPromise$1.reject(err);
                });
                setupPromise["catch"](function () {
                  setupPromise = null;
                });
                return setupPromise;
              }
              nextTick(function () {
                callback(null, api);
              });
              api._remote = true;
              api.type = function () {
                return 'http';
              };
              api.id = adapterFun$$1('id', function (callback) {
                ajax$$1({}, {
                  method: 'GET',
                  url: genUrl(host, '')
                }, function (err, result) {
                  var uuid$$1 = result && result.uuid ? result.uuid + host.db : genDBUrl(host, '');
                  callback(null, uuid$$1);
                });
              });
              api.request = adapterFun$$1('request', function (options, callback) {
                options.url = genDBUrl(host, options.url);
                ajax$$1({}, options, callback);
              });
              api.compact = adapterFun$$1('compact', function (opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                opts = clone(opts);
                ajax$$1(opts, {
                  url: genDBUrl(host, '_compact'),
                  method: 'POST'
                }, function () {
                  function ping() {
                    api.info(function (err, res) {
                      if (res && !res.compact_running) {
                        callback(null, { ok: true });
                      } else {
                        setTimeout(ping, opts.interval || 200);
                      }
                    });
                  }
                  ping();
                });
              });
              api.bulkGet = adapterFun('bulkGet', function (opts, callback) {
                var self = this;
                function doBulkGet(cb) {
                  var params = {};
                  if (opts.revs) {
                    params.revs = true;
                  }
                  if (opts.attachments) {
                    params.attachments = true;
                  }
                  if (opts.latest) {
                    params.latest = true;
                  }
                  ajax$$1(opts, {
                    url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),
                    method: 'POST',
                    body: { docs: opts.docs }
                  }, cb);
                }
                function doBulkGetShim() {
                  var batchSize = MAX_SIMULTANEOUS_REVS;
                  var numBatches = Math.ceil(opts.docs.length / batchSize);
                  var numDone = 0;
                  var results = new Array(numBatches);
                  function onResult(batchNum) {
                    return function (err, res) {
                      results[batchNum] = res.results;
                      if (++numDone === numBatches) {
                        callback(null, { results: flatten(results) });
                      }
                    };
                  }
                  for (var i = 0; i < numBatches; i++) {
                    var subOpts = pick(opts, ['revs', 'attachments', 'latest']);
                    subOpts.ajax = ajaxOpts;
                    subOpts.docs = opts.docs.slice(i * batchSize, Math.min(opts.docs.length, (i + 1) * batchSize));
                    bulkGet(self, subOpts, onResult(i));
                  }
                }
                var dbUrl = genUrl(host, '');
                var supportsBulkGet = supportsBulkGetMap[dbUrl];
                if (typeof supportsBulkGet !== 'boolean') {
                  doBulkGet(function (err, res) {
                    if (err) {
                      supportsBulkGetMap[dbUrl] = false;
                      explainError(err.status, 'PouchDB is just detecting if the remote ' + 'supports the _bulk_get API.');
                      doBulkGetShim();
                    } else {
                      supportsBulkGetMap[dbUrl] = true;
                      callback(null, res);
                    }
                  });
                } else if (supportsBulkGet) {
                  doBulkGet(callback);
                } else {
                  doBulkGetShim();
                }
              });
              api._info = function (callback) {
                setup().then(function () {
                  ajax$$1({}, {
                    method: 'GET',
                    url: genDBUrl(host, '')
                  }, function (err, res) {
                    if (err) {
                      return callback(err);
                    }
                    res.host = genDBUrl(host, '');
                    callback(null, res);
                  });
                })["catch"](callback);
              };
              api.get = adapterFun$$1('get', function (id, opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                opts = clone(opts);
                var params = {};
                if (opts.revs) {
                  params.revs = true;
                }
                if (opts.revs_info) {
                  params.revs_info = true;
                }
                if (opts.latest) {
                  params.latest = true;
                }
                if (opts.open_revs) {
                  if (opts.open_revs !== "all") {
                    opts.open_revs = JSON.stringify(opts.open_revs);
                  }
                  params.open_revs = opts.open_revs;
                }
                if (opts.rev) {
                  params.rev = opts.rev;
                }
                if (opts.conflicts) {
                  params.conflicts = opts.conflicts;
                }
                id = encodeDocId(id);
                var options = {
                  method: 'GET',
                  url: genDBUrl(host, id + paramsToStr(params))
                };
                function fetchAttachments(doc) {
                  var atts = doc._attachments;
                  var filenames = atts && Object.keys(atts);
                  if (!atts || !filenames.length) {
                    return;
                  }
                  function fetch(filename) {
                    var att = atts[filename];
                    var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) + '?rev=' + doc._rev;
                    return ajaxPromise(opts, {
                      method: 'GET',
                      url: genDBUrl(host, path),
                      binary: true
                    }).then(function (blob) {
                      if (opts.binary) {
                        return blob;
                      }
                      return new PouchPromise$1(function (resolve) {
                        blobToBase64(blob, resolve);
                      });
                    }).then(function (data) {
                      delete att.stub;
                      delete att.length;
                      att.data = data;
                    });
                  }
                  var promiseFactories = filenames.map(function (filename) {
                    return function () {
                      return fetch(filename);
                    };
                  });
                  return pool(promiseFactories, 5);
                }
                function fetchAllAttachments(docOrDocs) {
                  if (Array.isArray(docOrDocs)) {
                    return PouchPromise$1.all(docOrDocs.map(function (doc) {
                      if (doc.ok) {
                        return fetchAttachments(doc.ok);
                      }
                    }));
                  }
                  return fetchAttachments(docOrDocs);
                }
                ajaxPromise(opts, options).then(function (res) {
                  return PouchPromise$1.resolve().then(function () {
                    if (opts.attachments) {
                      return fetchAllAttachments(res);
                    }
                  }).then(function () {
                    callback(null, res);
                  });
                })["catch"](function (e) {
                  e.docId = id;
                  callback(e);
                });
              });
              api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, callback) {
                var doc;
                if (typeof optsOrRev === 'string') {
                  doc = {
                    _id: docOrId,
                    _rev: optsOrRev
                  };
                  if (typeof opts === 'function') {
                    callback = opts;
                    opts = {};
                  }
                } else {
                  doc = docOrId;
                  if (typeof optsOrRev === 'function') {
                    callback = optsOrRev;
                    opts = {};
                  } else {
                    callback = opts;
                    opts = optsOrRev;
                  }
                }
                var rev$$1 = doc._rev || opts.rev;
                ajax$$1(opts, {
                  method: 'DELETE',
                  url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1
                }, callback);
              });
              function encodeAttachmentId(attachmentId) {
                return attachmentId.split("/").map(encodeURIComponent).join("/");
              }
              api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId, opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                var params = opts.rev ? '?rev=' + opts.rev : '';
                var url = genDBUrl(host, encodeDocId(docId)) + '/' + encodeAttachmentId(attachmentId) + params;
                ajax$$1(opts, {
                  method: 'GET',
                  url: url,
                  binary: true
                }, callback);
              });
              api.removeAttachment = adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1, callback) {
                var url = genDBUrl(host, encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;
                ajax$$1({}, {
                  method: 'DELETE',
                  url: url
                }, callback);
              });
              api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob, type, callback) {
                if (typeof type === 'function') {
                  callback = type;
                  type = blob;
                  blob = rev$$1;
                  rev$$1 = null;
                }
                var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);
                var url = genDBUrl(host, id);
                if (rev$$1) {
                  url += '?rev=' + rev$$1;
                }
                if (typeof blob === 'string') {
                  var binary;
                  try {
                    binary = thisAtob(blob);
                  } catch (err) {
                    return callback(createError(BAD_ARG, 'Attachment is not a valid base64 string'));
                  }
                  blob = binary ? binStringToBluffer(binary, type) : '';
                }
                var opts = {
                  headers: { 'Content-Type': type },
                  method: 'PUT',
                  url: url,
                  processData: false,
                  body: blob,
                  timeout: ajaxOpts.timeout || 60000
                };
                ajax$$1({}, opts, callback);
              });
              api._bulkDocs = function (req, opts, callback) {
                req.new_edits = opts.new_edits;
                setup().then(function () {
                  return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));
                }).then(function () {
                  ajax$$1(opts, {
                    method: 'POST',
                    url: genDBUrl(host, '_bulk_docs'),
                    timeout: opts.timeout,
                    body: req
                  }, function (err, results) {
                    if (err) {
                      return callback(err);
                    }
                    results.forEach(function (result) {
                      result.ok = true;
                    });
                    callback(null, results);
                  });
                })["catch"](callback);
              };
              api._put = function (doc, opts, callback) {
                setup().then(function () {
                  return preprocessAttachments$2(doc);
                }).then(function () {
                  ajax$$1(opts, {
                    method: 'PUT',
                    url: genDBUrl(host, encodeDocId(doc._id)),
                    body: doc
                  }, function (err, result) {
                    if (err) {
                      err.docId = doc && doc._id;
                      return callback(err);
                    }
                    callback(null, result);
                  });
                })["catch"](callback);
              };
              api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                opts = clone(opts);
                var params = {};
                var body;
                var method = 'GET';
                if (opts.conflicts) {
                  params.conflicts = true;
                }
                if (opts.descending) {
                  params.descending = true;
                }
                if (opts.include_docs) {
                  params.include_docs = true;
                }
                if (opts.attachments) {
                  params.attachments = true;
                }
                if (opts.key) {
                  params.key = JSON.stringify(opts.key);
                }
                if (opts.start_key) {
                  opts.startkey = opts.start_key;
                }
                if (opts.startkey) {
                  params.startkey = JSON.stringify(opts.startkey);
                }
                if (opts.end_key) {
                  opts.endkey = opts.end_key;
                }
                if (opts.endkey) {
                  params.endkey = JSON.stringify(opts.endkey);
                }
                if (typeof opts.inclusive_end !== 'undefined') {
                  params.inclusive_end = !!opts.inclusive_end;
                }
                if (typeof opts.limit !== 'undefined') {
                  params.limit = opts.limit;
                }
                if (typeof opts.skip !== 'undefined') {
                  params.skip = opts.skip;
                }
                var paramStr = paramsToStr(params);
                if (typeof opts.keys !== 'undefined') {
                  method = 'POST';
                  body = { keys: opts.keys };
                }
                ajaxPromise(opts, {
                  method: method,
                  url: genDBUrl(host, '_all_docs' + paramStr),
                  body: body
                }).then(function (res) {
                  if (opts.include_docs && opts.attachments && opts.binary) {
                    res.rows.forEach(readAttachmentsAsBlobOrBuffer);
                  }
                  callback(null, res);
                })["catch"](callback);
              });
              api._changes = function (opts) {
                var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;
                opts = clone(opts);
                if (opts.continuous && !('heartbeat' in opts)) {
                  opts.heartbeat = DEFAULT_HEARTBEAT;
                }
                var requestTimeout = 'timeout' in opts ? opts.timeout : 'timeout' in ajaxOpts ? ajaxOpts.timeout : 30 * 1000;
                if ('timeout' in opts && opts.timeout && requestTimeout - opts.timeout < CHANGES_TIMEOUT_BUFFER) {
                  requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;
                }
                if ('heartbeat' in opts && opts.heartbeat && requestTimeout - opts.heartbeat < CHANGES_TIMEOUT_BUFFER) {
                  requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;
                }
                var params = {};
                if ('timeout' in opts && opts.timeout) {
                  params.timeout = opts.timeout;
                }
                var limit = typeof opts.limit !== 'undefined' ? opts.limit : false;
                var returnDocs;
                if ('return_docs' in opts) {
                  returnDocs = opts.return_docs;
                } else if ('returnDocs' in opts) {
                  returnDocs = opts.returnDocs;
                } else {
                  returnDocs = true;
                }
                var leftToFetch = limit;
                if (opts.style) {
                  params.style = opts.style;
                }
                if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {
                  params.include_docs = true;
                }
                if (opts.attachments) {
                  params.attachments = true;
                }
                if (opts.continuous) {
                  params.feed = 'longpoll';
                }
                if (opts.conflicts) {
                  params.conflicts = true;
                }
                if (opts.descending) {
                  params.descending = true;
                }
                if ('heartbeat' in opts) {
                  if (opts.heartbeat) {
                    params.heartbeat = opts.heartbeat;
                  }
                }
                if (opts.filter && typeof opts.filter === 'string') {
                  params.filter = opts.filter;
                }
                if (opts.view && typeof opts.view === 'string') {
                  params.filter = '_view';
                  params.view = opts.view;
                }
                if (opts.query_params && typeof opts.query_params === 'object') {
                  for (var param_name in opts.query_params) {
                    if (opts.query_params.hasOwnProperty(param_name)) {
                      params[param_name] = opts.query_params[param_name];
                    }
                  }
                }
                var method = 'GET';
                var body;
                if (opts.doc_ids) {
                  params.filter = '_doc_ids';
                  method = 'POST';
                  body = { doc_ids: opts.doc_ids };
                } else if (opts.selector) {
                  params.filter = '_selector';
                  method = 'POST';
                  body = { selector: opts.selector };
                }
                var xhr;
                var lastFetchedSeq;
                var fetch = function (since, callback) {
                  if (opts.aborted) {
                    return;
                  }
                  params.since = since;
                  if (typeof params.since === "object") {
                    params.since = JSON.stringify(params.since);
                  }
                  if (opts.descending) {
                    if (limit) {
                      params.limit = leftToFetch;
                    }
                  } else {
                    params.limit = !limit || leftToFetch > batchSize ? batchSize : leftToFetch;
                  }
                  var xhrOpts = {
                    method: method,
                    url: genDBUrl(host, '_changes' + paramsToStr(params)),
                    timeout: requestTimeout,
                    body: body
                  };
                  lastFetchedSeq = since;
                  if (opts.aborted) {
                    return;
                  }
                  setup().then(function () {
                    xhr = ajax$$1(opts, xhrOpts, callback);
                  })["catch"](callback);
                };
                var results = { results: [] };
                var fetched = function (err, res) {
                  if (opts.aborted) {
                    return;
                  }
                  var raw_results_length = 0;
                  if (res && res.results) {
                    raw_results_length = res.results.length;
                    results.last_seq = res.last_seq;
                    var req = {};
                    req.query = opts.query_params;
                    res.results = res.results.filter(function (c) {
                      leftToFetch--;
                      var ret = filterChange(opts)(c);
                      if (ret) {
                        if (opts.include_docs && opts.attachments && opts.binary) {
                          readAttachmentsAsBlobOrBuffer(c);
                        }
                        if (returnDocs) {
                          results.results.push(c);
                        }
                        opts.onChange(c);
                      }
                      return ret;
                    });
                  } else if (err) {
                    opts.aborted = true;
                    opts.complete(err);
                    return;
                  }
                  if (res && res.last_seq) {
                    lastFetchedSeq = res.last_seq;
                  }
                  var finished = limit && leftToFetch <= 0 || res && raw_results_length < batchSize || opts.descending;
                  if (opts.continuous && !(limit && leftToFetch <= 0) || !finished) {
                    nextTick(function () {
                      fetch(lastFetchedSeq, fetched);
                    });
                  } else {
                    opts.complete(null, results);
                  }
                };
                fetch(opts.since || 0, fetched);
                return { cancel: function () {
                    opts.aborted = true;
                    if (xhr) {
                      xhr.abort();
                    }
                  } };
              };
              api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                ajax$$1(opts, {
                  method: 'POST',
                  url: genDBUrl(host, '_revs_diff'),
                  body: req
                }, callback);
              });
              api._close = function (callback) {
                callback();
              };
              api._destroy = function (options, callback) {
                ajax$$1(options, {
                  url: genDBUrl(host, ''),
                  method: 'DELETE'
                }, function (err, resp) {
                  if (err && err.status && err.status !== 404) {
                    return callback(err);
                  }
                  callback(null, resp);
                });
              };
            }
            HttpPouch.valid = function () {
              return true;
            };
            var HttpPouch$1 = function (PouchDB) {
              PouchDB.adapter('http', HttpPouch, false);
              PouchDB.adapter('https', HttpPouch, false);
            };
            function QueryParseError(message) {
              this.status = 400;
              this.name = 'query_parse_error';
              this.message = message;
              this.error = true;
              try {
                Error.captureStackTrace(this, QueryParseError);
              } catch (e) {}
            }
            inherits(QueryParseError, Error);
            function NotFoundError(message) {
              this.status = 404;
              this.name = 'not_found';
              this.message = message;
              this.error = true;
              try {
                Error.captureStackTrace(this, NotFoundError);
              } catch (e) {}
            }
            inherits(NotFoundError, Error);
            function BuiltInError(message) {
              this.status = 500;
              this.name = 'invalid_value';
              this.message = message;
              this.error = true;
              try {
                Error.captureStackTrace(this, BuiltInError);
              } catch (e) {}
            }
            inherits(BuiltInError, Error);
            function promisedCallback(promise, callback) {
              if (callback) {
                promise.then(function (res) {
                  nextTick(function () {
                    callback(null, res);
                  });
                }, function (reason) {
                  nextTick(function () {
                    callback(reason);
                  });
                });
              }
              return promise;
            }
            function callbackify(fun) {
              return getArguments(function (args) {
                var cb = args.pop();
                var promise = fun.apply(this, args);
                if (typeof cb === 'function') {
                  promisedCallback(promise, cb);
                }
                return promise;
              });
            }
            function fin(promise, finalPromiseFactory) {
              return promise.then(function (res) {
                return finalPromiseFactory().then(function () {
                  return res;
                });
              }, function (reason) {
                return finalPromiseFactory().then(function () {
                  throw reason;
                });
              });
            }
            function sequentialize(queue, promiseFactory) {
              return function () {
                var args = arguments;
                var that = this;
                return queue.add(function () {
                  return promiseFactory.apply(that, args);
                });
              };
            }
            function uniq(arr) {
              var theSet = new ExportedSet(arr);
              var result = new Array(theSet.size);
              var index = -1;
              theSet.forEach(function (value) {
                result[++index] = value;
              });
              return result;
            }
            function mapToKeysArray(map) {
              var result = new Array(map.size);
              var index = -1;
              map.forEach(function (value, key) {
                result[++index] = key;
              });
              return result;
            }
            function createBuiltInError(name) {
              var message = 'builtin ' + name + ' function requires map values to be numbers' + ' or number arrays';
              return new BuiltInError(message);
            }
            function sum(values) {
              var result = 0;
              for (var i = 0, len = values.length; i < len; i++) {
                var num = values[i];
                if (typeof num !== 'number') {
                  if (Array.isArray(num)) {
                    result = typeof result === 'number' ? [result] : result;
                    for (var j = 0, jLen = num.length; j < jLen; j++) {
                      var jNum = num[j];
                      if (typeof jNum !== 'number') {
                        throw createBuiltInError('_sum');
                      } else if (typeof result[j] === 'undefined') {
                        result.push(jNum);
                      } else {
                        result[j] += jNum;
                      }
                    }
                  } else {
                    throw createBuiltInError('_sum');
                  }
                } else if (typeof result === 'number') {
                  result += num;
                } else {
                  result[0] += num;
                }
              }
              return result;
            }
            var log = guardedConsole.bind(null, 'log');
            var isArray = Array.isArray;
            var toJSON = JSON.parse;
            function evalFunctionWithEval(func, emit) {
              return scopeEval("return (" + func.replace(/;\s*$/, "") + ");", {
                emit: emit,
                sum: sum,
                log: log,
                isArray: isArray,
                toJSON: toJSON
              });
            }
            function TaskQueue$2() {
              this.promise = new PouchPromise$1(function (fulfill) {
                fulfill();
              });
            }
            TaskQueue$2.prototype.add = function (promiseFactory) {
              this.promise = this.promise["catch"](function () {}).then(function () {
                return promiseFactory();
              });
              return this.promise;
            };
            TaskQueue$2.prototype.finish = function () {
              return this.promise;
            };
            function stringify(input) {
              if (!input) {
                return 'undefined';
              }
              switch (typeof input) {
                case 'function':
                  return input.toString();
                case 'string':
                  return input.toString();
                default:
                  return JSON.stringify(input);
              }
            }
            function createViewSignature(mapFun, reduceFun) {
              return stringify(mapFun) + stringify(reduceFun) + 'undefined';
            }
            function createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {
              var viewSignature = createViewSignature(mapFun, reduceFun);
              var cachedViews;
              if (!temporary) {
                cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};
                if (cachedViews[viewSignature]) {
                  return cachedViews[viewSignature];
                }
              }
              var promiseForView = sourceDB.info().then(function (info) {
                var depDbName = info.db_name + '-mrview-' + (temporary ? 'temp' : stringMd5(viewSignature));
                function diffFunction(doc) {
                  doc.views = doc.views || {};
                  var fullViewName = viewName;
                  if (fullViewName.indexOf('/') === -1) {
                    fullViewName = viewName + '/' + viewName;
                  }
                  var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};
                  if (depDbs[depDbName]) {
                    return;
                  }
                  depDbs[depDbName] = true;
                  return doc;
                }
                return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {
                  return sourceDB.registerDependentDatabase(depDbName).then(function (res) {
                    var db = res.db;
                    db.auto_compaction = true;
                    var view = {
                      name: depDbName,
                      db: db,
                      sourceDB: sourceDB,
                      adapter: sourceDB.adapter,
                      mapFun: mapFun,
                      reduceFun: reduceFun
                    };
                    return view.db.get('_local/lastSeq')["catch"](function (err) {
                      if (err.status !== 404) {
                        throw err;
                      }
                    }).then(function (lastSeqDoc) {
                      view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;
                      if (cachedViews) {
                        view.db.once('destroyed', function () {
                          delete cachedViews[viewSignature];
                        });
                      }
                      return view;
                    });
                  });
                });
              });
              if (cachedViews) {
                cachedViews[viewSignature] = promiseForView;
              }
              return promiseForView;
            }
            var persistentQueues = {};
            var tempViewQueue = new TaskQueue$2();
            var CHANGES_BATCH_SIZE$1 = 50;
            function parseViewName(name) {
              return name.indexOf('/') === -1 ? [name, name] : name.split('/');
            }
            function isGenOne(changes) {
              return changes.length === 1 && /^1-/.test(changes[0].rev);
            }
            function emitError(db, e) {
              try {
                db.emit('error', e);
              } catch (err) {
                guardedConsole('error', 'The user\'s map/reduce function threw an uncaught error.\n' + 'You can debug this error by doing:\n' + 'myDatabase.on(\'error\', function (err) { debugger; });\n' + 'Please double-check your map/reduce function.');
                guardedConsole('error', e);
              }
            }
            function createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {
              function tryMap(db, fun, doc) {
                try {
                  fun(doc);
                } catch (e) {
                  emitError(db, e);
                }
              }
              function tryReduce(db, fun, keys, values, rereduce) {
                try {
                  return { output: fun(keys, values, rereduce) };
                } catch (e) {
                  emitError(db, e);
                  return { error: e };
                }
              }
              function sortByKeyThenValue(x, y) {
                var keyCompare = collate(x.key, y.key);
                return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);
              }
              function sliceResults(results, limit, skip) {
                skip = skip || 0;
                if (typeof limit === 'number') {
                  return results.slice(skip, limit + skip);
                } else if (skip > 0) {
                  return results.slice(skip);
                }
                return results;
              }
              function rowToDocId(row) {
                var val = row.value;
                var docId = val && typeof val === 'object' && val._id || row.id;
                return docId;
              }
              function readAttachmentsAsBlobOrBuffer(res) {
                res.rows.forEach(function (row) {
                  var atts = row.doc && row.doc._attachments;
                  if (!atts) {
                    return;
                  }
                  Object.keys(atts).forEach(function (filename) {
                    var att = atts[filename];
                    atts[filename].data = b64ToBluffer(att.data, att.content_type);
                  });
                });
              }
              function postprocessAttachments(opts) {
                return function (res) {
                  if (opts.include_docs && opts.attachments && opts.binary) {
                    readAttachmentsAsBlobOrBuffer(res);
                  }
                  return res;
                };
              }
              function addHttpParam(paramName, opts, params, asJson) {
                var val = opts[paramName];
                if (typeof val !== 'undefined') {
                  if (asJson) {
                    val = encodeURIComponent(JSON.stringify(val));
                  }
                  params.push(paramName + '=' + val);
                }
              }
              function coerceInteger(integerCandidate) {
                if (typeof integerCandidate !== 'undefined') {
                  var asNumber = Number(integerCandidate);
                  if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {
                    return asNumber;
                  } else {
                    return integerCandidate;
                  }
                }
              }
              function coerceOptions(opts) {
                opts.group_level = coerceInteger(opts.group_level);
                opts.limit = coerceInteger(opts.limit);
                opts.skip = coerceInteger(opts.skip);
                return opts;
              }
              function checkPositiveInteger(number) {
                if (number) {
                  if (typeof number !== 'number') {
                    return new QueryParseError('Invalid value for integer: "' + number + '"');
                  }
                  if (number < 0) {
                    return new QueryParseError('Invalid value for positive integer: ' + '"' + number + '"');
                  }
                }
              }
              function checkQueryParseError(options, fun) {
                var startkeyName = options.descending ? 'endkey' : 'startkey';
                var endkeyName = options.descending ? 'startkey' : 'endkey';
                if (typeof options[startkeyName] !== 'undefined' && typeof options[endkeyName] !== 'undefined' && collate(options[startkeyName], options[endkeyName]) > 0) {
                  throw new QueryParseError('No rows can match your key range, ' + 'reverse your start_key and end_key or set {descending : true}');
                } else if (fun.reduce && options.reduce !== false) {
                  if (options.include_docs) {
                    throw new QueryParseError('{include_docs:true} is invalid for reduce');
                  } else if (options.keys && options.keys.length > 1 && !options.group && !options.group_level) {
                    throw new QueryParseError('Multi-key fetches for reduce views must use ' + '{group: true}');
                  }
                }
                ['group_level', 'limit', 'skip'].forEach(function (optionName) {
                  var error = checkPositiveInteger(options[optionName]);
                  if (error) {
                    throw error;
                  }
                });
              }
              function httpQuery(db, fun, opts) {
                var params = [];
                var body;
                var method = 'GET';
                addHttpParam('reduce', opts, params);
                addHttpParam('include_docs', opts, params);
                addHttpParam('attachments', opts, params);
                addHttpParam('limit', opts, params);
                addHttpParam('descending', opts, params);
                addHttpParam('group', opts, params);
                addHttpParam('group_level', opts, params);
                addHttpParam('skip', opts, params);
                addHttpParam('stale', opts, params);
                addHttpParam('conflicts', opts, params);
                addHttpParam('startkey', opts, params, true);
                addHttpParam('start_key', opts, params, true);
                addHttpParam('endkey', opts, params, true);
                addHttpParam('end_key', opts, params, true);
                addHttpParam('inclusive_end', opts, params);
                addHttpParam('key', opts, params, true);
                params = params.join('&');
                params = params === '' ? '' : '?' + params;
                if (typeof opts.keys !== 'undefined') {
                  var MAX_URL_LENGTH = 2000;
                  var keysAsString = 'keys=' + encodeURIComponent(JSON.stringify(opts.keys));
                  if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {
                    params += (params[0] === '?' ? '&' : '?') + keysAsString;
                  } else {
                    method = 'POST';
                    if (typeof fun === 'string') {
                      body = { keys: opts.keys };
                    } else {
                      fun.keys = opts.keys;
                    }
                  }
                }
                if (typeof fun === 'string') {
                  var parts = parseViewName(fun);
                  return db.request({
                    method: method,
                    url: '_design/' + parts[0] + '/_view/' + parts[1] + params,
                    body: body
                  }).then(function (result) {
                    result.rows.forEach(function (row) {
                      if (row.value && row.value.error && row.value.error === "builtin_reduce_error") {
                        throw new Error(row.reason);
                      }
                    });
                    return result;
                  }).then(postprocessAttachments(opts));
                }
                body = body || {};
                Object.keys(fun).forEach(function (key) {
                  if (Array.isArray(fun[key])) {
                    body[key] = fun[key];
                  } else {
                    body[key] = fun[key].toString();
                  }
                });
                return db.request({
                  method: 'POST',
                  url: '_temp_view' + params,
                  body: body
                }).then(postprocessAttachments(opts));
              }
              function customQuery(db, fun, opts) {
                return new PouchPromise$1(function (resolve, reject) {
                  db._query(fun, opts, function (err, res) {
                    if (err) {
                      return reject(err);
                    }
                    resolve(res);
                  });
                });
              }
              function customViewCleanup(db) {
                return new PouchPromise$1(function (resolve, reject) {
                  db._viewCleanup(function (err, res) {
                    if (err) {
                      return reject(err);
                    }
                    resolve(res);
                  });
                });
              }
              function defaultsTo(value) {
                return function (reason) {
                  if (reason.status === 404) {
                    return value;
                  } else {
                    throw reason;
                  }
                };
              }
              function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {
                var metaDocId = '_local/doc_' + docId;
                var defaultMetaDoc = {
                  _id: metaDocId,
                  keys: []
                };
                var docData = docIdsToChangesAndEmits.get(docId);
                var indexableKeysToKeyValues = docData[0];
                var changes = docData[1];
                function getMetaDoc() {
                  if (isGenOne(changes)) {
                    return PouchPromise$1.resolve(defaultMetaDoc);
                  }
                  return view.db.get(metaDocId)["catch"](defaultsTo(defaultMetaDoc));
                }
                function getKeyValueDocs(metaDoc) {
                  if (!metaDoc.keys.length) {
                    return PouchPromise$1.resolve({ rows: [] });
                  }
                  return view.db.allDocs({
                    keys: metaDoc.keys,
                    include_docs: true
                  });
                }
                function processKeyValueDocs(metaDoc, kvDocsRes) {
                  var kvDocs = [];
                  var oldKeys = new ExportedSet();
                  for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {
                    var row = kvDocsRes.rows[i];
                    var doc = row.doc;
                    if (!doc) {
                      continue;
                    }
                    kvDocs.push(doc);
                    oldKeys.add(doc._id);
                    doc._deleted = !indexableKeysToKeyValues.has(doc._id);
                    if (!doc._deleted) {
                      var keyValue = indexableKeysToKeyValues.get(doc._id);
                      if ('value' in keyValue) {
                        doc.value = keyValue.value;
                      }
                    }
                  }
                  var newKeys = mapToKeysArray(indexableKeysToKeyValues);
                  newKeys.forEach(function (key) {
                    if (!oldKeys.has(key)) {
                      var kvDoc = { _id: key };
                      var keyValue = indexableKeysToKeyValues.get(key);
                      if ('value' in keyValue) {
                        kvDoc.value = keyValue.value;
                      }
                      kvDocs.push(kvDoc);
                    }
                  });
                  metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));
                  kvDocs.push(metaDoc);
                  return kvDocs;
                }
                return getMetaDoc().then(function (metaDoc) {
                  return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {
                    return processKeyValueDocs(metaDoc, kvDocsRes);
                  });
                });
              }
              function saveKeyValues(view, docIdsToChangesAndEmits, seq) {
                var seqDocId = '_local/lastSeq';
                return view.db.get(seqDocId)["catch"](defaultsTo({
                  _id: seqDocId,
                  seq: 0
                })).then(function (lastSeqDoc) {
                  var docIds = mapToKeysArray(docIdsToChangesAndEmits);
                  return PouchPromise$1.all(docIds.map(function (docId) {
                    return getDocsToPersist(docId, view, docIdsToChangesAndEmits);
                  })).then(function (listOfDocsToPersist) {
                    var docsToPersist = flatten(listOfDocsToPersist);
                    lastSeqDoc.seq = seq;
                    docsToPersist.push(lastSeqDoc);
                    return view.db.bulkDocs({ docs: docsToPersist });
                  });
                });
              }
              function getQueue(view) {
                var viewName = typeof view === 'string' ? view : view.name;
                var queue = persistentQueues[viewName];
                if (!queue) {
                  queue = persistentQueues[viewName] = new TaskQueue$2();
                }
                return queue;
              }
              function updateView(view) {
                return sequentialize(getQueue(view), function () {
                  return updateViewInQueue(view);
                })();
              }
              function updateViewInQueue(view) {
                var mapResults;
                var doc;
                function emit(key, value) {
                  var output = {
                    id: doc._id,
                    key: normalizeKey(key)
                  };
                  if (typeof value !== 'undefined' && value !== null) {
                    output.value = normalizeKey(value);
                  }
                  mapResults.push(output);
                }
                var mapFun = mapper(view.mapFun, emit);
                var currentSeq = view.seq || 0;
                function processChange(docIdsToChangesAndEmits, seq) {
                  return function () {
                    return saveKeyValues(view, docIdsToChangesAndEmits, seq);
                  };
                }
                var queue = new TaskQueue$2();
                function processNextBatch() {
                  return view.sourceDB.changes({
                    conflicts: true,
                    include_docs: true,
                    style: 'all_docs',
                    since: currentSeq,
                    limit: CHANGES_BATCH_SIZE$1
                  }).then(processBatch);
                }
                function processBatch(response) {
                  var results = response.results;
                  if (!results.length) {
                    return;
                  }
                  var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);
                  queue.add(processChange(docIdsToChangesAndEmits, currentSeq));
                  if (results.length < CHANGES_BATCH_SIZE$1) {
                    return;
                  }
                  return processNextBatch();
                }
                function createDocIdsToChangesAndEmits(results) {
                  var docIdsToChangesAndEmits = new ExportedMap();
                  for (var i = 0, len = results.length; i < len; i++) {
                    var change = results[i];
                    if (change.doc._id[0] !== '_') {
                      mapResults = [];
                      doc = change.doc;
                      if (!doc._deleted) {
                        tryMap(view.sourceDB, mapFun, doc);
                      }
                      mapResults.sort(sortByKeyThenValue);
                      var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);
                      docIdsToChangesAndEmits.set(change.doc._id, [indexableKeysToKeyValues, change.changes]);
                    }
                    currentSeq = change.seq;
                  }
                  return docIdsToChangesAndEmits;
                }
                function createIndexableKeysToKeyValues(mapResults) {
                  var indexableKeysToKeyValues = new ExportedMap();
                  var lastKey;
                  for (var i = 0, len = mapResults.length; i < len; i++) {
                    var emittedKeyValue = mapResults[i];
                    var complexKey = [emittedKeyValue.key, emittedKeyValue.id];
                    if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {
                      complexKey.push(i);
                    }
                    indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);
                    lastKey = emittedKeyValue.key;
                  }
                  return indexableKeysToKeyValues;
                }
                return processNextBatch().then(function () {
                  return queue.finish();
                }).then(function () {
                  view.seq = currentSeq;
                });
              }
              function reduceView(view, results, options) {
                if (options.group_level === 0) {
                  delete options.group_level;
                }
                var shouldGroup = options.group || options.group_level;
                var reduceFun = reducer(view.reduceFun);
                var groups = [];
                var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY : options.group_level;
                results.forEach(function (e) {
                  var last = groups[groups.length - 1];
                  var groupKey = shouldGroup ? e.key : null;
                  if (shouldGroup && Array.isArray(groupKey)) {
                    groupKey = groupKey.slice(0, lvl);
                  }
                  if (last && collate(last.groupKey, groupKey) === 0) {
                    last.keys.push([e.key, e.id]);
                    last.values.push(e.value);
                    return;
                  }
                  groups.push({
                    keys: [[e.key, e.id]],
                    values: [e.value],
                    groupKey: groupKey
                  });
                });
                results = [];
                for (var i = 0, len = groups.length; i < len; i++) {
                  var e = groups[i];
                  var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);
                  if (reduceTry.error && reduceTry.error instanceof BuiltInError) {
                    throw reduceTry.error;
                  }
                  results.push({
                    value: reduceTry.error ? null : reduceTry.output,
                    key: e.groupKey
                  });
                }
                return { rows: sliceResults(results, options.limit, options.skip) };
              }
              function queryView(view, opts) {
                return sequentialize(getQueue(view), function () {
                  return queryViewInQueue(view, opts);
                })();
              }
              function queryViewInQueue(view, opts) {
                var totalRows;
                var shouldReduce = view.reduceFun && opts.reduce !== false;
                var skip = opts.skip || 0;
                if (typeof opts.keys !== 'undefined' && !opts.keys.length) {
                  opts.limit = 0;
                  delete opts.keys;
                }
                function fetchFromView(viewOpts) {
                  viewOpts.include_docs = true;
                  return view.db.allDocs(viewOpts).then(function (res) {
                    totalRows = res.total_rows;
                    return res.rows.map(function (result) {
                      if ('value' in result.doc && typeof result.doc.value === 'object' && result.doc.value !== null) {
                        var keys = Object.keys(result.doc.value).sort();
                        var expectedKeys = ['id', 'key', 'value'];
                        if (!(keys < expectedKeys || keys > expectedKeys)) {
                          return result.doc.value;
                        }
                      }
                      var parsedKeyAndDocId = parseIndexableString(result.doc._id);
                      return {
                        key: parsedKeyAndDocId[0],
                        id: parsedKeyAndDocId[1],
                        value: 'value' in result.doc ? result.doc.value : null
                      };
                    });
                  });
                }
                function onMapResultsReady(rows) {
                  var finalResults;
                  if (shouldReduce) {
                    finalResults = reduceView(view, rows, opts);
                  } else {
                    finalResults = {
                      total_rows: totalRows,
                      offset: skip,
                      rows: rows
                    };
                  }
                  if (opts.include_docs) {
                    var docIds = uniq(rows.map(rowToDocId));
                    return view.sourceDB.allDocs({
                      keys: docIds,
                      include_docs: true,
                      conflicts: opts.conflicts,
                      attachments: opts.attachments,
                      binary: opts.binary
                    }).then(function (allDocsRes) {
                      var docIdsToDocs = new ExportedMap();
                      allDocsRes.rows.forEach(function (row) {
                        docIdsToDocs.set(row.id, row.doc);
                      });
                      rows.forEach(function (row) {
                        var docId = rowToDocId(row);
                        var doc = docIdsToDocs.get(docId);
                        if (doc) {
                          row.doc = doc;
                        }
                      });
                      return finalResults;
                    });
                  } else {
                    return finalResults;
                  }
                }
                if (typeof opts.keys !== 'undefined') {
                  var keys = opts.keys;
                  var fetchPromises = keys.map(function (key) {
                    var viewOpts = {
                      startkey: toIndexableString([key]),
                      endkey: toIndexableString([key, {}])
                    };
                    return fetchFromView(viewOpts);
                  });
                  return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);
                } else {
                  var viewOpts = { descending: opts.descending };
                  var startkey;
                  var endkey;
                  if ('start_key' in opts) {
                    startkey = opts.start_key;
                  }
                  if ('startkey' in opts) {
                    startkey = opts.startkey;
                  }
                  if ('end_key' in opts) {
                    endkey = opts.end_key;
                  }
                  if ('endkey' in opts) {
                    endkey = opts.endkey;
                  }
                  if (typeof startkey !== 'undefined') {
                    viewOpts.startkey = opts.descending ? toIndexableString([startkey, {}]) : toIndexableString([startkey]);
                  }
                  if (typeof endkey !== 'undefined') {
                    var inclusiveEnd = opts.inclusive_end !== false;
                    if (opts.descending) {
                      inclusiveEnd = !inclusiveEnd;
                    }
                    viewOpts.endkey = toIndexableString(inclusiveEnd ? [endkey, {}] : [endkey]);
                  }
                  if (typeof opts.key !== 'undefined') {
                    var keyStart = toIndexableString([opts.key]);
                    var keyEnd = toIndexableString([opts.key, {}]);
                    if (viewOpts.descending) {
                      viewOpts.endkey = keyStart;
                      viewOpts.startkey = keyEnd;
                    } else {
                      viewOpts.startkey = keyStart;
                      viewOpts.endkey = keyEnd;
                    }
                  }
                  if (!shouldReduce) {
                    if (typeof opts.limit === 'number') {
                      viewOpts.limit = opts.limit;
                    }
                    viewOpts.skip = skip;
                  }
                  return fetchFromView(viewOpts).then(onMapResultsReady);
                }
              }
              function httpViewCleanup(db) {
                return db.request({
                  method: 'POST',
                  url: '_view_cleanup'
                });
              }
              function localViewCleanup(db) {
                return db.get('_local/' + localDocName).then(function (metaDoc) {
                  var docsToViews = new ExportedMap();
                  Object.keys(metaDoc.views).forEach(function (fullViewName) {
                    var parts = parseViewName(fullViewName);
                    var designDocName = '_design/' + parts[0];
                    var viewName = parts[1];
                    var views = docsToViews.get(designDocName);
                    if (!views) {
                      views = new ExportedSet();
                      docsToViews.set(designDocName, views);
                    }
                    views.add(viewName);
                  });
                  var opts = {
                    keys: mapToKeysArray(docsToViews),
                    include_docs: true
                  };
                  return db.allDocs(opts).then(function (res) {
                    var viewsToStatus = {};
                    res.rows.forEach(function (row) {
                      var ddocName = row.key.substring(8);
                      docsToViews.get(row.key).forEach(function (viewName) {
                        var fullViewName = ddocName + '/' + viewName;
                        if (!metaDoc.views[fullViewName]) {
                          fullViewName = viewName;
                        }
                        var viewDBNames = Object.keys(metaDoc.views[fullViewName]);
                        var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];
                        viewDBNames.forEach(function (viewDBName) {
                          viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;
                        });
                      });
                    });
                    var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {
                      return !viewsToStatus[viewDBName];
                    });
                    var destroyPromises = dbsToDelete.map(function (viewDBName) {
                      return sequentialize(getQueue(viewDBName), function () {
                        return new db.constructor(viewDBName, db.__opts).destroy();
                      })();
                    });
                    return PouchPromise$1.all(destroyPromises).then(function () {
                      return { ok: true };
                    });
                  });
                }, defaultsTo({ ok: true }));
              }
              function queryPromised(db, fun, opts) {
                if (typeof db._query === 'function') {
                  return customQuery(db, fun, opts);
                }
                if (isRemote(db)) {
                  return httpQuery(db, fun, opts);
                }
                if (typeof fun !== 'string') {
                  checkQueryParseError(opts, fun);
                  tempViewQueue.add(function () {
                    var createViewPromise = createView(db, 'temp_view/temp_view', fun.map, fun.reduce, true, localDocName);
                    return createViewPromise.then(function (view) {
                      return fin(updateView(view).then(function () {
                        return queryView(view, opts);
                      }), function () {
                        return view.db.destroy();
                      });
                    });
                  });
                  return tempViewQueue.finish();
                } else {
                  var fullViewName = fun;
                  var parts = parseViewName(fullViewName);
                  var designDocName = parts[0];
                  var viewName = parts[1];
                  return db.get('_design/' + designDocName).then(function (doc) {
                    var fun = doc.views && doc.views[viewName];
                    if (!fun) {
                      throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' + viewName);
                    }
                    ddocValidator(doc, viewName);
                    checkQueryParseError(opts, fun);
                    var createViewPromise = createView(db, fullViewName, fun.map, fun.reduce, false, localDocName);
                    return createViewPromise.then(function (view) {
                      if (opts.stale === 'ok' || opts.stale === 'update_after') {
                        if (opts.stale === 'update_after') {
                          nextTick(function () {
                            updateView(view);
                          });
                        }
                        return queryView(view, opts);
                      } else {
                        return updateView(view).then(function () {
                          return queryView(view, opts);
                        });
                      }
                    });
                  });
                }
              }
              function abstractQuery(fun, opts, callback) {
                var db = this;
                if (typeof opts === 'function') {
                  callback = opts;
                  opts = {};
                }
                opts = opts ? coerceOptions(opts) : {};
                if (typeof fun === 'function') {
                  fun = { map: fun };
                }
                var promise = PouchPromise$1.resolve().then(function () {
                  return queryPromised(db, fun, opts);
                });
                promisedCallback(promise, callback);
                return promise;
              }
              var abstractViewCleanup = callbackify(function () {
                var db = this;
                if (typeof db._viewCleanup === 'function') {
                  return customViewCleanup(db);
                }
                if (isRemote(db)) {
                  return httpViewCleanup(db);
                }
                return localViewCleanup(db);
              });
              return {
                query: abstractQuery,
                viewCleanup: abstractViewCleanup
              };
            }
            var builtInReduce = {
              _sum: function (keys, values) {
                return sum(values);
              },
              _count: function (keys, values) {
                return values.length;
              },
              _stats: function (keys, values) {
                function sumsqr(values) {
                  var _sumsqr = 0;
                  for (var i = 0, len = values.length; i < len; i++) {
                    var num = values[i];
                    _sumsqr += num * num;
                  }
                  return _sumsqr;
                }
                return {
                  sum: sum(values),
                  min: Math.min.apply(null, values),
                  max: Math.max.apply(null, values),
                  count: values.length,
                  sumsqr: sumsqr(values)
                };
              }
            };
            function getBuiltIn(reduceFunString) {
              if (/^_sum/.test(reduceFunString)) {
                return builtInReduce._sum;
              } else if (/^_count/.test(reduceFunString)) {
                return builtInReduce._count;
              } else if (/^_stats/.test(reduceFunString)) {
                return builtInReduce._stats;
              } else if (/^_/.test(reduceFunString)) {
                throw new Error(reduceFunString + ' is not a supported reduce function.');
              }
            }
            function mapper(mapFun, emit) {
              if (typeof mapFun === "function" && mapFun.length === 2) {
                var origMap = mapFun;
                return function (doc) {
                  return origMap(doc, emit);
                };
              } else {
                return evalFunctionWithEval(mapFun.toString(), emit);
              }
            }
            function reducer(reduceFun) {
              var reduceFunString = reduceFun.toString();
              var builtIn = getBuiltIn(reduceFunString);
              if (builtIn) {
                return builtIn;
              } else {
                return evalFunctionWithEval(reduceFunString);
              }
            }
            function ddocValidator(ddoc, viewName) {
              var fun = ddoc.views && ddoc.views[viewName];
              if (typeof fun.map !== 'string') {
                throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' + viewName + ', instead found object of type: ' + typeof fun.map);
              }
            }
            var localDocName = 'mrviews';
            var abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);
            function query(fun, opts, callback) {
              return abstract.query.call(this, fun, opts, callback);
            }
            function viewCleanup(callback) {
              return abstract.viewCleanup.call(this, callback);
            }
            var mapreduce = {
              query: query,
              viewCleanup: viewCleanup
            };
            function isGenOne$1(rev$$1) {
              return (/^1-/.test(rev$$1)
              );
            }
            function fileHasChanged(localDoc, remoteDoc, filename) {
              return !localDoc._attachments || !localDoc._attachments[filename] || localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;
            }
            function getDocAttachments(db, doc) {
              var filenames = Object.keys(doc._attachments);
              return PouchPromise$1.all(filenames.map(function (filename) {
                return db.getAttachment(doc._id, filename, { rev: doc._rev });
              }));
            }
            function getDocAttachmentsFromTargetOrSource(target, src, doc) {
              var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);
              var filenames = Object.keys(doc._attachments);
              if (!doCheckForLocalAttachments) {
                return getDocAttachments(src, doc);
              }
              return target.get(doc._id).then(function (localDoc) {
                return PouchPromise$1.all(filenames.map(function (filename) {
                  if (fileHasChanged(localDoc, doc, filename)) {
                    return src.getAttachment(doc._id, filename);
                  }
                  return target.getAttachment(localDoc._id, filename);
                }));
              })["catch"](function (error) {
                if (error.status !== 404) {
                  throw error;
                }
                return getDocAttachments(src, doc);
              });
            }
            function createBulkGetOpts(diffs) {
              var requests = [];
              Object.keys(diffs).forEach(function (id) {
                var missingRevs = diffs[id].missing;
                missingRevs.forEach(function (missingRev) {
                  requests.push({
                    id: id,
                    rev: missingRev
                  });
                });
              });
              return {
                docs: requests,
                revs: true,
                latest: true
              };
            }
            function getDocs(src, target, diffs, state) {
              diffs = clone(diffs);
              var resultDocs = [],
                  ok = true;
              function getAllDocs() {
                var bulkGetOpts = createBulkGetOpts(diffs);
                if (!bulkGetOpts.docs.length) {
                  return;
                }
                return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {
                  if (state.cancelled) {
                    throw new Error('cancelled');
                  }
                  return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {
                    return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {
                      var remoteDoc = doc.ok;
                      if (doc.error) {
                        ok = false;
                      }
                      if (!remoteDoc || !remoteDoc._attachments) {
                        return remoteDoc;
                      }
                      return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc).then(function (attachments) {
                        var filenames = Object.keys(remoteDoc._attachments);
                        attachments.forEach(function (attachment, i) {
                          var att = remoteDoc._attachments[filenames[i]];
                          delete att.stub;
                          delete att.length;
                          att.data = attachment;
                        });
                        return remoteDoc;
                      });
                    }));
                  })).then(function (results) {
                    resultDocs = resultDocs.concat(flatten(results).filter(Boolean));
                  });
                });
              }
              function hasAttachments(doc) {
                return doc._attachments && Object.keys(doc._attachments).length > 0;
              }
              function hasConflicts(doc) {
                return doc._conflicts && doc._conflicts.length > 0;
              }
              function fetchRevisionOneDocs(ids) {
                return src.allDocs({
                  keys: ids,
                  include_docs: true,
                  conflicts: true
                }).then(function (res) {
                  if (state.cancelled) {
                    throw new Error('cancelled');
                  }
                  res.rows.forEach(function (row) {
                    if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) || hasAttachments(row.doc) || hasConflicts(row.doc)) {
                      return;
                    }
                    if (row.doc._conflicts) {
                      delete row.doc._conflicts;
                    }
                    resultDocs.push(row.doc);
                    delete diffs[row.id];
                  });
                });
              }
              function getRevisionOneDocs() {
                var ids = Object.keys(diffs).filter(function (id) {
                  var missing = diffs[id].missing;
                  return missing.length === 1 && isGenOne$1(missing[0]);
                });
                if (ids.length > 0) {
                  return fetchRevisionOneDocs(ids);
                }
              }
              function returnResult() {
                return {
                  ok: ok,
                  docs: resultDocs
                };
              }
              return PouchPromise$1.resolve().then(getRevisionOneDocs).then(getAllDocs).then(returnResult);
            }
            var CHECKPOINT_VERSION = 1;
            var REPLICATOR = "pouchdb";
            var CHECKPOINT_HISTORY_SIZE = 5;
            var LOWEST_SEQ = 0;
            function updateCheckpoint(db, id, checkpoint, session, returnValue) {
              return db.get(id)["catch"](function (err) {
                if (err.status === 404) {
                  if (db.adapter === 'http' || db.adapter === 'https') {
                    explainError(404, 'PouchDB is just checking if a remote checkpoint exists.');
                  }
                  return {
                    session_id: session,
                    _id: id,
                    history: [],
                    replicator: REPLICATOR,
                    version: CHECKPOINT_VERSION
                  };
                }
                throw err;
              }).then(function (doc) {
                if (returnValue.cancelled) {
                  return;
                }
                if (doc.last_seq === checkpoint) {
                  return;
                }
                doc.history = (doc.history || []).filter(function (item) {
                  return item.session_id !== session;
                });
                doc.history.unshift({
                  last_seq: checkpoint,
                  session_id: session
                });
                doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);
                doc.version = CHECKPOINT_VERSION;
                doc.replicator = REPLICATOR;
                doc.session_id = session;
                doc.last_seq = checkpoint;
                return db.put(doc)["catch"](function (err) {
                  if (err.status === 409) {
                    return updateCheckpoint(db, id, checkpoint, session, returnValue);
                  }
                  throw err;
                });
              });
            }
            function Checkpointer(src, target, id, returnValue, opts) {
              this.src = src;
              this.target = target;
              this.id = id;
              this.returnValue = returnValue;
              this.opts = opts;
            }
            Checkpointer.prototype.writeCheckpoint = function (checkpoint, session) {
              var self = this;
              return this.updateTarget(checkpoint, session).then(function () {
                return self.updateSource(checkpoint, session);
              });
            };
            Checkpointer.prototype.updateTarget = function (checkpoint, session) {
              if (this.opts.writeTargetCheckpoint) {
                return updateCheckpoint(this.target, this.id, checkpoint, session, this.returnValue);
              } else {
                return PouchPromise$1.resolve(true);
              }
            };
            Checkpointer.prototype.updateSource = function (checkpoint, session) {
              if (this.opts.writeSourceCheckpoint) {
                var self = this;
                if (this.readOnlySource) {
                  return PouchPromise$1.resolve(true);
                }
                return updateCheckpoint(this.src, this.id, checkpoint, session, this.returnValue)["catch"](function (err) {
                  if (isForbiddenError(err)) {
                    self.readOnlySource = true;
                    return true;
                  }
                  throw err;
                });
              } else {
                return PouchPromise$1.resolve(true);
              }
            };
            var comparisons = {
              "undefined": function (targetDoc, sourceDoc) {
                if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {
                  return sourceDoc.last_seq;
                }
                return 0;
              },
              "1": function (targetDoc, sourceDoc) {
                return compareReplicationLogs(sourceDoc, targetDoc).last_seq;
              }
            };
            Checkpointer.prototype.getCheckpoint = function () {
              var self = this;
              return self.target.get(self.id).then(function (targetDoc) {
                if (self.readOnlySource) {
                  return PouchPromise$1.resolve(targetDoc.last_seq);
                }
                return self.src.get(self.id).then(function (sourceDoc) {
                  if (targetDoc.version !== sourceDoc.version) {
                    return LOWEST_SEQ;
                  }
                  var version;
                  if (targetDoc.version) {
                    version = targetDoc.version.toString();
                  } else {
                    version = "undefined";
                  }
                  if (version in comparisons) {
                    return comparisons[version](targetDoc, sourceDoc);
                  }
                  return LOWEST_SEQ;
                }, function (err) {
                  if (err.status === 404 && targetDoc.last_seq) {
                    return self.src.put({
                      _id: self.id,
                      last_seq: LOWEST_SEQ
                    }).then(function () {
                      return LOWEST_SEQ;
                    }, function (err) {
                      if (isForbiddenError(err)) {
                        self.readOnlySource = true;
                        return targetDoc.last_seq;
                      }
                      return LOWEST_SEQ;
                    });
                  }
                  throw err;
                });
              })["catch"](function (err) {
                if (err.status !== 404) {
                  throw err;
                }
                return LOWEST_SEQ;
              });
            };
            function compareReplicationLogs(srcDoc, tgtDoc) {
              if (srcDoc.session_id === tgtDoc.session_id) {
                return {
                  last_seq: srcDoc.last_seq,
                  history: srcDoc.history
                };
              }
              return compareReplicationHistory(srcDoc.history, tgtDoc.history);
            }
            function compareReplicationHistory(sourceHistory, targetHistory) {
              var S = sourceHistory[0];
              var sourceRest = sourceHistory.slice(1);
              var T = targetHistory[0];
              var targetRest = targetHistory.slice(1);
              if (!S || targetHistory.length === 0) {
                return {
                  last_seq: LOWEST_SEQ,
                  history: []
                };
              }
              var sourceId = S.session_id;
              if (hasSessionId(sourceId, targetHistory)) {
                return {
                  last_seq: S.last_seq,
                  history: sourceHistory
                };
              }
              var targetId = T.session_id;
              if (hasSessionId(targetId, sourceRest)) {
                return {
                  last_seq: T.last_seq,
                  history: targetRest
                };
              }
              return compareReplicationHistory(sourceRest, targetRest);
            }
            function hasSessionId(sessionId, history) {
              var props = history[0];
              var rest = history.slice(1);
              if (!sessionId || history.length === 0) {
                return false;
              }
              if (sessionId === props.session_id) {
                return true;
              }
              return hasSessionId(sessionId, rest);
            }
            function isForbiddenError(err) {
              return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;
            }
            var STARTING_BACK_OFF = 0;
            function backOff(opts, returnValue, error, callback) {
              if (opts.retry === false) {
                returnValue.emit('error', error);
                returnValue.removeAllListeners();
                return;
              }
              if (typeof opts.back_off_function !== 'function') {
                opts.back_off_function = defaultBackOff;
              }
              returnValue.emit('requestError', error);
              if (returnValue.state === 'active' || returnValue.state === 'pending') {
                returnValue.emit('paused', error);
                returnValue.state = 'stopped';
                var backOffSet = function backoffTimeSet() {
                  opts.current_back_off = STARTING_BACK_OFF;
                };
                var removeBackOffSetter = function removeBackOffTimeSet() {
                  returnValue.removeListener('active', backOffSet);
                };
                returnValue.once('paused', removeBackOffSetter);
                returnValue.once('active', backOffSet);
              }
              opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;
              opts.current_back_off = opts.back_off_function(opts.current_back_off);
              setTimeout(callback, opts.current_back_off);
            }
            function sortObjectPropertiesByKey(queryParams) {
              return Object.keys(queryParams).sort(collate).reduce(function (result, key) {
                result[key] = queryParams[key];
                return result;
              }, {});
            }
            function generateReplicationId(src, target, opts) {
              var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';
              var filterFun = opts.filter ? opts.filter.toString() : '';
              var queryParams = '';
              var filterViewName = '';
              var selector = '';
              if (opts.selector) {
                selector = JSON.stringify(opts.selector);
              }
              if (opts.filter && opts.query_params) {
                queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));
              }
              if (opts.filter && opts.filter === '_view') {
                filterViewName = opts.view.toString();
              }
              return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {
                var queryData = res[0] + res[1] + filterFun + filterViewName + queryParams + docIds + selector;
                return new PouchPromise$1(function (resolve) {
                  binaryMd5(queryData, resolve);
                });
              }).then(function (md5sum) {
                md5sum = md5sum.replace(/\//g, '.').replace(/\+/g, '_');
                return '_local/' + md5sum;
              });
            }
            function replicate(src, target, opts, returnValue, result) {
              var batches = [];
              var currentBatch;
              var pendingBatch = {
                seq: 0,
                changes: [],
                docs: []
              };
              var writingCheckpoint = false;
              var changesCompleted = false;
              var replicationCompleted = false;
              var last_seq = 0;
              var continuous = opts.continuous || opts.live || false;
              var batch_size = opts.batch_size || 100;
              var batches_limit = opts.batches_limit || 10;
              var changesPending = false;
              var doc_ids = opts.doc_ids;
              var selector = opts.selector;
              var repId;
              var checkpointer;
              var changedDocs = [];
              var session = uuid();
              result = result || {
                ok: true,
                start_time: new Date(),
                docs_read: 0,
                docs_written: 0,
                doc_write_failures: 0,
                errors: []
              };
              var changesOpts = {};
              returnValue.ready(src, target);
              function initCheckpointer() {
                if (checkpointer) {
                  return PouchPromise$1.resolve();
                }
                return generateReplicationId(src, target, opts).then(function (res) {
                  repId = res;
                  var checkpointOpts = {};
                  if (opts.checkpoint === false) {
                    checkpointOpts = {
                      writeSourceCheckpoint: false,
                      writeTargetCheckpoint: false
                    };
                  } else if (opts.checkpoint === 'source') {
                    checkpointOpts = {
                      writeSourceCheckpoint: true,
                      writeTargetCheckpoint: false
                    };
                  } else if (opts.checkpoint === 'target') {
                    checkpointOpts = {
                      writeSourceCheckpoint: false,
                      writeTargetCheckpoint: true
                    };
                  } else {
                    checkpointOpts = {
                      writeSourceCheckpoint: true,
                      writeTargetCheckpoint: true
                    };
                  }
                  checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);
                });
              }
              function writeDocs() {
                changedDocs = [];
                if (currentBatch.docs.length === 0) {
                  return;
                }
                var docs = currentBatch.docs;
                var bulkOpts = { timeout: opts.timeout };
                return target.bulkDocs({
                  docs: docs,
                  new_edits: false
                }, bulkOpts).then(function (res) {
                  if (returnValue.cancelled) {
                    completeReplication();
                    throw new Error('cancelled');
                  }
                  var errorsById = Object.create(null);
                  res.forEach(function (res) {
                    if (res.error) {
                      errorsById[res.id] = res;
                    }
                  });
                  var errorsNo = Object.keys(errorsById).length;
                  result.doc_write_failures += errorsNo;
                  result.docs_written += docs.length - errorsNo;
                  docs.forEach(function (doc) {
                    var error = errorsById[doc._id];
                    if (error) {
                      result.errors.push(error);
                      if (error.name === 'unauthorized' || error.name === 'forbidden') {
                        returnValue.emit('denied', clone(error));
                      } else {
                        throw error;
                      }
                    } else {
                      changedDocs.push(doc);
                    }
                  });
                }, function (err) {
                  result.doc_write_failures += docs.length;
                  throw err;
                });
              }
              function finishBatch() {
                if (currentBatch.error) {
                  throw new Error('There was a problem getting docs.');
                }
                result.last_seq = last_seq = currentBatch.seq;
                var outResult = clone(result);
                if (changedDocs.length) {
                  outResult.docs = changedDocs;
                  returnValue.emit('change', outResult);
                }
                writingCheckpoint = true;
                return checkpointer.writeCheckpoint(currentBatch.seq, session).then(function () {
                  writingCheckpoint = false;
                  if (returnValue.cancelled) {
                    completeReplication();
                    throw new Error('cancelled');
                  }
                  currentBatch = undefined;
                  getChanges();
                })["catch"](function (err) {
                  onCheckpointError(err);
                  throw err;
                });
              }
              function getDiffs() {
                var diff = {};
                currentBatch.changes.forEach(function (change) {
                  if (change.id === "_user/") {
                    return;
                  }
                  diff[change.id] = change.changes.map(function (x) {
                    return x.rev;
                  });
                });
                return target.revsDiff(diff).then(function (diffs) {
                  if (returnValue.cancelled) {
                    completeReplication();
                    throw new Error('cancelled');
                  }
                  currentBatch.diffs = diffs;
                });
              }
              function getBatchDocs() {
                return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {
                  currentBatch.error = !got.ok;
                  got.docs.forEach(function (doc) {
                    delete currentBatch.diffs[doc._id];
                    result.docs_read++;
                    currentBatch.docs.push(doc);
                  });
                });
              }
              function startNextBatch() {
                if (returnValue.cancelled || currentBatch) {
                  return;
                }
                if (batches.length === 0) {
                  processPendingBatch(true);
                  return;
                }
                currentBatch = batches.shift();
                getDiffs().then(getBatchDocs).then(writeDocs).then(finishBatch).then(startNextBatch)["catch"](function (err) {
                  abortReplication('batch processing terminated with error', err);
                });
              }
              function processPendingBatch(immediate) {
                if (pendingBatch.changes.length === 0) {
                  if (batches.length === 0 && !currentBatch) {
                    if (continuous && changesOpts.live || changesCompleted) {
                      returnValue.state = 'pending';
                      returnValue.emit('paused');
                    }
                    if (changesCompleted) {
                      completeReplication();
                    }
                  }
                  return;
                }
                if (immediate || changesCompleted || pendingBatch.changes.length >= batch_size) {
                  batches.push(pendingBatch);
                  pendingBatch = {
                    seq: 0,
                    changes: [],
                    docs: []
                  };
                  if (returnValue.state === 'pending' || returnValue.state === 'stopped') {
                    returnValue.state = 'active';
                    returnValue.emit('active');
                  }
                  startNextBatch();
                }
              }
              function abortReplication(reason, err) {
                if (replicationCompleted) {
                  return;
                }
                if (!err.message) {
                  err.message = reason;
                }
                result.ok = false;
                result.status = 'aborting';
                batches = [];
                pendingBatch = {
                  seq: 0,
                  changes: [],
                  docs: []
                };
                completeReplication(err);
              }
              function completeReplication(fatalError) {
                if (replicationCompleted) {
                  return;
                }
                if (returnValue.cancelled) {
                  result.status = 'cancelled';
                  if (writingCheckpoint) {
                    return;
                  }
                }
                result.status = result.status || 'complete';
                result.end_time = new Date();
                result.last_seq = last_seq;
                replicationCompleted = true;
                if (fatalError) {
                  fatalError = createError(fatalError);
                  fatalError.result = result;
                  if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {
                    returnValue.emit('error', fatalError);
                    returnValue.removeAllListeners();
                  } else {
                    backOff(opts, returnValue, fatalError, function () {
                      replicate(src, target, opts, returnValue);
                    });
                  }
                } else {
                  returnValue.emit('complete', result);
                  returnValue.removeAllListeners();
                }
              }
              function onChange(change) {
                if (returnValue.cancelled) {
                  return completeReplication();
                }
                var filter = filterChange(opts)(change);
                if (!filter) {
                  return;
                }
                pendingBatch.seq = change.seq;
                pendingBatch.changes.push(change);
                processPendingBatch(batches.length === 0 && changesOpts.live);
              }
              function onChangesComplete(changes) {
                changesPending = false;
                if (returnValue.cancelled) {
                  return completeReplication();
                }
                if (changes.results.length > 0) {
                  changesOpts.since = changes.last_seq;
                  getChanges();
                  processPendingBatch(true);
                } else {
                  var complete = function () {
                    if (continuous) {
                      changesOpts.live = true;
                      getChanges();
                    } else {
                      changesCompleted = true;
                    }
                    processPendingBatch(true);
                  };
                  if (!currentBatch && changes.results.length === 0) {
                    writingCheckpoint = true;
                    checkpointer.writeCheckpoint(changes.last_seq, session).then(function () {
                      writingCheckpoint = false;
                      result.last_seq = last_seq = changes.last_seq;
                      complete();
                    })["catch"](onCheckpointError);
                  } else {
                    complete();
                  }
                }
              }
              function onChangesError(err) {
                changesPending = false;
                if (returnValue.cancelled) {
                  return completeReplication();
                }
                abortReplication('changes rejected', err);
              }
              function getChanges() {
                if (!(!changesPending && !changesCompleted && batches.length < batches_limit)) {
                  return;
                }
                changesPending = true;
                function abortChanges() {
                  changes.cancel();
                }
                function removeListener() {
                  returnValue.removeListener('cancel', abortChanges);
                }
                if (returnValue._changes) {
                  returnValue.removeListener('cancel', returnValue._abortChanges);
                  returnValue._changes.cancel();
                }
                returnValue.once('cancel', abortChanges);
                var changes = src.changes(changesOpts).on('change', onChange);
                changes.then(removeListener, removeListener);
                changes.then(onChangesComplete)["catch"](onChangesError);
                if (opts.retry) {
                  returnValue._changes = changes;
                  returnValue._abortChanges = abortChanges;
                }
              }
              function startChanges() {
                initCheckpointer().then(function () {
                  if (returnValue.cancelled) {
                    completeReplication();
                    return;
                  }
                  return checkpointer.getCheckpoint().then(function (checkpoint) {
                    last_seq = checkpoint;
                    changesOpts = {
                      since: last_seq,
                      limit: batch_size,
                      batch_size: batch_size,
                      style: 'all_docs',
                      doc_ids: doc_ids,
                      selector: selector,
                      return_docs: true
                    };
                    if (opts.filter) {
                      if (typeof opts.filter !== 'string') {
                        changesOpts.include_docs = true;
                      } else {
                        changesOpts.filter = opts.filter;
                      }
                    }
                    if ('heartbeat' in opts) {
                      changesOpts.heartbeat = opts.heartbeat;
                    }
                    if ('timeout' in opts) {
                      changesOpts.timeout = opts.timeout;
                    }
                    if (opts.query_params) {
                      changesOpts.query_params = opts.query_params;
                    }
                    if (opts.view) {
                      changesOpts.view = opts.view;
                    }
                    getChanges();
                  });
                })["catch"](function (err) {
                  abortReplication('getCheckpoint rejected with ', err);
                });
              }
              function onCheckpointError(err) {
                writingCheckpoint = false;
                abortReplication('writeCheckpoint completed with error', err);
              }
              if (returnValue.cancelled) {
                completeReplication();
                return;
              }
              if (!returnValue._addedListeners) {
                returnValue.once('cancel', completeReplication);
                if (typeof opts.complete === 'function') {
                  returnValue.once('error', opts.complete);
                  returnValue.once('complete', function (result) {
                    opts.complete(null, result);
                  });
                }
                returnValue._addedListeners = true;
              }
              if (typeof opts.since === 'undefined') {
                startChanges();
              } else {
                initCheckpointer().then(function () {
                  writingCheckpoint = true;
                  return checkpointer.writeCheckpoint(opts.since, session);
                }).then(function () {
                  writingCheckpoint = false;
                  if (returnValue.cancelled) {
                    completeReplication();
                    return;
                  }
                  last_seq = opts.since;
                  startChanges();
                })["catch"](onCheckpointError);
              }
            }
            inherits(Replication, events.EventEmitter);
            function Replication() {
              events.EventEmitter.call(this);
              this.cancelled = false;
              this.state = 'pending';
              var self = this;
              var promise = new PouchPromise$1(function (fulfill, reject) {
                self.once('complete', fulfill);
                self.once('error', reject);
              });
              self.then = function (resolve, reject) {
                return promise.then(resolve, reject);
              };
              self["catch"] = function (reject) {
                return promise["catch"](reject);
              };
              self["catch"](function () {});
            }
            Replication.prototype.cancel = function () {
              this.cancelled = true;
              this.state = 'cancelled';
              this.emit('cancel');
            };
            Replication.prototype.ready = function (src, target) {
              var self = this;
              if (self._readyCalled) {
                return;
              }
              self._readyCalled = true;
              function onDestroy() {
                self.cancel();
              }
              src.once('destroyed', onDestroy);
              target.once('destroyed', onDestroy);
              function cleanup() {
                src.removeListener('destroyed', onDestroy);
                target.removeListener('destroyed', onDestroy);
              }
              self.once('complete', cleanup);
            };
            function toPouch(db, opts) {
              var PouchConstructor = opts.PouchConstructor;
              if (typeof db === 'string') {
                return new PouchConstructor(db, opts);
              } else {
                return db;
              }
            }
            function replicateWrapper(src, target, opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              if (typeof opts === 'undefined') {
                opts = {};
              }
              if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {
                throw createError(BAD_REQUEST, "`doc_ids` filter parameter is not a list.");
              }
              opts.complete = callback;
              opts = clone(opts);
              opts.continuous = opts.continuous || opts.live;
              opts.retry = 'retry' in opts ? opts.retry : false;
              opts.PouchConstructor = opts.PouchConstructor || this;
              var replicateRet = new Replication(opts);
              var srcPouch = toPouch(src, opts);
              var targetPouch = toPouch(target, opts);
              replicate(srcPouch, targetPouch, opts, replicateRet);
              return replicateRet;
            }
            inherits(Sync, events.EventEmitter);
            function sync$1(src, target, opts, callback) {
              if (typeof opts === 'function') {
                callback = opts;
                opts = {};
              }
              if (typeof opts === 'undefined') {
                opts = {};
              }
              opts = clone(opts);
              opts.PouchConstructor = opts.PouchConstructor || this;
              src = toPouch(src, opts);
              target = toPouch(target, opts);
              return new Sync(src, target, opts, callback);
            }
            function Sync(src, target, opts, callback) {
              var self = this;
              this.canceled = false;
              var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;
              var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;
              this.push = replicateWrapper(src, target, optsPush);
              this.pull = replicateWrapper(target, src, optsPull);
              this.pushPaused = true;
              this.pullPaused = true;
              function pullChange(change) {
                self.emit('change', {
                  direction: 'pull',
                  change: change
                });
              }
              function pushChange(change) {
                self.emit('change', {
                  direction: 'push',
                  change: change
                });
              }
              function pushDenied(doc) {
                self.emit('denied', {
                  direction: 'push',
                  doc: doc
                });
              }
              function pullDenied(doc) {
                self.emit('denied', {
                  direction: 'pull',
                  doc: doc
                });
              }
              function pushPaused() {
                self.pushPaused = true;
                if (self.pullPaused) {
                  self.emit('paused');
                }
              }
              function pullPaused() {
                self.pullPaused = true;
                if (self.pushPaused) {
                  self.emit('paused');
                }
              }
              function pushActive() {
                self.pushPaused = false;
                if (self.pullPaused) {
                  self.emit('active', { direction: 'push' });
                }
              }
              function pullActive() {
                self.pullPaused = false;
                if (self.pushPaused) {
                  self.emit('active', { direction: 'pull' });
                }
              }
              var removed = {};
              function removeAll(type) {
                return function (event, func) {
                  var isChange = event === 'change' && (func === pullChange || func === pushChange);
                  var isDenied = event === 'denied' && (func === pullDenied || func === pushDenied);
                  var isPaused = event === 'paused' && (func === pullPaused || func === pushPaused);
                  var isActive = event === 'active' && (func === pullActive || func === pushActive);
                  if (isChange || isDenied || isPaused || isActive) {
                    if (!(event in removed)) {
                      removed[event] = {};
                    }
                    removed[event][type] = true;
                    if (Object.keys(removed[event]).length === 2) {
                      self.removeAllListeners(event);
                    }
                  }
                };
              }
              if (opts.live) {
                this.push.on('complete', self.pull.cancel.bind(self.pull));
                this.pull.on('complete', self.push.cancel.bind(self.push));
              }
              function addOneListener(ee, event, listener) {
                if (ee.listeners(event).indexOf(listener) == -1) {
                  ee.on(event, listener);
                }
              }
              this.on('newListener', function (event) {
                if (event === 'change') {
                  addOneListener(self.pull, 'change', pullChange);
                  addOneListener(self.push, 'change', pushChange);
                } else if (event === 'denied') {
                  addOneListener(self.pull, 'denied', pullDenied);
                  addOneListener(self.push, 'denied', pushDenied);
                } else if (event === 'active') {
                  addOneListener(self.pull, 'active', pullActive);
                  addOneListener(self.push, 'active', pushActive);
                } else if (event === 'paused') {
                  addOneListener(self.pull, 'paused', pullPaused);
                  addOneListener(self.push, 'paused', pushPaused);
                }
              });
              this.on('removeListener', function (event) {
                if (event === 'change') {
                  self.pull.removeListener('change', pullChange);
                  self.push.removeListener('change', pushChange);
                } else if (event === 'denied') {
                  self.pull.removeListener('denied', pullDenied);
                  self.push.removeListener('denied', pushDenied);
                } else if (event === 'active') {
                  self.pull.removeListener('active', pullActive);
                  self.push.removeListener('active', pushActive);
                } else if (event === 'paused') {
                  self.pull.removeListener('paused', pullPaused);
                  self.push.removeListener('paused', pushPaused);
                }
              });
              this.pull.on('removeListener', removeAll('pull'));
              this.push.on('removeListener', removeAll('push'));
              var promise = PouchPromise$1.all([this.push, this.pull]).then(function (resp) {
                var out = {
                  push: resp[0],
                  pull: resp[1]
                };
                self.emit('complete', out);
                if (callback) {
                  callback(null, out);
                }
                self.removeAllListeners();
                return out;
              }, function (err) {
                self.cancel();
                if (callback) {
                  callback(err);
                } else {
                  self.emit('error', err);
                }
                self.removeAllListeners();
                if (callback) {
                  throw err;
                }
              });
              this.then = function (success, err) {
                return promise.then(success, err);
              };
              this["catch"] = function (err) {
                return promise["catch"](err);
              };
            }
            Sync.prototype.cancel = function () {
              if (!this.canceled) {
                this.canceled = true;
                this.push.cancel();
                this.pull.cancel();
              }
            };
            function replication(PouchDB) {
              PouchDB.replicate = replicateWrapper;
              PouchDB.sync = sync$1;
              Object.defineProperty(PouchDB.prototype, 'replicate', { get: function () {
                  var self = this;
                  return {
                    from: function (other, opts, callback) {
                      return self.constructor.replicate(other, self, opts, callback);
                    },
                    to: function (other, opts, callback) {
                      return self.constructor.replicate(self, other, opts, callback);
                    }
                  };
                } });
              PouchDB.prototype.sync = function (dbName, opts, callback) {
                return this.constructor.sync(this, dbName, opts, callback);
              };
            }
            PouchDB$5.plugin(IDBPouch).plugin(WebSqlPouch).plugin(HttpPouch$1).plugin(mapreduce).plugin(replication);
            module.exports = PouchDB$5;
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {
          "1": 1,
          "10": 10,
          "13": 13,
          "14": 14,
          "2": 2,
          "4": 4,
          "5": 5,
          "6": 6,
          "7": 7
        }]
      }, {}, [15])(15);
    });
  })($__require("15"));
});
$__System.registerDynamic("a1", ["a0"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("a0");
});
$__System.register("a2", ["a1"], function (_export) {
  "use strict";

  var PouchDB, db;
  return {
    setters: [function (_a1) {
      PouchDB = _a1["default"];
    }],
    execute: function () {
      db = new PouchDB('http://localhost:5984/ajexpenditor');

      _export("db", db);
    }
  };
});
$__System.registerDynamic("a3", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
});
$__System.registerDynamic('a4', ['a3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('a3');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
});
$__System.registerDynamic("a5", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
});
$__System.registerDynamic('a6', ['a4', 'a5'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var IObject = $__require('a4'),
      defined = $__require('a5');
  module.exports = function (it) {
    return IObject(defined(it));
  };
});
$__System.registerDynamic("a7", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
});
$__System.registerDynamic('a8', ['a9', 'aa', 'a7'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('a9'),
        core = $__require('aa'),
        fails = $__require('a7');
    module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
            exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
            fn(1);
        }), 'Object', exp);
    };
});
$__System.registerDynamic('ab', ['a6', 'a8'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('a6');
  $__require('a8')('getOwnPropertyDescriptor', function ($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
});
$__System.registerDynamic('ac', ['ad', 'ab'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('ad');
  $__require('ab');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
});
$__System.registerDynamic("ae", ["ac"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("ac"), __esModule: true };
});
$__System.registerDynamic("af", ["ae"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$getOwnPropertyDescriptor = $__require("ae")["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null) object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
});
$__System.registerDynamic('b0', ['ad'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('ad');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
});
$__System.registerDynamic("b1", ["b0"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("b0"), __esModule: true };
});
$__System.registerDynamic('b2', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});
$__System.registerDynamic('a9', ['b2', 'aa', 'b3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('b2'),
      core = $__require('aa'),
      ctx = $__require('b3'),
      PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
        var F = function (param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
});
$__System.registerDynamic('b4', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
});
$__System.registerDynamic('b5', ['b4'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('b4');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
});
$__System.registerDynamic('b6', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
});
$__System.registerDynamic('b3', ['b6'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var aFunction = $__require('b6');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
});
$__System.registerDynamic('b7', ['ad', 'b4', 'b5', 'b3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var getDesc = $__require('ad').getDesc,
      isObject = $__require('b4'),
      anObject = $__require('b5');
  var check = function (O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {
      try {
        set = $__require('b3')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
});
$__System.registerDynamic('b8', ['a9', 'b7'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('a9');
  $export($export.S, 'Object', { setPrototypeOf: $__require('b7').set });
});
$__System.registerDynamic('aa', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var core = module.exports = { version: '1.2.6' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
$__System.registerDynamic('b9', ['b8', 'aa'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('b8');
  module.exports = $__require('aa').Object.setPrototypeOf;
});
$__System.registerDynamic("ba", ["b9"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("b9"), __esModule: true };
});
$__System.registerDynamic("bb", ["b1", "ba"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$create = $__require("b1")["default"];
  var _Object$setPrototypeOf = $__require("ba")["default"];
  exports["default"] = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, { constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      } });
    if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
});
$__System.registerDynamic("ad", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
});
$__System.registerDynamic('bc', ['ad'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('ad');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
});
$__System.registerDynamic("bd", ["bc"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("bc"), __esModule: true };
});
$__System.registerDynamic("be", ["bd"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$defineProperty = $__require("bd")["default"];
  exports["default"] = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  exports.__esModule = true;
});
$__System.registerDynamic("bf", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  exports["default"] = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  exports.__esModule = true;
});
$__System.registerDynamic('c0', ['c1', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('c1');
    var invariant = $__require('30');
    var oneArgumentPooler = function (copyFieldsFrom) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, copyFieldsFrom);
        return instance;
      } else {
        return new Klass(copyFieldsFrom);
      }
    };
    var twoArgumentPooler = function (a1, a2) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2);
        return instance;
      } else {
        return new Klass(a1, a2);
      }
    };
    var threeArgumentPooler = function (a1, a2, a3) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3);
        return instance;
      } else {
        return new Klass(a1, a2, a3);
      }
    };
    var fourArgumentPooler = function (a1, a2, a3, a4) {
      var Klass = this;
      if (Klass.instancePool.length) {
        var instance = Klass.instancePool.pop();
        Klass.call(instance, a1, a2, a3, a4);
        return instance;
      } else {
        return new Klass(a1, a2, a3, a4);
      }
    };
    var standardReleaser = function (instance) {
      var Klass = this;
      !(instance instanceof Klass) ? 'production' !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
      instance.destructor();
      if (Klass.instancePool.length < Klass.poolSize) {
        Klass.instancePool.push(instance);
      }
    };
    var DEFAULT_POOL_SIZE = 10;
    var DEFAULT_POOLER = oneArgumentPooler;
    var addPoolingTo = function (CopyConstructor, pooler) {
      var NewKlass = CopyConstructor;
      NewKlass.instancePool = [];
      NewKlass.getPooled = pooler || DEFAULT_POOLER;
      if (!NewKlass.poolSize) {
        NewKlass.poolSize = DEFAULT_POOL_SIZE;
      }
      NewKlass.release = standardReleaser;
      return NewKlass;
    };
    var PooledClass = {
      addPoolingTo: addPoolingTo,
      oneArgumentPooler: oneArgumentPooler,
      twoArgumentPooler: twoArgumentPooler,
      threeArgumentPooler: threeArgumentPooler,
      fourArgumentPooler: fourArgumentPooler
    };
    module.exports = PooledClass;
  })($__require('15'));
});
$__System.registerDynamic('c2', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */

  var global = this || self,
      GLOBAL = global;
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });

    return '$' + escapedString;
  }

  /**
   * Unescape and unwrap key for human-readable display
   *
   * @param {string} key to unescape.
   * @return {string} the unescaped key.
   */
  function unescape(key) {
    var unescapeRegex = /(=0|=2)/g;
    var unescaperLookup = {
      '=0': '=',
      '=2': ':'
    };
    var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

    return ('' + keySubstring).replace(unescapeRegex, function (match) {
      return unescaperLookup[match];
    });
  }

  var KeyEscapeUtils = {
    escape: escape,
    unescape: unescape
  };

  module.exports = KeyEscapeUtils;
});
$__System.registerDynamic('c3', ['c1', '40', 'c4', 'c5', '30', 'c2', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('c1');
    var ReactCurrentOwner = $__require('40');
    var REACT_ELEMENT_TYPE = $__require('c4');
    var getIteratorFn = $__require('c5');
    var invariant = $__require('30');
    var KeyEscapeUtils = $__require('c2');
    var warning = $__require('24');
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    var didWarnAboutMaps = false;
    function getComponentKey(component, index) {
      if (component && typeof component === 'object' && component.key != null) {
        return KeyEscapeUtils.escape(component.key);
      }
      return index.toString(36);
    }
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;
      if (type === 'undefined' || type === 'boolean') {
        children = null;
      }
      if (children === null || type === 'string' || type === 'number' || type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
        callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }
      var child;
      var nextName;
      var subtreeCount = 0;
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (iteratorFn) {
          var iterator = iteratorFn.call(children);
          var step;
          if (iteratorFn !== children.entries) {
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getComponentKey(child, ii++);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            if ('production' !== 'production') {
              var mapsAsChildrenAddendum = '';
              if (ReactCurrentOwner.current) {
                var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
                if (mapsAsChildrenOwnerName) {
                  mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
                }
              }
              'production' !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
              didWarnAboutMaps = true;
            }
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                child = entry[1];
                nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            }
          }
        } else if (type === 'object') {
          var addendum = '';
          if ('production' !== 'production') {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
            if (children._isReactElement) {
              addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
            }
            if (ReactCurrentOwner.current) {
              var name = ReactCurrentOwner.current.getName();
              if (name) {
                addendum += ' Check the render method of `' + name + '`.';
              }
            }
          }
          var childrenString = String(children);
          !false ? 'production' !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
        }
      }
      return subtreeCount;
    }
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }
      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    module.exports = traverseAllChildren;
  })($__require('15'));
});
$__System.registerDynamic('c6', ['c0', 'c7', '45', 'c3'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var PooledClass = $__require('c0');
  var ReactElement = $__require('c7');
  var emptyFunction = $__require('45');
  var traverseAllChildren = $__require('c3');
  var twoArgumentPooler = PooledClass.twoArgumentPooler;
  var fourArgumentPooler = PooledClass.fourArgumentPooler;
  var userProvidedKeyEscapeRegex = /\/+/g;
  function escapeUserProvidedKey(text) {
    return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
  }
  function ForEachBookKeeping(forEachFunction, forEachContext) {
    this.func = forEachFunction;
    this.context = forEachContext;
    this.count = 0;
  }
  ForEachBookKeeping.prototype.destructor = function () {
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
  function forEachSingleChild(bookKeeping, child, name) {
    var func = bookKeeping.func,
        context = bookKeeping.context;
    func.call(context, child, bookKeeping.count++);
  }
  function forEachChildren(children, forEachFunc, forEachContext) {
    if (children == null) {
      return children;
    }
    var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
    traverseAllChildren(children, forEachSingleChild, traverseContext);
    ForEachBookKeeping.release(traverseContext);
  }
  function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
    this.result = mapResult;
    this.keyPrefix = keyPrefix;
    this.func = mapFunction;
    this.context = mapContext;
    this.count = 0;
  }
  MapBookKeeping.prototype.destructor = function () {
    this.result = null;
    this.keyPrefix = null;
    this.func = null;
    this.context = null;
    this.count = 0;
  };
  PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
  function mapSingleChildIntoContext(bookKeeping, child, childKey) {
    var result = bookKeeping.result,
        keyPrefix = bookKeeping.keyPrefix,
        func = bookKeeping.func,
        context = bookKeeping.context;
    var mappedChild = func.call(context, child, bookKeeping.count++);
    if (Array.isArray(mappedChild)) {
      mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
    } else if (mappedChild != null) {
      if (ReactElement.isValidElement(mappedChild)) {
        mappedChild = ReactElement.cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
      }
      result.push(mappedChild);
    }
  }
  function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
    var escapedPrefix = '';
    if (prefix != null) {
      escapedPrefix = escapeUserProvidedKey(prefix) + '/';
    }
    var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
    traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
    MapBookKeeping.release(traverseContext);
  }
  function mapChildren(children, func, context) {
    if (children == null) {
      return children;
    }
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, func, context);
    return result;
  }
  function forEachSingleChildDummy(traverseContext, child, name) {
    return null;
  }
  function countChildren(children, context) {
    return traverseAllChildren(children, forEachSingleChildDummy, null);
  }
  function toArray(children) {
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
    return result;
  }
  var ReactChildren = {
    forEach: forEachChildren,
    map: mapChildren,
    mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
    count: countChildren,
    toArray: toArray
  };
  module.exports = ReactChildren;
});
$__System.registerDynamic('c8', ['c7', 'c9', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactElement = $__require('c7');
    var createDOMFactory = ReactElement.createFactory;
    if ('production' !== 'production') {
      var ReactElementValidator = $__require('c9');
      createDOMFactory = ReactElementValidator.createFactory;
    }
    var ReactDOMFactories = {
      a: createDOMFactory('a'),
      abbr: createDOMFactory('abbr'),
      address: createDOMFactory('address'),
      area: createDOMFactory('area'),
      article: createDOMFactory('article'),
      aside: createDOMFactory('aside'),
      audio: createDOMFactory('audio'),
      b: createDOMFactory('b'),
      base: createDOMFactory('base'),
      bdi: createDOMFactory('bdi'),
      bdo: createDOMFactory('bdo'),
      big: createDOMFactory('big'),
      blockquote: createDOMFactory('blockquote'),
      body: createDOMFactory('body'),
      br: createDOMFactory('br'),
      button: createDOMFactory('button'),
      canvas: createDOMFactory('canvas'),
      caption: createDOMFactory('caption'),
      cite: createDOMFactory('cite'),
      code: createDOMFactory('code'),
      col: createDOMFactory('col'),
      colgroup: createDOMFactory('colgroup'),
      data: createDOMFactory('data'),
      datalist: createDOMFactory('datalist'),
      dd: createDOMFactory('dd'),
      del: createDOMFactory('del'),
      details: createDOMFactory('details'),
      dfn: createDOMFactory('dfn'),
      dialog: createDOMFactory('dialog'),
      div: createDOMFactory('div'),
      dl: createDOMFactory('dl'),
      dt: createDOMFactory('dt'),
      em: createDOMFactory('em'),
      embed: createDOMFactory('embed'),
      fieldset: createDOMFactory('fieldset'),
      figcaption: createDOMFactory('figcaption'),
      figure: createDOMFactory('figure'),
      footer: createDOMFactory('footer'),
      form: createDOMFactory('form'),
      h1: createDOMFactory('h1'),
      h2: createDOMFactory('h2'),
      h3: createDOMFactory('h3'),
      h4: createDOMFactory('h4'),
      h5: createDOMFactory('h5'),
      h6: createDOMFactory('h6'),
      head: createDOMFactory('head'),
      header: createDOMFactory('header'),
      hgroup: createDOMFactory('hgroup'),
      hr: createDOMFactory('hr'),
      html: createDOMFactory('html'),
      i: createDOMFactory('i'),
      iframe: createDOMFactory('iframe'),
      img: createDOMFactory('img'),
      input: createDOMFactory('input'),
      ins: createDOMFactory('ins'),
      kbd: createDOMFactory('kbd'),
      keygen: createDOMFactory('keygen'),
      label: createDOMFactory('label'),
      legend: createDOMFactory('legend'),
      li: createDOMFactory('li'),
      link: createDOMFactory('link'),
      main: createDOMFactory('main'),
      map: createDOMFactory('map'),
      mark: createDOMFactory('mark'),
      menu: createDOMFactory('menu'),
      menuitem: createDOMFactory('menuitem'),
      meta: createDOMFactory('meta'),
      meter: createDOMFactory('meter'),
      nav: createDOMFactory('nav'),
      noscript: createDOMFactory('noscript'),
      object: createDOMFactory('object'),
      ol: createDOMFactory('ol'),
      optgroup: createDOMFactory('optgroup'),
      option: createDOMFactory('option'),
      output: createDOMFactory('output'),
      p: createDOMFactory('p'),
      param: createDOMFactory('param'),
      picture: createDOMFactory('picture'),
      pre: createDOMFactory('pre'),
      progress: createDOMFactory('progress'),
      q: createDOMFactory('q'),
      rp: createDOMFactory('rp'),
      rt: createDOMFactory('rt'),
      ruby: createDOMFactory('ruby'),
      s: createDOMFactory('s'),
      samp: createDOMFactory('samp'),
      script: createDOMFactory('script'),
      section: createDOMFactory('section'),
      select: createDOMFactory('select'),
      small: createDOMFactory('small'),
      source: createDOMFactory('source'),
      span: createDOMFactory('span'),
      strong: createDOMFactory('strong'),
      style: createDOMFactory('style'),
      sub: createDOMFactory('sub'),
      summary: createDOMFactory('summary'),
      sup: createDOMFactory('sup'),
      table: createDOMFactory('table'),
      tbody: createDOMFactory('tbody'),
      td: createDOMFactory('td'),
      textarea: createDOMFactory('textarea'),
      tfoot: createDOMFactory('tfoot'),
      th: createDOMFactory('th'),
      thead: createDOMFactory('thead'),
      time: createDOMFactory('time'),
      title: createDOMFactory('title'),
      tr: createDOMFactory('tr'),
      track: createDOMFactory('track'),
      u: createDOMFactory('u'),
      ul: createDOMFactory('ul'),
      'var': createDOMFactory('var'),
      video: createDOMFactory('video'),
      wbr: createDOMFactory('wbr'),
      circle: createDOMFactory('circle'),
      clipPath: createDOMFactory('clipPath'),
      defs: createDOMFactory('defs'),
      ellipse: createDOMFactory('ellipse'),
      g: createDOMFactory('g'),
      image: createDOMFactory('image'),
      line: createDOMFactory('line'),
      linearGradient: createDOMFactory('linearGradient'),
      mask: createDOMFactory('mask'),
      path: createDOMFactory('path'),
      pattern: createDOMFactory('pattern'),
      polygon: createDOMFactory('polygon'),
      polyline: createDOMFactory('polyline'),
      radialGradient: createDOMFactory('radialGradient'),
      rect: createDOMFactory('rect'),
      stop: createDOMFactory('stop'),
      svg: createDOMFactory('svg'),
      text: createDOMFactory('text'),
      tspan: createDOMFactory('tspan')
    };
    module.exports = ReactDOMFactories;
  })($__require('15'));
});
$__System.registerDynamic('ca', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;
});
$__System.registerDynamic('cb', ['30', '24', 'ca', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    if ('production' !== 'production') {
      var invariant = $__require('30');
      var warning = $__require('24');
      var ReactPropTypesSecret = $__require('ca');
      var loggedTypeFailures = {};
    }
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if ('production' !== 'production') {
        for (var typeSpecName in typeSpecs) {
          if (typeSpecs.hasOwnProperty(typeSpecName)) {
            var error;
            try {
              invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : '';
              warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
            }
          }
        }
      }
    }
    module.exports = checkPropTypes;
  })($__require('15'));
});
$__System.registerDynamic('cc', ['45', '30', '24', 'ca', 'cb', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var emptyFunction = $__require('45');
    var invariant = $__require('30');
    var warning = $__require('24');
    var ReactPropTypesSecret = $__require('ca');
    var checkPropTypes = $__require('cb');
    module.exports = function (isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = '@@iterator';
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
          return iteratorFn;
        }
      }
      var ANONYMOUS = '<<anonymous>>';
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message) {
        this.message = message;
        this.stack = '';
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if ('production' !== 'production') {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
            } else if ('production' !== 'production' && typeof console !== 'undefined') {
              var cacheKey = componentName + ':' + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
              }
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunction.thatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== 'function') {
            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          'production' !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
          return emptyFunction.thatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== 'function') {
            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
          }
          for (var key in propValue) {
            if (propValue.hasOwnProperty(key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          'production' !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
          return emptyFunction.thatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== 'function') {
            warning(false, 'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
            return emptyFunction.thatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
              return null;
            }
          }
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (!checker) {
              continue;
            }
            var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case 'number':
          case 'string':
          case 'undefined':
            return true;
          case 'boolean':
            return !propValue;
          case 'object':
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === 'symbol') {
          return true;
        }
        if (propValue['@@toStringTag'] === 'Symbol') {
          return true;
        }
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return 'array';
        }
        if (propValue instanceof RegExp) {
          return 'object';
        }
        if (isSymbol(propType, propValue)) {
          return 'symbol';
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
          return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
          if (propValue instanceof Date) {
            return 'date';
          } else if (propValue instanceof RegExp) {
            return 'regexp';
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case 'array':
          case 'object':
            return 'an ' + type;
          case 'boolean':
          case 'date':
          case 'regexp':
            return 'a ' + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  })($__require('15'));
});
$__System.registerDynamic('35', ['cc'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var factory = $__require('cc');
  module.exports = function (isValidElement) {
    var throwOnDirectAccess = false;
    return factory(isValidElement, throwOnDirectAccess);
  };
});
$__System.registerDynamic('cd', ['c7', '35'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var _require = $__require('c7'),
        isValidElement = _require.isValidElement;
    var factory = $__require('35');
    module.exports = factory(isValidElement);
});
$__System.registerDynamic('ce', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  module.exports = '15.6.1';
});
$__System.registerDynamic('cf', ['c1', '6', 'd0', 'd1', '91', '30', 'd2', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('c1'),
        _assign = $__require('6');
    var ReactNoopUpdateQueue = $__require('d0');
    var canDefineProperty = $__require('d1');
    var emptyObject = $__require('91');
    var invariant = $__require('30');
    var lowPriorityWarning = $__require('d2');
    function ReactComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    ReactComponent.prototype.isReactComponent = {};
    ReactComponent.prototype.setState = function (partialState, callback) {
      !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? 'production' !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
      this.updater.enqueueSetState(this, partialState);
      if (callback) {
        this.updater.enqueueCallback(this, callback, 'setState');
      }
    };
    ReactComponent.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this);
      if (callback) {
        this.updater.enqueueCallback(this, callback, 'forceUpdate');
      }
    };
    if ('production' !== 'production') {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function (methodName, info) {
        if (canDefineProperty) {
          Object.defineProperty(ReactComponent.prototype, methodName, { get: function () {
              lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
              return undefined;
            } });
        }
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    function ReactPureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    ComponentDummy.prototype = ReactComponent.prototype;
    ReactPureComponent.prototype = new ComponentDummy();
    ReactPureComponent.prototype.constructor = ReactPureComponent;
    _assign(ReactPureComponent.prototype, ReactComponent.prototype);
    ReactPureComponent.prototype.isPureReactComponent = true;
    module.exports = {
      Component: ReactComponent,
      PureComponent: ReactPureComponent
    };
  })($__require('15'));
});
$__System.registerDynamic('d0', ['24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var warning = $__require('24');
    function warnNoop(publicInstance, callerName) {
      if ('production' !== 'production') {
        var constructor = publicInstance.constructor;
        'production' !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
      }
    }
    var ReactNoopUpdateQueue = {
      isMounted: function (publicInstance) {
        return false;
      },
      enqueueCallback: function (publicInstance, callback) {},
      enqueueForceUpdate: function (publicInstance) {
        warnNoop(publicInstance, 'forceUpdate');
      },
      enqueueReplaceState: function (publicInstance, completeState) {
        warnNoop(publicInstance, 'replaceState');
      },
      enqueueSetState: function (publicInstance, partialState) {
        warnNoop(publicInstance, 'setState');
      }
    };
    module.exports = ReactNoopUpdateQueue;
  })($__require('15'));
});
$__System.registerDynamic('91', ['15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var emptyObject = {};
    if ('production' !== 'production') {
      Object.freeze(emptyObject);
    }
    module.exports = emptyObject;
  })($__require('15'));
});
$__System.registerDynamic('d3', ['6', '91', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var emptyObject = $__require('91');
    var _invariant = $__require('30');
    if ('production' !== 'production') {
      var warning = $__require('24');
    }
    var MIXINS_KEY = 'mixins';
    function identity(fn) {
      return fn;
    }
    var ReactPropTypeLocationNames;
    if ('production' !== 'production') {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    } else {
      ReactPropTypeLocationNames = {};
    }
    function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
      var injectedMixins = [];
      var ReactClassInterface = {
        mixins: 'DEFINE_MANY',
        statics: 'DEFINE_MANY',
        propTypes: 'DEFINE_MANY',
        contextTypes: 'DEFINE_MANY',
        childContextTypes: 'DEFINE_MANY',
        getDefaultProps: 'DEFINE_MANY_MERGED',
        getInitialState: 'DEFINE_MANY_MERGED',
        getChildContext: 'DEFINE_MANY_MERGED',
        render: 'DEFINE_ONCE',
        componentWillMount: 'DEFINE_MANY',
        componentDidMount: 'DEFINE_MANY',
        componentWillReceiveProps: 'DEFINE_MANY',
        shouldComponentUpdate: 'DEFINE_ONCE',
        componentWillUpdate: 'DEFINE_MANY',
        componentDidUpdate: 'DEFINE_MANY',
        componentWillUnmount: 'DEFINE_MANY',
        updateComponent: 'OVERRIDE_BASE'
      };
      var RESERVED_SPEC_KEYS = {
        displayName: function (Constructor, displayName) {
          Constructor.displayName = displayName;
        },
        mixins: function (Constructor, mixins) {
          if (mixins) {
            for (var i = 0; i < mixins.length; i++) {
              mixSpecIntoComponent(Constructor, mixins[i]);
            }
          }
        },
        childContextTypes: function (Constructor, childContextTypes) {
          if ('production' !== 'production') {
            validateTypeDef(Constructor, childContextTypes, 'childContext');
          }
          Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
        },
        contextTypes: function (Constructor, contextTypes) {
          if ('production' !== 'production') {
            validateTypeDef(Constructor, contextTypes, 'context');
          }
          Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
        },
        getDefaultProps: function (Constructor, getDefaultProps) {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
          } else {
            Constructor.getDefaultProps = getDefaultProps;
          }
        },
        propTypes: function (Constructor, propTypes) {
          if ('production' !== 'production') {
            validateTypeDef(Constructor, propTypes, 'prop');
          }
          Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
        },
        statics: function (Constructor, statics) {
          mixStaticSpecIntoComponent(Constructor, statics);
        },
        autobind: function () {}
      };
      function validateTypeDef(Constructor, typeDef, location) {
        for (var propName in typeDef) {
          if (typeDef.hasOwnProperty(propName)) {
            if ('production' !== 'production') {
              warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
            }
          }
        }
      }
      function validateMethodOverride(isAlreadyDefined, name) {
        var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
        if (ReactClassMixin.hasOwnProperty(name)) {
          _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);
        }
        if (isAlreadyDefined) {
          _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);
        }
      }
      function mixSpecIntoComponent(Constructor, spec) {
        if (!spec) {
          if ('production' !== 'production') {
            var typeofSpec = typeof spec;
            var isMixinValid = typeofSpec === 'object' && spec !== null;
            if ('production' !== 'production') {
              warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
            }
          }
          return;
        }
        _invariant(typeof spec !== 'function', "ReactClass: You're attempting to " + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');
        _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + 'use a component as a mixin. Instead, just use a regular object.');
        var proto = Constructor.prototype;
        var autoBindPairs = proto.__reactAutoBindPairs;
        if (spec.hasOwnProperty(MIXINS_KEY)) {
          RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
        }
        for (var name in spec) {
          if (!spec.hasOwnProperty(name)) {
            continue;
          }
          if (name === MIXINS_KEY) {
            continue;
          }
          var property = spec[name];
          var isAlreadyDefined = proto.hasOwnProperty(name);
          validateMethodOverride(isAlreadyDefined, name);
          if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
            RESERVED_SPEC_KEYS[name](Constructor, property);
          } else {
            var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
            var isFunction = typeof property === 'function';
            var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
            if (shouldAutoBind) {
              autoBindPairs.push(name, property);
              proto[name] = property;
            } else {
              if (isAlreadyDefined) {
                var specPolicy = ReactClassInterface[name];
                _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name);
                if (specPolicy === 'DEFINE_MANY_MERGED') {
                  proto[name] = createMergedResultFunction(proto[name], property);
                } else if (specPolicy === 'DEFINE_MANY') {
                  proto[name] = createChainedFunction(proto[name], property);
                }
              } else {
                proto[name] = property;
                if ('production' !== 'production') {
                  if (typeof property === 'function' && spec.displayName) {
                    proto[name].displayName = spec.displayName + '_' + name;
                  }
                }
              }
            }
          }
        }
      }
      function mixStaticSpecIntoComponent(Constructor, statics) {
        if (!statics) {
          return;
        }
        for (var name in statics) {
          var property = statics[name];
          if (!statics.hasOwnProperty(name)) {
            continue;
          }
          var isReserved = name in RESERVED_SPEC_KEYS;
          _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);
          var isInherited = name in Constructor;
          _invariant(!isInherited, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);
          Constructor[name] = property;
        }
      }
      function mergeIntoWithNoDuplicateKeys(one, two) {
        _invariant(one && two && typeof one === 'object' && typeof two === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');
        for (var key in two) {
          if (two.hasOwnProperty(key)) {
            _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);
            one[key] = two[key];
          }
        }
        return one;
      }
      function createMergedResultFunction(one, two) {
        return function mergedResult() {
          var a = one.apply(this, arguments);
          var b = two.apply(this, arguments);
          if (a == null) {
            return b;
          } else if (b == null) {
            return a;
          }
          var c = {};
          mergeIntoWithNoDuplicateKeys(c, a);
          mergeIntoWithNoDuplicateKeys(c, b);
          return c;
        };
      }
      function createChainedFunction(one, two) {
        return function chainedFunction() {
          one.apply(this, arguments);
          two.apply(this, arguments);
        };
      }
      function bindAutoBindMethod(component, method) {
        var boundMethod = method.bind(component);
        if ('production' !== 'production') {
          boundMethod.__reactBoundContext = component;
          boundMethod.__reactBoundMethod = method;
          boundMethod.__reactBoundArguments = null;
          var componentName = component.constructor.displayName;
          var _bind = boundMethod.bind;
          boundMethod.bind = function (newThis) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            if (newThis !== component && newThis !== null) {
              if ('production' !== 'production') {
                warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
              }
            } else if (!args.length) {
              if ('production' !== 'production') {
                warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
              }
              return boundMethod;
            }
            var reboundMethod = _bind.apply(boundMethod, arguments);
            reboundMethod.__reactBoundContext = component;
            reboundMethod.__reactBoundMethod = method;
            reboundMethod.__reactBoundArguments = args;
            return reboundMethod;
          };
        }
        return boundMethod;
      }
      function bindAutoBindMethods(component) {
        var pairs = component.__reactAutoBindPairs;
        for (var i = 0; i < pairs.length; i += 2) {
          var autoBindKey = pairs[i];
          var method = pairs[i + 1];
          component[autoBindKey] = bindAutoBindMethod(component, method);
        }
      }
      var IsMountedPreMixin = { componentDidMount: function () {
          this.__isMounted = true;
        } };
      var IsMountedPostMixin = { componentWillUnmount: function () {
          this.__isMounted = false;
        } };
      var ReactClassMixin = {
        replaceState: function (newState, callback) {
          this.updater.enqueueReplaceState(this, newState, callback);
        },
        isMounted: function () {
          if ('production' !== 'production') {
            warning(this.__didWarnIsMounted, '%s: isMounted is deprecated. Instead, make sure to clean up ' + 'subscriptions and pending requests in componentWillUnmount to ' + 'prevent memory leaks.', this.constructor && this.constructor.displayName || this.name || 'Component');
            this.__didWarnIsMounted = true;
          }
          return !!this.__isMounted;
        }
      };
      var ReactClassComponent = function () {};
      _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
      function createClass(spec) {
        var Constructor = identity(function (props, context, updater) {
          if ('production' !== 'production') {
            warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
          }
          if (this.__reactAutoBindPairs.length) {
            bindAutoBindMethods(this);
          }
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
          this.state = null;
          var initialState = this.getInitialState ? this.getInitialState() : null;
          if ('production' !== 'production') {
            if (initialState === undefined && this.getInitialState._isMockFunction) {
              initialState = null;
            }
          }
          _invariant(typeof initialState === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');
          this.state = initialState;
        });
        Constructor.prototype = new ReactClassComponent();
        Constructor.prototype.constructor = Constructor;
        Constructor.prototype.__reactAutoBindPairs = [];
        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
        mixSpecIntoComponent(Constructor, IsMountedPreMixin);
        mixSpecIntoComponent(Constructor, spec);
        mixSpecIntoComponent(Constructor, IsMountedPostMixin);
        if (Constructor.getDefaultProps) {
          Constructor.defaultProps = Constructor.getDefaultProps();
        }
        if ('production' !== 'production') {
          if (Constructor.getDefaultProps) {
            Constructor.getDefaultProps.isReactClassApproved = {};
          }
          if (Constructor.prototype.getInitialState) {
            Constructor.prototype.getInitialState.isReactClassApproved = {};
          }
        }
        _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');
        if ('production' !== 'production') {
          warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
          warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
        }
        for (var methodName in ReactClassInterface) {
          if (!Constructor.prototype[methodName]) {
            Constructor.prototype[methodName] = null;
          }
        }
        return Constructor;
      }
      return createClass;
    }
    module.exports = factory;
  })($__require('15'));
});
$__System.registerDynamic('d4', ['cf', 'c7', 'd0', 'd3'], true, function ($__require, exports, module) {
    /* */
    'use strict';

    var global = this || self,
        GLOBAL = global;
    var _require = $__require('cf'),
        Component = _require.Component;
    var _require2 = $__require('c7'),
        isValidElement = _require2.isValidElement;
    var ReactNoopUpdateQueue = $__require('d0');
    var factory = $__require('d3');
    module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);
});
$__System.registerDynamic('d5', ['c1', 'c7', '30', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('c1');
    var ReactElement = $__require('c7');
    var invariant = $__require('30');
    function onlyChild(children) {
      !ReactElement.isValidElement(children) ? 'production' !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
      return children;
    }
    module.exports = onlyChild;
  })($__require('15'));
});
$__System.registerDynamic('d6', [], true, function ($__require, exports, module) {
	/*
 object-assign
 (c) Sindre Sorhus
 @license MIT
 */

	'use strict';
	/* eslint-disable no-unused-vars */

	var global = this || self,
	    GLOBAL = global;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
});
$__System.registerDynamic("6", ["d6"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("d6");
});
$__System.registerDynamic('c4', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2014-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  // The Symbol used to tag the ReactElement type. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.

  var global = this || self,
      GLOBAL = global;
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

  module.exports = REACT_ELEMENT_TYPE;
});
$__System.registerDynamic('c7', ['6', '40', '24', 'd1', 'c4', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var ReactCurrentOwner = $__require('40');
    var warning = $__require('24');
    var canDefineProperty = $__require('d1');
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var REACT_ELEMENT_TYPE = $__require('c4');
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown;
    function hasValidRef(config) {
      if ('production' !== 'production') {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }
    function hasValidKey(config) {
      if ('production' !== 'production') {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function () {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          'production' !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function () {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          'production' !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }
    var ReactElement = function (type, key, ref, self, source, owner, props) {
      var element = {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type,
        key: key,
        ref: ref,
        props: props,
        _owner: owner
      };
      if ('production' !== 'production') {
        element._store = {};
        if (canDefineProperty) {
          Object.defineProperty(element._store, 'validated', {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, '_self', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, '_source', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
        } else {
          element._store.validated = false;
          element._self = self;
          element._source = source;
        }
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    ReactElement.createElement = function (type, config, children) {
      var propName;
      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;
      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }
        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        if ('production' !== 'production') {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      if ('production' !== 'production') {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    };
    ReactElement.createFactory = function (type) {
      var factory = ReactElement.createElement.bind(null, type);
      factory.type = type;
      return factory;
    };
    ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    };
    ReactElement.cloneElement = function (element, config, children) {
      var propName;
      var props = _assign({}, element.props);
      var key = element.key;
      var ref = element.ref;
      var self = element._self;
      var source = element._source;
      var owner = element._owner;
      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }
      return ReactElement(element.type, key, ref, self, source, owner, props);
    };
    ReactElement.isValidElement = function (object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    };
    module.exports = ReactElement;
  })($__require('15'));
});
$__System.registerDynamic('d7', ['15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactPropTypeLocationNames = {};
    if ('production' !== 'production') {
      ReactPropTypeLocationNames = {
        prop: 'prop',
        context: 'context',
        childContext: 'child context'
      };
    }
    module.exports = ReactPropTypeLocationNames;
  })($__require('15'));
});
$__System.registerDynamic('d8', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;
});
$__System.registerDynamic('c1', [], true, function ($__require, exports, module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */
  'use strict';

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  var global = this || self,
      GLOBAL = global;
  function reactProdInvariant(code) {
    var argCount = arguments.length - 1;

    var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

    for (var argIdx = 0; argIdx < argCount; argIdx++) {
      message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
    }

    message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

    var error = new Error(message);
    error.name = 'Invariant Violation';
    error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

    throw error;
  }

  module.exports = reactProdInvariant;
});
$__System.registerDynamic('40', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /**
   * Keeps track of the current owner.
   *
   * The current owner is the component who should own any components that are
   * currently being constructed.
   */

  var global = this || self,
      GLOBAL = global;
  var ReactCurrentOwner = {
    /**
     * @internal
     * @type {ReactComponent}
     */
    current: null
  };

  module.exports = ReactCurrentOwner;
});
$__System.registerDynamic('30', ['15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var validateFormat = function validateFormat(format) {};
    if ('production' !== 'production') {
      validateFormat = function validateFormat(format) {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      };
    }
    function invariant(condition, format, a, b, c, d, e, f) {
      validateFormat(format);
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function () {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }
        error.framesToPop = 1;
        throw error;
      }
    }
    module.exports = invariant;
  })($__require('15'));
});
$__System.registerDynamic('3d', ['c1', '40', '30', '24', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('c1');
    var ReactCurrentOwner = $__require('40');
    var invariant = $__require('30');
    var warning = $__require('24');
    function isNative(fn) {
      var funcToString = Function.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
      try {
        var source = funcToString.call(fn);
        return reIsNative.test(source);
      } catch (err) {
        return false;
      }
    }
    var canUseCollections = typeof Array.from === 'function' && typeof Map === 'function' && isNative(Map) && Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) && typeof Set === 'function' && isNative(Set) && Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
    var setItem;
    var getItem;
    var removeItem;
    var getItemIDs;
    var addRoot;
    var removeRoot;
    var getRootIDs;
    if (canUseCollections) {
      var itemMap = new Map();
      var rootIDSet = new Set();
      setItem = function (id, item) {
        itemMap.set(id, item);
      };
      getItem = function (id) {
        return itemMap.get(id);
      };
      removeItem = function (id) {
        itemMap['delete'](id);
      };
      getItemIDs = function () {
        return Array.from(itemMap.keys());
      };
      addRoot = function (id) {
        rootIDSet.add(id);
      };
      removeRoot = function (id) {
        rootIDSet['delete'](id);
      };
      getRootIDs = function () {
        return Array.from(rootIDSet.keys());
      };
    } else {
      var itemByKey = {};
      var rootByKey = {};
      var getKeyFromID = function (id) {
        return '.' + id;
      };
      var getIDFromKey = function (key) {
        return parseInt(key.substr(1), 10);
      };
      setItem = function (id, item) {
        var key = getKeyFromID(id);
        itemByKey[key] = item;
      };
      getItem = function (id) {
        var key = getKeyFromID(id);
        return itemByKey[key];
      };
      removeItem = function (id) {
        var key = getKeyFromID(id);
        delete itemByKey[key];
      };
      getItemIDs = function () {
        return Object.keys(itemByKey).map(getIDFromKey);
      };
      addRoot = function (id) {
        var key = getKeyFromID(id);
        rootByKey[key] = true;
      };
      removeRoot = function (id) {
        var key = getKeyFromID(id);
        delete rootByKey[key];
      };
      getRootIDs = function () {
        return Object.keys(rootByKey).map(getIDFromKey);
      };
    }
    var unmountedIDs = [];
    function purgeDeep(id) {
      var item = getItem(id);
      if (item) {
        var childIDs = item.childIDs;
        removeItem(id);
        childIDs.forEach(purgeDeep);
      }
    }
    function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    }
    function getDisplayName(element) {
      if (element == null) {
        return '#empty';
      } else if (typeof element === 'string' || typeof element === 'number') {
        return '#text';
      } else if (typeof element.type === 'string') {
        return element.type;
      } else {
        return element.type.displayName || element.type.name || 'Unknown';
      }
    }
    function describeID(id) {
      var name = ReactComponentTreeHook.getDisplayName(id);
      var element = ReactComponentTreeHook.getElement(id);
      var ownerID = ReactComponentTreeHook.getOwnerID(id);
      var ownerName;
      if (ownerID) {
        ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
      }
      'production' !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
      return describeComponentFrame(name, element && element._source, ownerName);
    }
    var ReactComponentTreeHook = {
      onSetChildren: function (id, nextChildIDs) {
        var item = getItem(id);
        !item ? 'production' !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
        item.childIDs = nextChildIDs;
        for (var i = 0; i < nextChildIDs.length; i++) {
          var nextChildID = nextChildIDs[i];
          var nextChild = getItem(nextChildID);
          !nextChild ? 'production' !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
          !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? 'production' !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
          !nextChild.isMounted ? 'production' !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
          if (nextChild.parentID == null) {
            nextChild.parentID = id;
          }
          !(nextChild.parentID === id) ? 'production' !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
        }
      },
      onBeforeMountComponent: function (id, element, parentID) {
        var item = {
          element: element,
          parentID: parentID,
          text: null,
          childIDs: [],
          isMounted: false,
          updateCount: 0
        };
        setItem(id, item);
      },
      onBeforeUpdateComponent: function (id, element) {
        var item = getItem(id);
        if (!item || !item.isMounted) {
          return;
        }
        item.element = element;
      },
      onMountComponent: function (id) {
        var item = getItem(id);
        !item ? 'production' !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
        item.isMounted = true;
        var isRoot = item.parentID === 0;
        if (isRoot) {
          addRoot(id);
        }
      },
      onUpdateComponent: function (id) {
        var item = getItem(id);
        if (!item || !item.isMounted) {
          return;
        }
        item.updateCount++;
      },
      onUnmountComponent: function (id) {
        var item = getItem(id);
        if (item) {
          item.isMounted = false;
          var isRoot = item.parentID === 0;
          if (isRoot) {
            removeRoot(id);
          }
        }
        unmountedIDs.push(id);
      },
      purgeUnmountedComponents: function () {
        if (ReactComponentTreeHook._preventPurging) {
          return;
        }
        for (var i = 0; i < unmountedIDs.length; i++) {
          var id = unmountedIDs[i];
          purgeDeep(id);
        }
        unmountedIDs.length = 0;
      },
      isMounted: function (id) {
        var item = getItem(id);
        return item ? item.isMounted : false;
      },
      getCurrentStackAddendum: function (topElement) {
        var info = '';
        if (topElement) {
          var name = getDisplayName(topElement);
          var owner = topElement._owner;
          info += describeComponentFrame(name, topElement._source, owner && owner.getName());
        }
        var currentOwner = ReactCurrentOwner.current;
        var id = currentOwner && currentOwner._debugID;
        info += ReactComponentTreeHook.getStackAddendumByID(id);
        return info;
      },
      getStackAddendumByID: function (id) {
        var info = '';
        while (id) {
          info += describeID(id);
          id = ReactComponentTreeHook.getParentID(id);
        }
        return info;
      },
      getChildIDs: function (id) {
        var item = getItem(id);
        return item ? item.childIDs : [];
      },
      getDisplayName: function (id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (!element) {
          return null;
        }
        return getDisplayName(element);
      },
      getElement: function (id) {
        var item = getItem(id);
        return item ? item.element : null;
      },
      getOwnerID: function (id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (!element || !element._owner) {
          return null;
        }
        return element._owner._debugID;
      },
      getParentID: function (id) {
        var item = getItem(id);
        return item ? item.parentID : null;
      },
      getSource: function (id) {
        var item = getItem(id);
        var element = item ? item.element : null;
        var source = element != null ? element._source : null;
        return source;
      },
      getText: function (id) {
        var element = ReactComponentTreeHook.getElement(id);
        if (typeof element === 'string') {
          return element;
        } else if (typeof element === 'number') {
          return '' + element;
        } else {
          return null;
        }
      },
      getUpdateCount: function (id) {
        var item = getItem(id);
        return item ? item.updateCount : 0;
      },
      getRootIDs: getRootIDs,
      getRegisteredIDs: getItemIDs,
      pushNonStandardWarningStack: function (isCreatingElement, currentSource) {
        if (typeof console.reactStack !== 'function') {
          return;
        }
        var stack = [];
        var currentOwner = ReactCurrentOwner.current;
        var id = currentOwner && currentOwner._debugID;
        try {
          if (isCreatingElement) {
            stack.push({
              name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
              fileName: currentSource ? currentSource.fileName : null,
              lineNumber: currentSource ? currentSource.lineNumber : null
            });
          }
          while (id) {
            var element = ReactComponentTreeHook.getElement(id);
            var parentID = ReactComponentTreeHook.getParentID(id);
            var ownerID = ReactComponentTreeHook.getOwnerID(id);
            var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
            var source = element && element._source;
            stack.push({
              name: ownerName,
              fileName: source ? source.fileName : null,
              lineNumber: source ? source.lineNumber : null
            });
            id = parentID;
          }
        } catch (err) {}
        console.reactStack(stack);
      },
      popNonStandardWarningStack: function () {
        if (typeof console.reactStackEnd !== 'function') {
          return;
        }
        console.reactStackEnd();
      }
    };
    module.exports = ReactComponentTreeHook;
  })($__require('15'));
});
$__System.registerDynamic('d9', ['c1', 'd7', 'd8', '30', '24', '3d', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _prodInvariant = $__require('c1');
    var ReactPropTypeLocationNames = $__require('d7');
    var ReactPropTypesSecret = $__require('d8');
    var invariant = $__require('30');
    var warning = $__require('24');
    var ReactComponentTreeHook;
    if (typeof process !== 'undefined' && process.env && 'production' === 'test') {
      ReactComponentTreeHook = $__require('3d');
    }
    var loggedTypeFailures = {};
    function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;
          try {
            !(typeof typeSpecs[typeSpecName] === 'function') ? 'production' !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          'production' !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = true;
            var componentStackInfo = '';
            if ('production' !== 'production') {
              if (!ReactComponentTreeHook) {
                ReactComponentTreeHook = $__require('3d');
              }
              if (debugID !== null) {
                componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
              } else if (element !== null) {
                componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
              }
            }
            'production' !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
          }
        }
      }
    }
    module.exports = checkReactTypeSpec;
  })($__require('15'));
});
$__System.registerDynamic('d1', ['15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var canDefineProperty = false;
    if ('production' !== 'production') {
      try {
        Object.defineProperty({}, 'x', { get: function () {} });
        canDefineProperty = true;
      } catch (x) {}
    }
    module.exports = canDefineProperty;
  })($__require('15'));
});
$__System.registerDynamic('c5', [], true, function ($__require, exports, module) {
  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  'use strict';

  /* global Symbol */

  var global = this || self,
      GLOBAL = global;
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  module.exports = getIteratorFn;
});
$__System.registerDynamic("45", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * 
   */

  var global = this || self,
      GLOBAL = global;
  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */
  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  module.exports = emptyFunction;
});
$__System.registerDynamic('24', ['45', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var emptyFunction = $__require('45');
    var warning = emptyFunction;
    if ('production' !== 'production') {
      (function () {
        var printWarning = function printWarning(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function () {
            return args[argIndex++];
          });
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {}
        };
        warning = function warning(condition, format) {
          if (format === undefined) {
            throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
          }
          if (format.indexOf('Failed Composite propType: ') === 0) {
            return;
          }
          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }
            printWarning.apply(undefined, [format].concat(args));
          }
        };
      })();
    }
    module.exports = warning;
  })($__require('15'));
});
$__System.registerDynamic('d2', ['15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var lowPriorityWarning = function () {};
    if ('production' !== 'production') {
      var printWarning = function (format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      };
      lowPriorityWarning = function (condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }
          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }
    module.exports = lowPriorityWarning;
  })($__require('15'));
});
$__System.registerDynamic('c9', ['40', '3d', 'c7', 'd9', 'd1', 'c5', '24', 'd2', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var ReactCurrentOwner = $__require('40');
    var ReactComponentTreeHook = $__require('3d');
    var ReactElement = $__require('c7');
    var checkReactTypeSpec = $__require('d9');
    var canDefineProperty = $__require('d1');
    var getIteratorFn = $__require('c5');
    var warning = $__require('24');
    var lowPriorityWarning = $__require('d2');
    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = ReactCurrentOwner.current.getName();
        if (name) {
          return ' Check the render method of `' + name + '`.';
        }
      }
      return '';
    }
    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return ' Check your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }
    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();
      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = ' Check the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;
      var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (memoizer[currentComponentErrorInfo]) {
        return;
      }
      memoizer[currentComponentErrorInfo] = true;
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
      }
      'production' !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
    }
    function validateChildKeys(node, parentType) {
      if (typeof node !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (ReactElement.isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (ReactElement.isValidElement(node)) {
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (iteratorFn) {
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (ReactElement.isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      if (componentClass.propTypes) {
        checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        'production' !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
      }
    }
    var ReactElementValidator = {
      createElement: function (type, props, children) {
        var validType = typeof type === 'string' || typeof type === 'function';
        if (!validType) {
          if (typeof type !== 'function' && typeof type !== 'string') {
            var info = '';
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            info += ReactComponentTreeHook.getCurrentStackAddendum();
            var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
            ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
            'production' !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
            ReactComponentTreeHook.popNonStandardWarningStack();
          }
        }
        var element = ReactElement.createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        validatePropTypes(element);
        return element;
      },
      createFactory: function (type) {
        var validatedFactory = ReactElementValidator.createElement.bind(null, type);
        validatedFactory.type = type;
        if ('production' !== 'production') {
          if (canDefineProperty) {
            Object.defineProperty(validatedFactory, 'type', {
              enumerable: false,
              get: function () {
                lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
                Object.defineProperty(this, 'type', { value: type });
                return type;
              }
            });
          }
        }
        return validatedFactory;
      },
      cloneElement: function (element, props, children) {
        var newElement = ReactElement.cloneElement.apply(this, arguments);
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
    };
    module.exports = ReactElementValidator;
  })($__require('15'));
});
$__System.registerDynamic('da', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) {
        return [];
    };

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
$__System.registerDynamic("db", ["da"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("da");
});
$__System.registerDynamic('dc', ['db'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__System._nodeRequire ? process : $__require('db');
});
$__System.registerDynamic("15", ["dc"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("dc");
});
$__System.registerDynamic('33', ['6', 'cf', 'c6', 'c8', 'c7', 'cd', 'ce', 'd4', 'd5', 'd2', 'd1', 'c9', '15'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var _assign = $__require('6');
    var ReactBaseClasses = $__require('cf');
    var ReactChildren = $__require('c6');
    var ReactDOMFactories = $__require('c8');
    var ReactElement = $__require('c7');
    var ReactPropTypes = $__require('cd');
    var ReactVersion = $__require('ce');
    var createReactClass = $__require('d4');
    var onlyChild = $__require('d5');
    var createElement = ReactElement.createElement;
    var createFactory = ReactElement.createFactory;
    var cloneElement = ReactElement.cloneElement;
    if ('production' !== 'production') {
      var lowPriorityWarning = $__require('d2');
      var canDefineProperty = $__require('d1');
      var ReactElementValidator = $__require('c9');
      var didWarnPropTypesDeprecated = false;
      createElement = ReactElementValidator.createElement;
      createFactory = ReactElementValidator.createFactory;
      cloneElement = ReactElementValidator.cloneElement;
    }
    var __spread = _assign;
    var createMixin = function (mixin) {
      return mixin;
    };
    if ('production' !== 'production') {
      var warnedForSpread = false;
      var warnedForCreateMixin = false;
      __spread = function () {
        lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
        warnedForSpread = true;
        return _assign.apply(null, arguments);
      };
      createMixin = function (mixin) {
        lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
        warnedForCreateMixin = true;
        return mixin;
      };
    }
    var React = {
      Children: {
        map: ReactChildren.map,
        forEach: ReactChildren.forEach,
        count: ReactChildren.count,
        toArray: ReactChildren.toArray,
        only: onlyChild
      },
      Component: ReactBaseClasses.Component,
      PureComponent: ReactBaseClasses.PureComponent,
      createElement: createElement,
      cloneElement: cloneElement,
      isValidElement: ReactElement.isValidElement,
      PropTypes: ReactPropTypes,
      createClass: createReactClass,
      createFactory: createFactory,
      createMixin: createMixin,
      DOM: ReactDOMFactories,
      version: ReactVersion,
      __spread: __spread
    };
    if ('production' !== 'production') {
      var warnedForCreateClass = false;
      if (canDefineProperty) {
        Object.defineProperty(React, 'PropTypes', { get: function () {
            lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
            didWarnPropTypesDeprecated = true;
            return ReactPropTypes;
          } });
        Object.defineProperty(React, 'createClass', { get: function () {
            lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
            warnedForCreateClass = true;
            return createReactClass;
          } });
      }
      React.DOM = {};
      var warnedForFactories = false;
      Object.keys(ReactDOMFactories).forEach(function (factory) {
        React.DOM[factory] = function () {
          if (!warnedForFactories) {
            lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
            warnedForFactories = true;
          }
          return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
        };
      });
    }
    module.exports = React;
  })($__require('15'));
});
$__System.registerDynamic('dd', ['33'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  module.exports = $__require('33');
});
$__System.registerDynamic("de", ["dd"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("dd");
});
$__System.register("df", ["af", "bb", "be", "bf", "de"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, React, TableView;

    return {
        setters: [function (_af) {
            _get = _af["default"];
        }, function (_bb) {
            _inherits = _bb["default"];
        }, function (_be) {
            _createClass = _be["default"];
        }, function (_bf) {
            _classCallCheck = _bf["default"];
        }, function (_de) {
            React = _de;
        }],
        execute: function () {
            "use strict";

            TableView = (function (_React$Component) {
                _inherits(TableView, _React$Component);

                function TableView() {
                    _classCallCheck(this, TableView);

                    _get(Object.getPrototypeOf(TableView.prototype), "constructor", this).apply(this, arguments);
                }

                _createClass(TableView, [{
                    key: "render",
                    value: function render() {
                        return React.createElement("div", null, "Hello World!");
                    }
                }]);

                return TableView;
            })(React.Component);

            _export("TableView", TableView);
        }
    };
});
$__System.register("1", ["de", "9f", "a2", "df"], function (_export) {
  "use strict";

  var React, ReactDOM, db, TableView;
  return {
    setters: [function (_de) {
      React = _de;
    }, function (_f) {
      ReactDOM = _f;
    }, function (_a2) {
      db = _a2.db;
    }, function (_df) {
      TableView = _df.TableView;
    }],
    execute: function () {

      db.query('ajexpenditor/people', {
        include_docs: true
      }).then(function (data) {
        console.log(data.rows);
      });

      ReactDOM.render(React.createElement(TableView, null), document.getElementById('root'));
    }
  };
});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=index.js.map