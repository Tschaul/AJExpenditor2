/* */ 
'use strict';
const CallTracker = require('./CallTracker');
const createSpy = require('./createSpy');
const SpyStrategy = require('./SpyStrategy');
const formatErrorMsg = function() {
  function generateErrorMsg(domain, usage) {
    const usageDefinition = usage ? '\nUsage: ' + usage : '';
    return function errorMsg(msg) {
      return domain + ' : ' + msg + usageDefinition;
    };
  }
  return generateErrorMsg;
};
function isSpy(putativeSpy) {
  if (!putativeSpy) {
    return false;
  }
  return (putativeSpy.and instanceof SpyStrategy && putativeSpy.calls instanceof CallTracker);
}
const getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');
function SpyRegistry(options) {
  options = options || {};
  const currentSpies = options.currentSpies || function() {
    return [];
  };
  this.allowRespy = function(allow) {
    this.respy = allow;
  };
  this.spyOn = function(obj, methodName) {
    if (obj === void 0) {
      throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));
    }
    if (methodName === void 0) {
      throw new Error(getErrorMsg('No method name supplied'));
    }
    if (obj[methodName] === void 0) {
      throw new Error(getErrorMsg(methodName + '() method does not exist'));
    }
    if (obj[methodName] && isSpy(obj[methodName])) {
      if (this.respy) {
        return obj[methodName];
      } else {
        throw new Error(getErrorMsg(methodName + ' has already been spied upon'));
      }
    }
    let descriptor;
    try {
      descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
    } catch (e) {}
    if (descriptor && !(descriptor.writable || descriptor.set)) {
      throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));
    }
    const originalMethod = obj[methodName];
    const spiedMethod = createSpy(methodName, originalMethod);
    let restoreStrategy;
    if (Object.prototype.hasOwnProperty.call(obj, methodName)) {
      restoreStrategy = function() {
        obj[methodName] = originalMethod;
      };
    } else {
      restoreStrategy = function() {
        if (!delete obj[methodName]) {
          obj[methodName] = originalMethod;
        }
      };
    }
    currentSpies().push({restoreObjectToOriginalState: restoreStrategy});
    obj[methodName] = spiedMethod;
    return spiedMethod;
  };
  this.clearSpies = function() {
    const spies = currentSpies();
    for (let i = spies.length - 1; i >= 0; i--) {
      const spyEntry = spies[i];
      spyEntry.restoreObjectToOriginalState();
    }
  };
}
module.exports = SpyRegistry;
