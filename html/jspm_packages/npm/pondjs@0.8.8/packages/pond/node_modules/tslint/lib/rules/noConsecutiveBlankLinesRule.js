/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var utils = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.FAILURE_STRING_FACTORY = function(allowed) {
    return allowed === 1 ? "Consecutive blank lines are forbidden" : "Exceeds the " + allowed + " allowed consecutive blank lines";
  };
  Rule.prototype.isEnabled = function() {
    var option = this.ruleArguments[0];
    return _super.prototype.isEnabled.call(this) && (option === undefined || option > 0);
  };
  Rule.prototype.apply = function(sourceFile) {
    var limit = this.ruleArguments[0];
    return this.applyWithFunction(sourceFile, walk, limit !== undefined ? limit : Rule.DEFAULT_ALLOWED_BLANKS);
  };
  Rule.DEFAULT_ALLOWED_BLANKS = 1;
  Rule.metadata = {
    ruleName: "no-consecutive-blank-lines",
    description: "Disallows one or more blank lines in a row.",
    hasFix: true,
    rationale: "Helps maintain a readable style in your codebase.",
    optionsDescription: (_a = ["\n            An optional number of maximum allowed sequential blanks can be specified. If no value\n            is provided, a default of ", " will be used."], _a.raw = ["\n            An optional number of maximum allowed sequential blanks can be specified. If no value\n            is provided, a default of ", " will be used."], Lint.Utils.dedent(_a, Rule.DEFAULT_ALLOWED_BLANKS)),
    options: {
      type: "number",
      minimum: "1"
    },
    optionExamples: [true, [true, 2]],
    type: "style",
    typescriptOnly: false
  };
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  var sourceText = ctx.sourceFile.text;
  var threshold = ctx.options + 1;
  var possibleFailures = [];
  var consecutiveBlankLines = 0;
  for (var _i = 0,
      _a = utils.getLineRanges(ctx.sourceFile); _i < _a.length; _i++) {
    var line = _a[_i];
    if (line.contentLength === 0 || sourceText.substr(line.pos, line.contentLength).search(/\S/) === -1) {
      ++consecutiveBlankLines;
      if (consecutiveBlankLines === threshold) {
        possibleFailures.push({
          end: line.end,
          pos: line.pos
        });
      } else if (consecutiveBlankLines > threshold) {
        possibleFailures[possibleFailures.length - 1].end = line.end;
      }
    } else {
      consecutiveBlankLines = 0;
    }
  }
  if (possibleFailures.length === 0) {
    return;
  }
  var failureString = Rule.FAILURE_STRING_FACTORY(ctx.options);
  var templateRanges = getTemplateRanges(ctx.sourceFile);
  var _loop_1 = function(possibleFailure) {
    if (!templateRanges.some(function(template) {
      return template.pos < possibleFailure.pos && possibleFailure.pos < template.end;
    })) {
      ctx.addFailureAt(possibleFailure.pos, 1, failureString, [Lint.Replacement.deleteFromTo(possibleFailure.end === sourceText.length ? getStartOfLineBreak(sourceText, possibleFailure.pos) : possibleFailure.pos, possibleFailure.end)]);
    }
  };
  for (var _b = 0,
      possibleFailures_1 = possibleFailures; _b < possibleFailures_1.length; _b++) {
    var possibleFailure = possibleFailures_1[_b];
    _loop_1(possibleFailure);
  }
}
function getStartOfLineBreak(sourceText, pos) {
  return sourceText[pos - 2] === "\r" ? pos - 1 : pos - 1;
}
function getTemplateRanges(sourceFile) {
  var intervals = [];
  var cb = function(node) {
    if (node.kind >= ts.SyntaxKind.FirstTemplateToken && node.kind <= ts.SyntaxKind.LastTemplateToken) {
      intervals.push({
        end: node.end,
        pos: node.getStart(sourceFile)
      });
    } else {
      return ts.forEachChild(node, cb);
    }
  };
  ts.forEachChild(sourceFile, cb);
  return intervals;
}
exports.getTemplateRanges = getTemplateRanges;
var _a;
