/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var Lint = require('../index');
var OPTION_LINEBREAK_STYLE_CRLF = "CRLF";
var OPTION_LINEBREAK_STYLE_LF = "LF";
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk, this.ruleArguments.indexOf(OPTION_LINEBREAK_STYLE_CRLF) !== -1);
  };
  Rule.metadata = {
    ruleName: "linebreak-style",
    description: "Enforces a consistent linebreak style.",
    optionsDescription: (_a = ["\n            One of the following options must be provided:\n\n            * `\"", "\"` requires LF (`\\n`) linebreaks\n            * `\"", "\"` requires CRLF (`\\r\\n`) linebreaks"], _a.raw = ["\n            One of the following options must be provided:\n\n            * \\`\"", "\"\\` requires LF (\\`\\\\n\\`) linebreaks\n            * \\`\"", "\"\\` requires CRLF (\\`\\\\r\\\\n\\`) linebreaks"], Lint.Utils.dedent(_a, OPTION_LINEBREAK_STYLE_LF, OPTION_LINEBREAK_STYLE_CRLF)),
    options: {
      type: "string",
      enum: [OPTION_LINEBREAK_STYLE_LF, OPTION_LINEBREAK_STYLE_CRLF]
    },
    optionExamples: [[true, OPTION_LINEBREAK_STYLE_LF], [true, OPTION_LINEBREAK_STYLE_CRLF]],
    type: "maintainability",
    typescriptOnly: false,
    hasFix: true
  };
  Rule.FAILURE_CRLF = "Expected linebreak to be '" + OPTION_LINEBREAK_STYLE_CRLF + "'";
  Rule.FAILURE_LF = "Expected linebreak to be '" + OPTION_LINEBREAK_STYLE_LF + "'";
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  var expectedCr = ctx.options;
  var sourceText = ctx.sourceFile.text;
  var lineStarts = ctx.sourceFile.getLineStarts();
  for (var i = 1; i < lineStarts.length; ++i) {
    var lineEnd = lineStarts[i] - 1;
    if (sourceText[lineEnd - 1] === "\r") {
      if (!expectedCr) {
        ctx.addFailure(lineStarts[i - 1], lineEnd - 1, Rule.FAILURE_LF, Lint.Replacement.deleteText(lineEnd - 1, 1));
      }
    } else if (expectedCr) {
      ctx.addFailure(lineStarts[i - 1], lineEnd, Rule.FAILURE_CRLF, Lint.Replacement.appendText(lineEnd, "\r"));
    }
  }
}
var _a;
