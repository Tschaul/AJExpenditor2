/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var abstractFormatter_1 = require('../language/formatter/abstractFormatter');
var Formatter = (function(_super) {
  tslib_1.__extends(Formatter, _super);
  function Formatter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Formatter.prototype.format = function(failures) {
    return this.mapToMessages(failures).join("\n") + "\n";
  };
  Formatter.prototype.mapToMessages = function(failures) {
    return failures.map(function(failure) {
      var fileName = failure.getFileName();
      var failureString = failure.getFailure();
      var ruleName = failure.getRuleName();
      var lineAndCharacter = failure.getStartPosition().getLineAndCharacter();
      var positionTuple = "[" + (lineAndCharacter.line + 1) + ", " + (lineAndCharacter.character + 1) + "]";
      return failure.getRuleSeverity().toUpperCase() + ": (" + ruleName + ") " + fileName + positionTuple + ": " + failureString;
    });
  };
  Formatter.metadata = {
    formatterName: "verbose",
    description: "The human-readable formatter which includes the rule name in messages.",
    descriptionDetails: "The output is the same as the prose formatter with the rule name included",
    sample: "ERROR: (semicolon) myFile.ts[1, 14]: Missing semicolon",
    consumer: "human"
  };
  return Formatter;
}(abstractFormatter_1.AbstractFormatter));
exports.Formatter = Formatter;
