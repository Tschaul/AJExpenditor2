/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.FAILURE_STRING_FACTORY = function(lineLimit) {
    return "Exceeds maximum line length of " + lineLimit;
  };
  Rule.prototype.isEnabled = function() {
    return _super.prototype.isEnabled.call(this) && this.ruleArguments[0] > 0;
  };
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk, this.ruleArguments[0]);
  };
  Rule.metadata = {
    ruleName: "max-line-length",
    description: "Requires lines to be under a certain max length.",
    rationale: (_a = ["\n            Limiting the length of a line of code improves code readability.\n            It also makes comparing code side-by-side easier and improves compatibility with\n            various editors, IDEs, and diff viewers."], _a.raw = ["\n            Limiting the length of a line of code improves code readability.\n            It also makes comparing code side-by-side easier and improves compatibility with\n            various editors, IDEs, and diff viewers."], Lint.Utils.dedent(_a)),
    optionsDescription: "An integer indicating the max length of lines.",
    options: {
      type: "number",
      minimum: "1"
    },
    optionExamples: [[true, 120]],
    type: "maintainability",
    typescriptOnly: false
  };
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  var limit = ctx.options;
  for (var _i = 0,
      _a = tsutils_1.getLineRanges(ctx.sourceFile); _i < _a.length; _i++) {
    var line = _a[_i];
    if (line.contentLength > limit) {
      ctx.addFailureAt(line.pos, line.contentLength, Rule.FAILURE_STRING_FACTORY(limit));
    }
  }
}
var _a;
