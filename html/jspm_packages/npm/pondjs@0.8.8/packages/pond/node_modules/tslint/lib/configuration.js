/* */ 
(function(process) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  var fs = require('fs');
  var path = require('path');
  var resolve = require('../../resolve/index');
  var error_1 = require('./error');
  var utils_1 = require('./utils');
  exports.CONFIG_FILENAME = "tslint.json";
  exports.DEFAULT_CONFIG = {
    defaultSeverity: "error",
    extends: ["tslint:recommended"],
    jsRules: new Map(),
    rules: new Map(),
    rulesDirectory: []
  };
  exports.EMPTY_CONFIG = {
    defaultSeverity: "error",
    extends: [],
    jsRules: new Map(),
    rules: new Map(),
    rulesDirectory: []
  };
  var BUILT_IN_CONFIG = /^tslint:(.*)$/;
  function findConfiguration(configFile, inputFilePath) {
    var configPath = findConfigurationPath(configFile, inputFilePath);
    var loadResult = {path: configPath};
    try {
      loadResult.results = loadConfigurationFromPath(configPath);
      return loadResult;
    } catch (error) {
      throw new error_1.FatalError("Failed to load " + configPath + ": " + error.message, error);
    }
  }
  exports.findConfiguration = findConfiguration;
  function findConfigurationPath(suppliedConfigFilePath, inputFilePath) {
    if (suppliedConfigFilePath != null) {
      if (!fs.existsSync(suppliedConfigFilePath)) {
        throw new error_1.FatalError("Could not find config file at: " + path.resolve(suppliedConfigFilePath));
      } else {
        return path.resolve(suppliedConfigFilePath);
      }
    } else {
      var useDirName = false;
      try {
        var stats = fs.statSync(inputFilePath);
        if (stats.isFile()) {
          useDirName = true;
        }
      } catch (e) {
        useDirName = true;
      }
      if (useDirName) {
        inputFilePath = path.dirname(inputFilePath);
      }
      var configFilePath = findup(exports.CONFIG_FILENAME, inputFilePath);
      if (configFilePath !== undefined) {
        return path.resolve(configFilePath);
      }
      var homeDir = getHomeDir();
      if (homeDir != null) {
        configFilePath = path.join(homeDir, exports.CONFIG_FILENAME);
        if (fs.existsSync(configFilePath)) {
          return path.resolve(configFilePath);
        }
      }
      return undefined;
    }
  }
  exports.findConfigurationPath = findConfigurationPath;
  function findup(filename, directory) {
    while (true) {
      var res = findFile(directory);
      if (res !== undefined) {
        return path.join(directory, res);
      }
      var parent = path.dirname(directory);
      if (parent === directory) {
        return undefined;
      }
      directory = parent;
    }
    function findFile(cwd) {
      if (fs.existsSync(path.join(cwd, filename))) {
        return filename;
      }
      var filenameLower = filename.toLowerCase();
      var result = fs.readdirSync(cwd).find(function(entry) {
        return entry.toLowerCase() === filenameLower;
      });
      if (result !== undefined) {
        error_1.showWarningOnce("Using mixed case tslint.json is deprecated. Found: " + path.join(cwd, result));
      }
      return result;
    }
  }
  function loadConfigurationFromPath(configFilePath, originalFilePath) {
    if (originalFilePath === void 0) {
      originalFilePath = configFilePath;
    }
    if (configFilePath == null) {
      return exports.DEFAULT_CONFIG;
    } else {
      var resolvedConfigFilePath = resolveConfigurationPath(configFilePath);
      var rawConfigFile = void 0;
      if (path.extname(resolvedConfigFilePath) === ".json") {
        var fileContent = utils_1.stripComments(fs.readFileSync(resolvedConfigFilePath).toString().replace(/^\uFEFF/, ""));
        try {
          rawConfigFile = JSON.parse(fileContent);
        } catch (e) {
          var error = e;
          throw configFilePath === originalFilePath ? error : new Error(error.message + " in " + configFilePath);
        }
      } else {
        rawConfigFile = require(resolvedConfigFilePath);
        delete require.cache[resolvedConfigFilePath];
      }
      var configFileDir_1 = path.dirname(resolvedConfigFilePath);
      var configFile = parseConfigFile(rawConfigFile, configFileDir_1);
      var configs = configFile.extends.map(function(name) {
        var nextConfigFilePath = resolveConfigurationPath(name, configFileDir_1);
        return loadConfigurationFromPath(nextConfigFilePath, originalFilePath);
      }).concat([configFile]);
      return configs.reduce(extendConfigurationFile, exports.EMPTY_CONFIG);
    }
  }
  exports.loadConfigurationFromPath = loadConfigurationFromPath;
  function resolveConfigurationPath(filePath, relativeTo) {
    var matches = filePath.match(BUILT_IN_CONFIG);
    var isBuiltInConfig = matches != null && matches.length > 0;
    if (isBuiltInConfig) {
      var configName = matches[1];
      try {
        return require.resolve("./configs/" + configName);
      } catch (err) {
        throw new Error(filePath + " is not a built-in config, try \"tslint:recommended\" instead.");
      }
    }
    var basedir = relativeTo !== undefined ? relativeTo : process.cwd();
    try {
      return resolve.sync(filePath, {basedir: basedir});
    } catch (err) {
      try {
        return require.resolve(filePath);
      } catch (err) {
        throw new Error("Invalid \"extends\" configuration value - could not require \"" + filePath + "\". " + "Review the Node lookup algorithm (https://nodejs.org/api/modules.html#modules_all_together) " + "for the approximate method TSLint uses to find the referenced configuration file.");
      }
    }
  }
  function extendConfigurationFile(targetConfig, nextConfigSource) {
    function combineProperties(targetProperty, nextProperty) {
      var combinedProperty = {};
      add(targetProperty);
      add(nextProperty);
      return combinedProperty;
      function add(property) {
        if (property !== undefined) {
          for (var name in property) {
            if (utils_1.hasOwnProperty(property, name)) {
              combinedProperty[name] = property[name];
            }
          }
        }
      }
    }
    function combineMaps(target, next) {
      var combined = new Map();
      target.forEach(function(options, ruleName) {
        combined.set(ruleName, options);
      });
      next.forEach(function(options, ruleName) {
        var combinedRule = combined.get(ruleName);
        if (combinedRule != null) {
          combined.set(ruleName, combineProperties(combinedRule, options));
        } else {
          combined.set(ruleName, options);
        }
      });
      return combined;
    }
    var combinedRulesDirs = targetConfig.rulesDirectory.concat(nextConfigSource.rulesDirectory);
    var dedupedRulesDirs = Array.from(new Set(combinedRulesDirs));
    return {
      extends: [],
      jsRules: combineMaps(targetConfig.jsRules, nextConfigSource.jsRules),
      linterOptions: combineProperties(targetConfig.linterOptions, nextConfigSource.linterOptions),
      rules: combineMaps(targetConfig.rules, nextConfigSource.rules),
      rulesDirectory: dedupedRulesDirs
    };
  }
  exports.extendConfigurationFile = extendConfigurationFile;
  function getHomeDir() {
    var environment = global.process.env;
    var paths = [environment.USERPROFILE, environment.HOME, environment.HOMEPATH, environment.HOMEDRIVE + environment.HOMEPATH];
    for (var _i = 0,
        paths_1 = paths; _i < paths_1.length; _i++) {
      var homePath = paths_1[_i];
      if (homePath != null && fs.existsSync(homePath)) {
        return homePath;
      }
    }
    return undefined;
  }
  function getRelativePath(directory, relativeTo) {
    if (directory != null) {
      var basePath = relativeTo !== undefined ? relativeTo : process.cwd();
      return path.resolve(basePath, directory);
    }
    return undefined;
  }
  exports.getRelativePath = getRelativePath;
  function useAsPath(directory) {
    return /^(?:\.?\.?(?:\/|$)|node_modules\/)/.test(directory);
  }
  exports.useAsPath = useAsPath;
  function getRulesDirectories(directories, relativeTo) {
    return utils_1.arrayify(directories).map(function(dir) {
      if (!useAsPath(dir)) {
        try {
          return path.dirname(resolve.sync(dir, {basedir: relativeTo}));
        } catch (err) {}
      }
      var absolutePath = getRelativePath(dir, relativeTo);
      if (absolutePath != null) {
        if (!fs.existsSync(absolutePath)) {
          throw new error_1.FatalError("Could not find custom rule directory: " + dir);
        }
      }
      return absolutePath;
    }).filter(function(dir) {
      return dir !== undefined;
    });
  }
  exports.getRulesDirectories = getRulesDirectories;
  function parseRuleOptions(ruleConfigValue, rawDefaultRuleSeverity) {
    var ruleArguments;
    var defaultRuleSeverity = "error";
    if (rawDefaultRuleSeverity !== undefined) {
      switch (rawDefaultRuleSeverity.toLowerCase()) {
        case "warn":
        case "warning":
          defaultRuleSeverity = "warning";
          break;
        case "off":
        case "none":
          defaultRuleSeverity = "off";
          break;
        default:
          defaultRuleSeverity = "error";
      }
    }
    var ruleSeverity = defaultRuleSeverity;
    if (ruleConfigValue == null) {
      ruleArguments = [];
      ruleSeverity = "off";
    } else if (Array.isArray(ruleConfigValue)) {
      if (ruleConfigValue.length > 0) {
        ruleArguments = ruleConfigValue.slice(1);
        ruleSeverity = ruleConfigValue[0] === true ? defaultRuleSeverity : "off";
      }
    } else if (typeof ruleConfigValue === "boolean") {
      ruleArguments = [];
      ruleSeverity = ruleConfigValue ? defaultRuleSeverity : "off";
    } else if (typeof ruleConfigValue === "object") {
      if (ruleConfigValue.severity !== undefined) {
        switch (ruleConfigValue.severity.toLowerCase()) {
          case "default":
            ruleSeverity = defaultRuleSeverity;
            break;
          case "error":
            ruleSeverity = "error";
            break;
          case "warn":
          case "warning":
            ruleSeverity = "warning";
            break;
          case "off":
          case "none":
            ruleSeverity = "off";
            break;
          default:
            console.warn("Invalid severity level: " + ruleConfigValue.severity);
            ruleSeverity = defaultRuleSeverity;
        }
      }
      if (ruleConfigValue.options != null) {
        ruleArguments = utils_1.arrayify(ruleConfigValue.options);
      }
    }
    return {
      ruleArguments: ruleArguments,
      ruleSeverity: ruleSeverity
    };
  }
  function parseConfigFile(configFile, configFileDir) {
    return {
      extends: utils_1.arrayify(configFile.extends),
      jsRules: parseRules(configFile.jsRules),
      linterOptions: configFile.linterOptions !== undefined ? configFile.linterOptions : {},
      rules: parseRules(configFile.rules),
      rulesDirectory: getRulesDirectories(configFile.rulesDirectory, configFileDir)
    };
    function parseRules(config) {
      var map = new Map();
      if (config !== undefined) {
        for (var ruleName in config) {
          if (utils_1.hasOwnProperty(config, ruleName)) {
            map.set(ruleName, parseRuleOptions(config[ruleName], configFile.defaultSeverity));
          }
        }
      }
      return map;
    }
  }
  exports.parseConfigFile = parseConfigFile;
  function convertRuleOptions(ruleConfiguration) {
    var output = [];
    ruleConfiguration.forEach(function(_a, ruleName) {
      var ruleArguments = _a.ruleArguments,
          ruleSeverity = _a.ruleSeverity;
      var options = {
        disabledIntervals: [],
        ruleArguments: ruleArguments != null ? ruleArguments : [],
        ruleName: ruleName,
        ruleSeverity: ruleSeverity != null ? ruleSeverity : "error"
      };
      output.push(options);
    });
    return output;
  }
  exports.convertRuleOptions = convertRuleOptions;
})(require('process'));
