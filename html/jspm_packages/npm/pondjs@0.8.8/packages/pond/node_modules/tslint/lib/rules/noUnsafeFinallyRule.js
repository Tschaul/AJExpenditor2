/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var utils = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.FAILURE_STRING = function(name) {
    return "'" + name + "' statements in finally blocks are forbidden.";
  };
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk);
  };
  Rule.metadata = {
    ruleName: "no-unsafe-finally",
    description: (_a = ["\n            Disallows control flow statements, such as `return`, `continue`,\n            `break` and `throws` in finally blocks."], _a.raw = ["\n            Disallows control flow statements, such as \\`return\\`, \\`continue\\`,\n            \\`break\\` and \\`throws\\` in finally blocks."], Lint.Utils.dedent(_a)),
    descriptionDetails: "",
    rationale: (_b = ["\n            When used inside `finally` blocks, control flow statements,\n            such as `return`, `continue`, `break` and `throws`\n            override any other control flow statements in the same try/catch scope.\n            This is confusing and unexpected behavior."], _b.raw = ["\n            When used inside \\`finally\\` blocks, control flow statements,\n            such as \\`return\\`, \\`continue\\`, \\`break\\` and \\`throws\\`\n            override any other control flow statements in the same try/catch scope.\n            This is confusing and unexpected behavior."], Lint.Utils.dedent(_b)),
    optionsDescription: "Not configurable.",
    options: null,
    optionExamples: [true],
    type: "functionality",
    typescriptOnly: false
  };
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  var inFinally = false;
  ts.forEachChild(ctx.sourceFile, function cb(node) {
    switch (node.kind) {
      case ts.SyntaxKind.TryStatement:
        var _a = node,
            tryBlock = _a.tryBlock,
            catchClause = _a.catchClause,
            finallyBlock = _a.finallyBlock;
        ts.forEachChild(tryBlock, cb);
        if (catchClause !== undefined) {
          ts.forEachChild(catchClause, cb);
        }
        if (finallyBlock !== undefined) {
          var old = inFinally;
          inFinally = true;
          cb(finallyBlock);
          inFinally = old;
        }
        break;
      case ts.SyntaxKind.BreakStatement:
      case ts.SyntaxKind.ContinueStatement:
      case ts.SyntaxKind.ThrowStatement:
      case ts.SyntaxKind.ReturnStatement:
        if (inFinally && !jumpIsLocalToFinallyBlock(node)) {
          ctx.addFailureAtNode(node, Rule.FAILURE_STRING(printJumpKind(node)));
        }
      default:
        return ts.forEachChild(node, cb);
    }
  });
}
function jumpIsLocalToFinallyBlock(jump) {
  var isBreakOrContinue = utils.isBreakOrContinueStatement(jump);
  var label = isBreakOrContinue ? jump.label : undefined;
  var node = jump;
  while (true) {
    var parent = node.parent;
    switch (parent.kind) {
      case ts.SyntaxKind.TryStatement:
        if (parent.finallyBlock === node) {
          return false;
        }
        break;
      case ts.SyntaxKind.SwitchStatement:
        if (jump.kind === ts.SyntaxKind.BreakStatement && label === undefined) {
          return true;
        }
        break;
      case ts.SyntaxKind.ForInStatement:
      case ts.SyntaxKind.ForOfStatement:
      case ts.SyntaxKind.ForStatement:
      case ts.SyntaxKind.WhileStatement:
      case ts.SyntaxKind.DoStatement:
        if (isBreakOrContinue && label === undefined) {
          return true;
        }
        break;
      case ts.SyntaxKind.LabeledStatement:
        {
          var text = parent.label.text;
          if (label !== undefined && label.text === text) {
            return true;
          }
          break;
        }
      default:
        if (utils.isFunctionScopeBoundary(parent)) {
          return true;
        }
    }
    node = parent;
  }
}
function printJumpKind(node) {
  switch (node.kind) {
    case ts.SyntaxKind.BreakStatement:
      return "break";
    case ts.SyntaxKind.ContinueStatement:
      return "continue";
    case ts.SyntaxKind.ThrowStatement:
      return "throw";
    case ts.SyntaxKind.ReturnStatement:
      return "return";
  }
}
var _a,
    _b;
