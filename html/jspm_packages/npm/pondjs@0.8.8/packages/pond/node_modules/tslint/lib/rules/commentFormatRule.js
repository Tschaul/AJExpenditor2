/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var utils = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var enableDisableRules_1 = require('../enableDisableRules');
var Lint = require('../index');
var utils_1 = require('../utils');
var OPTION_SPACE = "check-space";
var OPTION_LOWERCASE = "check-lowercase";
var OPTION_UPPERCASE = "check-uppercase";
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk, parseOptions(this.ruleArguments));
  };
  Rule.metadata = {
    ruleName: "comment-format",
    description: "Enforces formatting rules for single-line comments.",
    rationale: "Helps maintain a consistent, readable style in your codebase.",
    optionsDescription: (_a = ["\n            Three arguments may be optionally provided:\n\n            * `\"check-space\"` requires that all single-line comments must begin with a space, as in `// comment`\n                * note that for comments starting with multiple slashes, e.g. `///`, leading slashes are ignored\n                * TypeScript reference comments are ignored completely\n            * `\"check-lowercase\"` requires that the first non-whitespace character of a comment must be lowercase, if applicable.\n            * `\"check-uppercase\"` requires that the first non-whitespace character of a comment must be uppercase, if applicable.\n\n            Exceptions to `\"check-lowercase\"` or `\"check-uppercase\"` can be managed with object that may be passed as last argument.\n\n            One of two options can be provided in this object:\n\n                * `\"ignore-words\"`  - array of strings - words that will be ignored at the beginning of the comment.\n                * `\"ignore-pattern\"` - string - RegExp pattern that will be ignored at the beginning of the comment.\n            "], _a.raw = ["\n            Three arguments may be optionally provided:\n\n            * \\`\"check-space\"\\` requires that all single-line comments must begin with a space, as in \\`// comment\\`\n                * note that for comments starting with multiple slashes, e.g. \\`///\\`, leading slashes are ignored\n                * TypeScript reference comments are ignored completely\n            * \\`\"check-lowercase\"\\` requires that the first non-whitespace character of a comment must be lowercase, if applicable.\n            * \\`\"check-uppercase\"\\` requires that the first non-whitespace character of a comment must be uppercase, if applicable.\n\n            Exceptions to \\`\"check-lowercase\"\\` or \\`\"check-uppercase\"\\` can be managed with object that may be passed as last argument.\n\n            One of two options can be provided in this object:\n\n                * \\`\"ignore-words\"\\`  - array of strings - words that will be ignored at the beginning of the comment.\n                * \\`\"ignore-pattern\"\\` - string - RegExp pattern that will be ignored at the beginning of the comment.\n            "], Lint.Utils.dedent(_a)),
    options: {
      type: "array",
      items: {anyOf: [{
          type: "string",
          enum: ["check-space", "check-lowercase", "check-uppercase"]
        }, {
          type: "object",
          properties: {
            "ignore-words": {
              type: "array",
              items: {type: "string"}
            },
            "ignore-pattern": {type: "string"}
          },
          minProperties: 1,
          maxProperties: 1
        }]},
      minLength: 1,
      maxLength: 4
    },
    optionExamples: [[true, "check-space", "check-uppercase"], [true, "check-lowercase", {"ignore-words": ["TODO", "HACK"]}], [true, "check-lowercase", {"ignore-pattern": "STD\\w{2,3}\\b"}]],
    type: "style",
    typescriptOnly: false
  };
  Rule.LOWERCASE_FAILURE = "comment must start with lowercase letter";
  Rule.UPPERCASE_FAILURE = "comment must start with uppercase letter";
  Rule.LEADING_SPACE_FAILURE = "comment must start with a space";
  Rule.IGNORE_WORDS_FAILURE_FACTORY = function(words) {
    return " or the word(s): " + words.join(", ");
  };
  Rule.IGNORE_PATTERN_FAILURE_FACTORY = function(pattern) {
    return " or its start must match the regex pattern \"" + pattern + "\"";
  };
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function parseOptions(options) {
  return tslib_1.__assign({
    case: options.indexOf(OPTION_LOWERCASE) !== -1 ? 1 : options.indexOf(OPTION_UPPERCASE) !== -1 ? 2 : 0,
    failureSuffix: "",
    space: options.indexOf(OPTION_SPACE) !== -1
  }, composeExceptions(options[options.length - 1]));
}
function composeExceptions(option) {
  if (typeof option !== "object") {
    return undefined;
  }
  var ignorePattern = option["ignore-pattern"];
  if (ignorePattern !== undefined) {
    return {
      exceptions: new RegExp("^\\s*(" + ignorePattern + ")"),
      failureSuffix: Rule.IGNORE_PATTERN_FAILURE_FACTORY(ignorePattern)
    };
  }
  var ignoreWords = option["ignore-words"];
  if (ignoreWords !== undefined && ignoreWords.length !== 0) {
    return {
      exceptions: new RegExp("^\\s*(?:" + ignoreWords.map(function(word) {
        return utils_1.escapeRegExp(word.trim());
      }).join("|") + ")\\b"),
      failureSuffix: Rule.IGNORE_WORDS_FAILURE_FACTORY(ignoreWords)
    };
  }
  return undefined;
}
function walk(ctx) {
  utils.forEachComment(ctx.sourceFile, function(fullText, _a) {
    var kind = _a.kind,
        pos = _a.pos,
        end = _a.end;
    var start = pos + 2;
    if (kind !== ts.SyntaxKind.SingleLineCommentTrivia || start === end || fullText[start] === "/" && ctx.sourceFile.referencedFiles.some(function(ref) {
      return ref.pos >= pos && ref.end <= end;
    })) {
      return;
    }
    while (fullText[start] === "/") {
      ++start;
    }
    if (start === end) {
      return;
    }
    var commentText = fullText.slice(start, end);
    if (/^(?:#(?:end)?region|noinspection\s)/.test(commentText)) {
      return;
    }
    if (ctx.options.space && commentText[0] !== " ") {
      ctx.addFailure(start, end, Rule.LEADING_SPACE_FAILURE);
    }
    if (ctx.options.case === 0 || ctx.options.exceptions !== undefined && ctx.options.exceptions.test(commentText) || enableDisableRules_1.ENABLE_DISABLE_REGEX.test(commentText)) {
      return;
    }
    var charPos = commentText.search(/\S/);
    if (charPos === -1) {
      return;
    }
    if (ctx.options.case === 1) {
      if (!utils_1.isLowerCase(commentText[charPos])) {
        ctx.addFailure(start, end, Rule.LOWERCASE_FAILURE + ctx.options.failureSuffix);
      }
    } else if (!utils_1.isUpperCase(commentText[charPos])) {
      ctx.addFailure(start, end, Rule.UPPERCASE_FAILURE + ctx.options.failureSuffix);
    }
  });
}
var _a;
