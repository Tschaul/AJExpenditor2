/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.applyWithProgram = function(sourceFile, program) {
    return this.applyWithFunction(sourceFile, function(ctx) {
      return walk(ctx, program.getTypeChecker());
    });
  };
  Rule.metadata = {
    ruleName: "promise-function-async",
    description: "Requires any function or method that returns a promise to be marked async.",
    rationale: (_a = ["\n            Ensures that each function is only capable of 1) returning a rejected promise, or 2)\n            throwing an Error object. In contrast, non-`async` `Promise`-returning functions\n            are technically capable of either. This practice removes a requirement for consuming\n            code to handle both cases.\n        "], _a.raw = ["\n            Ensures that each function is only capable of 1) returning a rejected promise, or 2)\n            throwing an Error object. In contrast, non-\\`async\\` \\`Promise\\`-returning functions\n            are technically capable of either. This practice removes a requirement for consuming\n            code to handle both cases.\n        "], Lint.Utils.dedent(_a)),
    optionsDescription: "Not configurable.",
    options: null,
    optionExamples: [true],
    type: "typescript",
    typescriptOnly: false,
    requiresTypeInfo: true
  };
  Rule.FAILURE_STRING = "functions that return promises must be async";
  return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
function walk(ctx, tc) {
  return ts.forEachChild(ctx.sourceFile, function cb(node) {
    switch (node.kind) {
      case ts.SyntaxKind.MethodDeclaration:
      case ts.SyntaxKind.FunctionDeclaration:
        if (node.body === undefined) {
          break;
        }
      case ts.SyntaxKind.FunctionExpression:
      case ts.SyntaxKind.ArrowFunction:
        if (!tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.AsyncKeyword) && returnsPromise(node, tc)) {
          ctx.addFailure(node.getStart(ctx.sourceFile), node.body.pos, Rule.FAILURE_STRING);
        }
    }
    return ts.forEachChild(node, cb);
  });
}
function returnsPromise(node, tc) {
  var type = tc.getReturnTypeOfSignature(tc.getTypeAtLocation(node).getCallSignatures()[0]);
  return type.symbol !== undefined && type.symbol.name === "Promise";
}
var _a;
