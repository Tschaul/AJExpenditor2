/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var OPTION_IGNORE_STATIC = "ignore-static";
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.applyWithProgram = function(sourceFile, program) {
    return this.applyWithFunction(sourceFile, function(ctx) {
      return walk(ctx, program.getTypeChecker());
    }, {ignoreStatic: this.ruleArguments.indexOf(OPTION_IGNORE_STATIC) !== -1});
  };
  Rule.metadata = {
    ruleName: "no-unbound-method",
    description: "Warns when a method is used as outside of a method call.",
    optionsDescription: "You may optionally pass \"" + OPTION_IGNORE_STATIC + "\" to ignore static methods.",
    options: {
      type: "string",
      enum: [OPTION_IGNORE_STATIC]
    },
    optionExamples: [true, [true, OPTION_IGNORE_STATIC]],
    type: "functionality",
    typescriptOnly: true,
    requiresTypeInfo: true
  };
  Rule.FAILURE_STRING = "Avoid referencing unbound methods which may cause unintentional scoping of 'this'.";
  return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
function walk(ctx, tc) {
  return ts.forEachChild(ctx.sourceFile, function cb(node) {
    if (tsutils_1.isPropertyAccessExpression(node) && !isSafeUse(node)) {
      var symbol = tc.getSymbolAtLocation(node);
      var declaration = symbol === undefined ? undefined : symbol.valueDeclaration;
      if (declaration !== undefined && isMethod(declaration, ctx.options.ignoreStatic)) {
        ctx.addFailureAtNode(node, Rule.FAILURE_STRING);
      }
    }
    return ts.forEachChild(node, cb);
  });
}
function isMethod(node, ignoreStatic) {
  switch (node.kind) {
    case ts.SyntaxKind.MethodDeclaration:
    case ts.SyntaxKind.MethodSignature:
      return !(ignoreStatic && tsutils_1.hasModifier(node.modifiers, ts.SyntaxKind.StaticKeyword));
    default:
      return false;
  }
}
function isSafeUse(node) {
  var parent = node.parent;
  switch (parent.kind) {
    case ts.SyntaxKind.CallExpression:
      return parent.expression === node;
    case ts.SyntaxKind.TaggedTemplateExpression:
      return parent.tag === node;
    case ts.SyntaxKind.PropertyAccessExpression:
      return true;
    case ts.SyntaxKind.BinaryExpression:
      return parent.operatorToken.kind !== ts.SyntaxKind.BarBarToken;
    case ts.SyntaxKind.NonNullExpression:
    case ts.SyntaxKind.AsExpression:
    case ts.SyntaxKind.TypeAssertionExpression:
    case ts.SyntaxKind.ParenthesizedExpression:
      return isSafeUse(parent);
    case ts.SyntaxKind.ConditionalExpression:
      return parent.condition === node;
    case ts.SyntaxKind.IfStatement:
    case ts.SyntaxKind.WhileStatement:
    case ts.SyntaxKind.DoStatement:
    case ts.SyntaxKind.ForStatement:
      return true;
    default:
      return false;
  }
}
