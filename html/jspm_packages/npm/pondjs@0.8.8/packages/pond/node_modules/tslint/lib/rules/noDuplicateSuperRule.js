/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk);
  };
  Rule.metadata = {
    ruleName: "no-duplicate-super",
    description: "Warns if 'super()' appears twice in a constructor.",
    rationale: "The second call to 'super()' will fail at runtime.",
    optionsDescription: "Not configurable.",
    options: null,
    optionExamples: [true],
    type: "functionality",
    typescriptOnly: false
  };
  Rule.FAILURE_STRING_DUPLICATE = "Multiple calls to 'super()' found. It must be called only once.";
  Rule.FAILURE_STRING_LOOP = "'super()' called in a loop. It must be called only once.";
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  return ts.forEachChild(ctx.sourceFile, function cb(node) {
    if (tsutils_1.isConstructorDeclaration(node) && node.body !== undefined) {
      getSuperForNode(node.body);
    }
    return ts.forEachChild(node, cb);
  });
  function getSuperForNode(node) {
    if (Lint.isLoop(node)) {
      var bodySuper = combineSequentialChildren(node);
      if (typeof bodySuper === "number") {
        return 0;
      }
      if (!bodySuper.break) {
        ctx.addFailureAtNode(bodySuper.node, Rule.FAILURE_STRING_LOOP);
      }
      return tslib_1.__assign({}, bodySuper, {break: false});
    }
    switch (node.kind) {
      case ts.SyntaxKind.ReturnStatement:
      case ts.SyntaxKind.ThrowStatement:
        return 1;
      case ts.SyntaxKind.BreakStatement:
        return 2;
      case ts.SyntaxKind.ClassDeclaration:
      case ts.SyntaxKind.ClassExpression:
        return 0;
      case ts.SyntaxKind.SuperKeyword:
        return node.parent.kind === ts.SyntaxKind.CallExpression && node.parent.expression === node ? {
          node: node.parent,
          break: false
        } : 0;
      case ts.SyntaxKind.IfStatement:
        {
          var _a = node,
              thenStatement = _a.thenStatement,
              elseStatement = _a.elseStatement;
          return worse(getSuperForNode(thenStatement), elseStatement !== undefined ? getSuperForNode(elseStatement) : 0);
        }
      case ts.SyntaxKind.SwitchStatement:
        return getSuperForSwitch(node);
      default:
        return combineSequentialChildren(node);
    }
  }
  function getSuperForSwitch(node) {
    var foundSingle;
    var fallthroughSingle;
    for (var _i = 0,
        _a = node.caseBlock.clauses; _i < _a.length; _i++) {
      var clause = _a[_i];
      var clauseSuper = combineSequentialChildren(clause);
      switch (clauseSuper) {
        case 0:
          break;
        case 2:
          fallthroughSingle = undefined;
          break;
        case 1:
          return 0;
        default:
          if (fallthroughSingle !== undefined) {
            addDuplicateFailure(fallthroughSingle, clauseSuper.node);
          }
          if (!clauseSuper.break) {
            fallthroughSingle = clauseSuper.node;
          }
          foundSingle = clauseSuper.node;
      }
    }
    return foundSingle !== undefined ? {
      node: foundSingle,
      break: false
    } : 0;
  }
  function combineSequentialChildren(node) {
    var seenSingle;
    var res = ts.forEachChild(node, function(child) {
      var childSuper = getSuperForNode(child);
      switch (childSuper) {
        case 0:
          return undefined;
        case 2:
          if (seenSingle !== undefined) {
            return tslib_1.__assign({}, seenSingle, {break: true});
          }
          return childSuper;
        case 1:
          return childSuper;
        default:
          if (seenSingle !== undefined && !seenSingle.break) {
            addDuplicateFailure(seenSingle.node, childSuper.node);
          }
          seenSingle = childSuper;
          return undefined;
      }
    });
    return res !== undefined ? res : seenSingle !== undefined ? seenSingle : 0;
  }
  function addDuplicateFailure(a, b) {
    ctx.addFailure(a.getStart(), b.end, Rule.FAILURE_STRING_DUPLICATE);
  }
}
function worse(a, b) {
  return typeof a === "number" ? typeof b === "number" ? (a < b ? b : a) : b : typeof b === "number" ? a : a.break ? b : a;
}
