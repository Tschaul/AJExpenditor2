/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.FAILURE_STRING_FACTORY = function(type, sigSuggestion) {
    return type + " has only a call signature \u2014 use `" + sigSuggestion + "` instead.";
  };
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk);
  };
  Rule.metadata = {
    ruleName: "callable-types",
    description: "An interface or literal type with just a call signature can be written as a function type.",
    rationale: "style",
    optionsDescription: "Not configurable.",
    options: null,
    type: "style",
    typescriptOnly: true,
    hasFix: true
  };
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  return ts.forEachChild(ctx.sourceFile, function cb(node) {
    if ((tsutils_1.isInterfaceDeclaration(node) && noSupertype(node) || tsutils_1.isTypeLiteralNode(node)) && node.members.length === 1) {
      var member = node.members[0];
      if (tsutils_1.isCallSignatureDeclaration(member) && member.type !== undefined) {
        var suggestion = renderSuggestion(member, node, ctx.sourceFile);
        ctx.addFailureAtNode(member, Rule.FAILURE_STRING_FACTORY(node.kind === ts.SyntaxKind.TypeLiteral ? "Type literal" : "Interface", suggestion), Lint.Replacement.replaceNode(node, suggestion));
      }
    }
    return ts.forEachChild(node, cb);
  });
}
function noSupertype(node) {
  if (node.heritageClauses === undefined) {
    return true;
  }
  if (node.heritageClauses.length !== 1) {
    return false;
  }
  var expr = node.heritageClauses[0].types[0].expression;
  return tsutils_1.isIdentifier(expr) && expr.text === "Function";
}
function renderSuggestion(call, parent, sourceFile) {
  var start = call.getStart(sourceFile);
  var colonPos = call.type.pos - 1 - start;
  var text = sourceFile.text.substring(start, call.end);
  var suggestion = text.substr(0, colonPos) + " =>" + text.substr(colonPos + 1);
  if (parent.kind === ts.SyntaxKind.InterfaceDeclaration) {
    if (parent.typeParameters !== undefined) {
      return "type" + sourceFile.text.substring(parent.name.pos, parent.typeParameters.end + 1) + " = " + suggestion;
    } else {
      return "type " + parent.name.text + " = " + suggestion;
    }
  }
  return suggestion.endsWith(";") ? suggestion.slice(0, -1) : suggestion;
}
