/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var utils = require('../../tsutils/index');
var ts = require('../../typescript/lib/typescript');
exports.ENABLE_DISABLE_REGEX = /^\s*tslint:(enable|disable)(?:-(line|next-line))?(:|\s|$)/;
function removeDisabledFailures(sourceFile, failures) {
  if (failures.length === 0) {
    return failures;
  }
  var failingRules = new Set(failures.map(function(f) {
    return f.getRuleName();
  }));
  var map = getDisableMap(sourceFile, failingRules);
  return failures.filter(function(failure) {
    var disabledIntervals = map.get(failure.getRuleName());
    return disabledIntervals === undefined || !disabledIntervals.some(function(_a) {
      var pos = _a.pos,
          end = _a.end;
      var failPos = failure.getStartPosition().getPosition();
      var failEnd = failure.getEndPosition().getPosition();
      return failEnd >= pos && (end === -1 || failPos <= end);
    });
  });
}
exports.removeDisabledFailures = removeDisabledFailures;
function getDisableMap(sourceFile, failingRules) {
  var map = new Map();
  utils.forEachComment(sourceFile, function(fullText, comment) {
    var commentText = comment.kind === ts.SyntaxKind.SingleLineCommentTrivia ? fullText.substring(comment.pos + 2, comment.end) : fullText.substring(comment.pos + 2, comment.end - 2);
    var parsed = parseComment(commentText);
    if (parsed !== undefined) {
      var rulesList = parsed.rulesList,
          isEnabled = parsed.isEnabled,
          modifier = parsed.modifier;
      var switchRange = getSwitchRange(modifier, comment, sourceFile);
      if (switchRange !== undefined) {
        var rulesToSwitch = rulesList === "all" ? Array.from(failingRules) : rulesList.filter(function(r) {
          return failingRules.has(r);
        });
        for (var _i = 0,
            rulesToSwitch_1 = rulesToSwitch; _i < rulesToSwitch_1.length; _i++) {
          var ruleToSwitch = rulesToSwitch_1[_i];
          switchRuleState(ruleToSwitch, isEnabled, switchRange.pos, switchRange.end);
        }
      }
    }
  });
  return map;
  function switchRuleState(ruleName, isEnable, start, end) {
    var disableRanges = map.get(ruleName);
    if (isEnable) {
      if (disableRanges !== undefined) {
        var lastDisable = disableRanges[disableRanges.length - 1];
        if (lastDisable.end === -1) {
          lastDisable.end = start;
          if (end !== -1) {
            disableRanges.push({
              pos: end,
              end: -1
            });
          }
        }
      }
    } else {
      if (disableRanges === undefined) {
        map.set(ruleName, [{
          pos: start,
          end: end
        }]);
      } else if (disableRanges[disableRanges.length - 1].end !== -1) {
        disableRanges.push({
          pos: start,
          end: end
        });
      }
    }
  }
}
function getSwitchRange(modifier, range, sourceFile) {
  var lineStarts = sourceFile.getLineStarts();
  switch (modifier) {
    case "line":
      return {
        pos: getStartOfLinePosition(range.pos),
        end: getStartOfLinePosition(range.end, 1)
      };
    case "next-line":
      var pos = getStartOfLinePosition(range.end, 1);
      if (pos === -1) {
        return undefined;
      }
      return {
        pos: pos,
        end: getStartOfLinePosition(range.end, 2)
      };
    default:
      return {
        pos: range.pos,
        end: -1
      };
  }
  function getStartOfLinePosition(position, lineOffset) {
    if (lineOffset === void 0) {
      lineOffset = 0;
    }
    var line = ts.getLineAndCharacterOfPosition(sourceFile, position).line + lineOffset;
    return line >= lineStarts.length ? -1 : lineStarts[line];
  }
}
function parseComment(commentText) {
  var match = exports.ENABLE_DISABLE_REGEX.exec(commentText);
  if (match === null) {
    return undefined;
  }
  var rulesList = splitOnSpaces(commentText.substr(match[0].length));
  if (rulesList.length === 0 && match[3] === ":") {
    return undefined;
  }
  if (rulesList.length === 0 || rulesList.indexOf("all") !== -1) {
    rulesList = "all";
  }
  return {
    rulesList: rulesList,
    isEnabled: match[1] === "enable",
    modifier: match[2]
  };
}
function splitOnSpaces(str) {
  return str.split(/\s+/).filter(function(s) {
    return s !== "";
  });
}
