/* */ 
(function(Buffer) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  var tslib_1 = require('../../../tslib/tslib');
  var fs = require('fs');
  var Lint = require('../index');
  var utils_1 = require('../utils');
  var Rule = (function(_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.FAILURE_STRING = function(actual) {
      return "This file is encoded as " + showEncoding(actual) + " instead of UTF-8.";
    };
    Rule.prototype.apply = function(sourceFile) {
      return this.applyWithFunction(sourceFile, walk);
    };
    Rule.metadata = {
      ruleName: "encoding",
      description: "Enforces UTF-8 file encoding.",
      optionsDescription: "Not configurable.",
      options: null,
      optionExamples: ["true"],
      type: "style",
      typescriptOnly: false
    };
    return Rule;
  }(Lint.Rules.AbstractRule));
  exports.Rule = Rule;
  function walk(ctx) {
    var encoding = detectEncoding(ctx.sourceFile.fileName);
    if (encoding !== "utf8") {
      ctx.addFailure(0, 1, Rule.FAILURE_STRING(encoding));
    }
  }
  function showEncoding(encoding) {
    switch (encoding) {
      case "utf8":
        return "UTF-8";
      case "utf8-bom":
        return "UTF-8 with byte-order marker (BOM)";
      case "utf16le":
        return "UTF-16 (little-endian)";
      case "utf16be":
        return "UTF-16 (big-endian)";
    }
  }
  function detectEncoding(fileName) {
    var fd = fs.openSync(fileName, "r");
    var maxBytesRead = 3;
    var buffer = new Buffer(maxBytesRead);
    var bytesRead = fs.readSync(fd, buffer, 0, maxBytesRead, 0);
    fs.closeSync(fd);
    return utils_1.detectBufferEncoding(buffer, bytesRead);
  }
})(require('buffer').Buffer);
