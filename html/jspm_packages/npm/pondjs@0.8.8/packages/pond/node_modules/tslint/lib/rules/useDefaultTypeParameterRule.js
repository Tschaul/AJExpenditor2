/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var utils_1 = require('../utils');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.applyWithProgram = function(sourceFile, program) {
    return this.applyWithFunction(sourceFile, function(ctx) {
      return walk(ctx, program.getTypeChecker());
    });
  };
  Rule.metadata = {
    ruleName: "use-default-type-parameter",
    description: "Warns if an explicitly specified type argument is the default for that type parameter.",
    optionsDescription: "Not configurable.",
    options: null,
    optionExamples: ["true"],
    type: "functionality",
    typescriptOnly: true,
    requiresTypeInfo: true
  };
  Rule.FAILURE_STRING = "This is the default value for this type parameter, so it can be omitted.";
  return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
function walk(ctx, checker) {
  return ts.forEachChild(ctx.sourceFile, function cb(node) {
    var argsAndParams = getArgsAndParameters(node, checker);
    if (argsAndParams !== undefined) {
      checkArgsAndParameters(node, argsAndParams);
    }
    return ts.forEachChild(node, cb);
  });
  function checkArgsAndParameters(node, _a) {
    var typeArguments = _a.typeArguments,
        typeParameters = _a.typeParameters;
    var i = typeArguments.length - 1;
    var arg = typeArguments[i];
    var param = typeParameters[i];
    if (param.default !== undefined && param.default.getText() === arg.getText()) {
      ctx.addFailureAtNode(arg, Rule.FAILURE_STRING, createFix());
    }
    function createFix() {
      if (i === 0) {
        var lt = Lint.childOfKind(node, ts.SyntaxKind.LessThanToken);
        var gt = Lint.childOfKind(node, ts.SyntaxKind.GreaterThanToken);
        return Lint.Replacement.deleteFromTo(lt.getStart(), gt.getEnd());
      } else {
        return Lint.Replacement.deleteFromTo(typeArguments[i - 1].getEnd(), arg.getEnd());
      }
    }
  }
}
function getArgsAndParameters(node, checker) {
  switch (node.kind) {
    case ts.SyntaxKind.CallExpression:
    case ts.SyntaxKind.NewExpression:
    case ts.SyntaxKind.TypeReference:
    case ts.SyntaxKind.ExpressionWithTypeArguments:
      var decl = node;
      var typeArguments = decl.typeArguments;
      if (typeArguments === undefined) {
        return undefined;
      }
      var typeParameters = decl.kind === ts.SyntaxKind.TypeReference ? typeParamsFromType(decl.typeName, checker) : decl.kind === ts.SyntaxKind.ExpressionWithTypeArguments ? typeParamsFromType(decl.expression, checker) : typeParamsFromCall(node, checker);
      return typeParameters === undefined ? undefined : {
        typeArguments: typeArguments,
        typeParameters: typeParameters
      };
    default:
      return undefined;
  }
}
function typeParamsFromCall(node, checker) {
  var sig = checker.getResolvedSignature(node);
  var sigDecl = sig === undefined ? undefined : sig.getDeclaration();
  if (sigDecl === undefined) {
    return node.kind === ts.SyntaxKind.NewExpression ? typeParamsFromType(node.expression, checker) : undefined;
  }
  return sigDecl.typeParameters === undefined ? undefined : sigDecl.typeParameters;
}
function typeParamsFromType(type, checker) {
  var sym = getAliasedSymbol(checker.getSymbolAtLocation(type), checker);
  if (sym === undefined || sym.declarations === undefined) {
    return undefined;
  }
  return utils_1.find(sym.declarations, function(decl) {
    return tsutils_1.isClassLikeDeclaration(decl) || tsutils_1.isTypeAliasDeclaration(decl) || tsutils_1.isInterfaceDeclaration(decl) ? decl.typeParameters : undefined;
  });
}
function getAliasedSymbol(symbol, checker) {
  if (symbol === undefined) {
    return undefined;
  }
  return Lint.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? checker.getAliasedSymbol(symbol) : symbol;
}
