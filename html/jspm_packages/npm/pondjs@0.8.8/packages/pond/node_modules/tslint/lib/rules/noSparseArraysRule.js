/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var utils = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk);
  };
  Rule.metadata = {
    ruleName: "no-sparse-arrays",
    description: "Forbids array literals to contain missing elements.",
    rationale: "Missing elements are probably an accidentally duplicated comma.",
    optionsDescription: "Not configurable.",
    options: null,
    optionExamples: [true],
    type: "functionality",
    typescriptOnly: false
  };
  Rule.FAILURE_STRING = "Array has a missing element.";
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  return ts.forEachChild(ctx.sourceFile, function cb(node) {
    if (!utils.isArrayLiteralExpression(node)) {
      if (utils.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        traverseExpressionsInLHS(node.left, cb);
        return cb(node.right);
      } else {
        return ts.forEachChild(node, cb);
      }
    }
    for (var _i = 0,
        _a = node.elements; _i < _a.length; _i++) {
      var element = _a[_i];
      if (utils.isOmittedExpression(element)) {
        ctx.addFailureAt(element.pos, 1, Rule.FAILURE_STRING);
      } else {
        ts.forEachChild(element, cb);
      }
    }
  });
}
function traverseExpressionsInLHS(node, cb) {
  switch (node.kind) {
    case ts.SyntaxKind.ParenthesizedExpression:
      traverseExpressionsInLHS(node.expression, cb);
      break;
    case ts.SyntaxKind.ArrayLiteralExpression:
      for (var _i = 0,
          _a = node.elements; _i < _a.length; _i++) {
        var e = _a[_i];
        traverseExpressionsInLHS(e, cb);
      }
      break;
    case ts.SyntaxKind.ObjectLiteralExpression:
      for (var _b = 0,
          _c = node.properties; _b < _c.length; _b++) {
        var o = _c[_b];
        traverseExpressionsInLHS(o, cb);
      }
      break;
    case ts.SyntaxKind.BinaryExpression:
      {
        var _d = node,
            left = _d.left,
            operatorToken = _d.operatorToken,
            right = _d.right;
        if (operatorToken.kind === ts.SyntaxKind.EqualsToken) {
          traverseExpressionsInLHS(left, cb);
          cb(right);
        }
      }
  }
}
