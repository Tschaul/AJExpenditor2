/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.applyWithProgram = function(sourceFile, program) {
    return this.applyWithFunction(sourceFile, function(ctx) {
      return walk(ctx, program.getTypeChecker());
    });
  };
  Rule.metadata = {
    ruleName: "no-unsafe-any",
    description: (_a = ["\n            Warns when using an expression of type 'any' in a dynamic way.\n            Uses are only allowed if they would work for `{} | null | undefined`.\n            Type casts and tests are allowed.\n            Expressions that work on all values (such as `\"\" + x`) are allowed."], _a.raw = ["\n            Warns when using an expression of type 'any' in a dynamic way.\n            Uses are only allowed if they would work for \\`{} | null | undefined\\`.\n            Type casts and tests are allowed.\n            Expressions that work on all values (such as \\`\"\" + x\\`) are allowed."], Lint.Utils.dedent(_a)),
    optionsDescription: "Not configurable.",
    options: null,
    optionExamples: [true],
    type: "functionality",
    typescriptOnly: true,
    requiresTypeInfo: true
  };
  Rule.FAILURE_STRING = "Unsafe use of expression of type 'any'.";
  return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
function walk(ctx, checker) {
  if (ctx.sourceFile.isDeclarationFile) {
    return;
  }
  return ts.forEachChild(ctx.sourceFile, cb);
  function cb(node, anyOk) {
    switch (node.kind) {
      case ts.SyntaxKind.ParenthesizedExpression:
        return cb(node.expression, anyOk);
      case ts.SyntaxKind.Parameter:
        {
          var _a = node,
              type = _a.type,
              initializer = _a.initializer;
          if (initializer !== undefined) {
            return cb(initializer, type !== undefined && type.kind === ts.SyntaxKind.AnyKeyword);
          }
          return;
        }
      case ts.SyntaxKind.LabeledStatement:
        return cb(node.statement);
      case ts.SyntaxKind.BreakStatement:
      case ts.SyntaxKind.ContinueStatement:
      case ts.SyntaxKind.InterfaceDeclaration:
      case ts.SyntaxKind.TypeAliasDeclaration:
      case ts.SyntaxKind.QualifiedName:
      case ts.SyntaxKind.TypePredicate:
      case ts.SyntaxKind.TypeOfExpression:
      case ts.SyntaxKind.ImportEqualsDeclaration:
      case ts.SyntaxKind.ImportDeclaration:
      case ts.SyntaxKind.ExportDeclaration:
      case ts.SyntaxKind.NumericLiteral:
      case ts.SyntaxKind.StringLiteral:
        return;
      case ts.SyntaxKind.DeleteExpression:
      case ts.SyntaxKind.ExpressionStatement:
      case ts.SyntaxKind.TypeAssertionExpression:
      case ts.SyntaxKind.AsExpression:
      case ts.SyntaxKind.TemplateSpan:
      case ts.SyntaxKind.ThrowStatement:
        {
          var expression = node.expression;
          return cb(expression, true);
        }
      case ts.SyntaxKind.PropertyAssignment:
        {
          var _b = node,
              name = _b.name,
              initializer = _b.initializer;
          cb(name, true);
          cb(initializer);
          return;
        }
      case ts.SyntaxKind.PropertyDeclaration:
        {
          var _c = node,
              name = _c.name,
              initializer = _c.initializer;
          if (initializer !== undefined) {
            return cb(initializer, isNodeAny(name, checker));
          }
          return;
        }
      case ts.SyntaxKind.TaggedTemplateExpression:
        {
          var _d = node,
              tag = _d.tag,
              template = _d.template;
          cb(tag);
          if (template.kind === ts.SyntaxKind.TemplateExpression) {
            for (var _i = 0,
                _e = template.templateSpans; _i < _e.length; _i++) {
              var expression = _e[_i].expression;
              checkContextual(expression);
            }
          }
          check();
          return;
        }
      case ts.SyntaxKind.CallExpression:
      case ts.SyntaxKind.NewExpression:
        {
          var _f = node,
              expression = _f.expression,
              args = _f.arguments;
          cb(expression);
          if (args !== undefined) {
            for (var _g = 0,
                args_1 = args; _g < args_1.length; _g++) {
              var arg = args_1[_g];
              checkContextual(arg);
            }
          }
          check();
          return;
        }
      case ts.SyntaxKind.PropertyAccessExpression:
        cb(node.expression);
        check();
        return;
      case ts.SyntaxKind.VariableDeclaration:
        return checkVariableDeclaration(node);
      case ts.SyntaxKind.BinaryExpression:
        return checkBinaryExpression(node);
      case ts.SyntaxKind.ReturnStatement:
        {
          var expression = node.expression;
          if (expression !== undefined) {
            return checkContextual(expression);
          }
          return;
        }
      case ts.SyntaxKind.SwitchStatement:
        {
          var _h = node,
              expression = _h.expression,
              clauses = _h.caseBlock.clauses;
          cb(expression, true);
          for (var _j = 0,
              clauses_1 = clauses; _j < clauses_1.length; _j++) {
            var clause = clauses_1[_j];
            if (clause.kind === ts.SyntaxKind.CaseClause) {
              cb(clause.expression, true);
            }
            for (var _k = 0,
                _l = clause.statements; _k < _l.length; _k++) {
              var statement = _l[_k];
              cb(statement);
            }
          }
          break;
        }
      case ts.SyntaxKind.ModuleDeclaration:
        {
          var body = node.body;
          if (body !== undefined) {
            cb(body);
          }
          return;
        }
      default:
        if (!(tsutils_1.isExpression(node) && check())) {
          return ts.forEachChild(node, cb);
        }
        return;
    }
    function check() {
      var isUnsafe = !anyOk && isNodeAny(node, checker);
      if (isUnsafe) {
        ctx.addFailureAtNode(node, Rule.FAILURE_STRING);
      }
      return isUnsafe;
    }
  }
  function checkContextual(arg) {
    return cb(arg, isAny(checker.getContextualType(arg)));
  }
  function checkVariableDeclaration(_a) {
    var type = _a.type,
        initializer = _a.initializer;
    if (initializer !== undefined) {
      return cb(initializer, type === undefined || type.kind === ts.SyntaxKind.AnyKeyword);
    }
    return;
  }
  function checkBinaryExpression(node) {
    var _a = node,
        left = _a.left,
        right = _a.right,
        operatorToken = _a.operatorToken;
    if (Lint.getEqualsKind(operatorToken) !== undefined) {
      return;
    }
    switch (operatorToken.kind) {
      case ts.SyntaxKind.InstanceOfKeyword:
        return cb(right);
      case ts.SyntaxKind.CommaToken:
        cb(left, true);
        return cb(right, true);
      case ts.SyntaxKind.EqualsToken:
        cb(right, isNodeAny(left, checker));
        return;
      case ts.SyntaxKind.PlusToken:
      case ts.SyntaxKind.PlusEqualsToken:
        var anyOk = isStringLike(left, checker) || (isStringLike(right, checker) && operatorToken.kind === ts.SyntaxKind.PlusToken);
        cb(left, anyOk);
        return cb(right, anyOk);
      default:
        cb(left);
        return cb(right);
    }
  }
}
function isNodeAny(node, checker) {
  return isAny(checker.getTypeAtLocation(node));
}
function isStringLike(expr, checker) {
  return Lint.isTypeFlagSet(checker.getTypeAtLocation(expr), ts.TypeFlags.StringLike);
}
function isAny(type) {
  return type !== undefined && Lint.isTypeFlagSet(type, ts.TypeFlags.Any);
}
var _a;
