/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var utils = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var utils_1 = require('../utils');
var OPTION_ALWAYS = "always-prefix";
var OPTION_NEVER = "never-prefix";
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk, {never: this.ruleArguments.indexOf(OPTION_NEVER) !== -1});
  };
  Rule.metadata = {
    ruleName: "interface-name",
    description: "Requires interface names to begin with a capital 'I'",
    rationale: "Makes it easy to differentiate interfaces from regular classes at a glance.",
    optionsDescription: (_a = ["\n            One of the following two options must be provided:\n\n            * `\"", "\"` requires interface names to start with an \"I\"\n            * `\"", "\"` requires interface names to not have an \"I\" prefix"], _a.raw = ["\n            One of the following two options must be provided:\n\n            * \\`\"", "\"\\` requires interface names to start with an \"I\"\n            * \\`\"", "\"\\` requires interface names to not have an \"I\" prefix"], Lint.Utils.dedent(_a, OPTION_ALWAYS, OPTION_NEVER)),
    options: {
      type: "string",
      enum: [OPTION_ALWAYS, OPTION_NEVER]
    },
    optionExamples: [[true, OPTION_ALWAYS], [true, OPTION_NEVER]],
    type: "style",
    typescriptOnly: true
  };
  Rule.FAILURE_STRING = "interface name must start with a capitalized I";
  Rule.FAILURE_STRING_NO_PREFIX = 'interface name must not have an "I" prefix';
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  var never = ctx.options.never;
  return ts.forEachChild(ctx.sourceFile, function cb(node) {
    if (utils.isInterfaceDeclaration(node)) {
      var name = node.name;
      if (never && hasPrefixI(name.text)) {
        ctx.addFailureAtNode(name, Rule.FAILURE_STRING_NO_PREFIX);
      } else if (!never && name.text[0] !== "I") {
        ctx.addFailureAtNode(name, Rule.FAILURE_STRING);
      }
    } else {
      return ts.forEachChild(node, cb);
    }
  });
}
function hasPrefixI(name) {
  return name.length >= 2 && name[0] === "I" && utils_1.isUpperCase(name[1]) && !name.startsWith("IDB");
}
var _a;
