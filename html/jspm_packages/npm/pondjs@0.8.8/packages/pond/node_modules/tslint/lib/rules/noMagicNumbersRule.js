/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var utils_1 = require('../language/utils');
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    var allowedNumbers = this.ruleArguments.length > 0 ? this.ruleArguments : Rule.DEFAULT_ALLOWED;
    return this.applyWithWalker(new NoMagicNumbersWalker(sourceFile, this.ruleName, new Set(allowedNumbers.map(String))));
  };
  Rule.metadata = {
    ruleName: "no-magic-numbers",
    description: (_a = ["\n            Disallows the use constant number values outside of variable assignments.\n            When no list of allowed values is specified, -1, 0 and 1 are allowed by default."], _a.raw = ["\n            Disallows the use constant number values outside of variable assignments.\n            When no list of allowed values is specified, -1, 0 and 1 are allowed by default."], Lint.Utils.dedent(_a)),
    rationale: (_b = ["\n            Magic numbers should be avoided as they often lack documentation, forcing\n            them to be stored in variables gives them implicit documentation."], _b.raw = ["\n            Magic numbers should be avoided as they often lack documentation, forcing\n            them to be stored in variables gives them implicit documentation."], Lint.Utils.dedent(_b)),
    optionsDescription: "A list of allowed numbers.",
    options: {
      type: "array",
      items: {type: "number"},
      minLength: 1
    },
    optionExamples: [true, [true, 1, 2, 3]],
    type: "typescript",
    typescriptOnly: false
  };
  Rule.FAILURE_STRING = "'magic numbers' are not allowed";
  Rule.ALLOWED_NODES = new Set([ts.SyntaxKind.ExportAssignment, ts.SyntaxKind.FirstAssignment, ts.SyntaxKind.LastAssignment, ts.SyntaxKind.PropertyAssignment, ts.SyntaxKind.ShorthandPropertyAssignment, ts.SyntaxKind.VariableDeclaration, ts.SyntaxKind.VariableDeclarationList, ts.SyntaxKind.EnumMember, ts.SyntaxKind.PropertyDeclaration, ts.SyntaxKind.Parameter]);
  Rule.DEFAULT_ALLOWED = [-1, 0, 1];
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var NoMagicNumbersWalker = (function(_super) {
  tslib_1.__extends(NoMagicNumbersWalker, _super);
  function NoMagicNumbersWalker() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  NoMagicNumbersWalker.prototype.walk = function(sourceFile) {
    var _this = this;
    var cb = function(node) {
      if (node.kind === ts.SyntaxKind.NumericLiteral) {
        return _this.checkNumericLiteral(node, node.text);
      }
      if (utils_1.isNegativeNumberLiteral(node)) {
        return _this.checkNumericLiteral(node, "-" + node.operand.text);
      }
      return ts.forEachChild(node, cb);
    };
    return ts.forEachChild(sourceFile, cb);
  };
  NoMagicNumbersWalker.prototype.checkNumericLiteral = function(node, num) {
    if (!Rule.ALLOWED_NODES.has(node.parent.kind) && !this.options.has(num)) {
      this.addFailureAtNode(node, Rule.FAILURE_STRING);
    }
  };
  return NoMagicNumbersWalker;
}(Lint.AbstractWalker));
var _a,
    _b;
