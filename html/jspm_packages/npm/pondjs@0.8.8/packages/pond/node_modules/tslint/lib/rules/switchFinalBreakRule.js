/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var tsutils_1 = require('../../../tsutils/index');
var ts = require('../../../typescript/lib/typescript');
var Lint = require('../index');
var OPTION_ALWAYS = "always";
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    return this.applyWithFunction(sourceFile, walk, {always: this.ruleArguments.indexOf(OPTION_ALWAYS) !== -1});
  };
  Rule.metadata = {
    ruleName: "switch-final-break",
    description: "Checks whether the final clause of a switch statement ends in \`break;\`.",
    optionsDescription: (_a = ["\n            If no options are passed, a final 'break;' is forbidden.\n            If the \"always\" option is passed this will require a 'break;' to always be present\n            unless control flow is escaped in some other way."], _a.raw = ["\n            If no options are passed, a final 'break;' is forbidden.\n            If the \"always\" option is passed this will require a 'break;' to always be present\n            unless control flow is escaped in some other way."], Lint.Utils.dedent(_a)),
    options: {
      type: "string",
      enum: [OPTION_ALWAYS]
    },
    optionExamples: [true, [true, OPTION_ALWAYS]],
    type: "style",
    typescriptOnly: false
  };
  Rule.FAILURE_STRING_ALWAYS = "Final clause in 'switch' statement should end with 'break;'.";
  Rule.FAILURE_STRING_NEVER = "Final clause in 'switch' statement should not end with 'break;'.";
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  var sourceFile = ctx.sourceFile,
      always = ctx.options.always;
  ts.forEachChild(sourceFile, function cb(node) {
    if (tsutils_1.isSwitchStatement(node)) {
      check(node);
    }
    ts.forEachChild(node, cb);
  });
  function check(node) {
    var clause = last(node.caseBlock.clauses);
    if (clause === undefined) {
      return;
    }
    if (always) {
      if (!tsutils_1.endsControlFlow(clause)) {
        ctx.addFailureAtNode(clause.getChildAt(0), Rule.FAILURE_STRING_ALWAYS);
      }
      return;
    }
    if (clause.statements.length === 0) {
      return;
    }
    var block = clause.statements[0];
    var statements = clause.statements.length === 1 && tsutils_1.isBlock(block) ? block.statements : clause.statements;
    var lastStatement = last(statements);
    if (lastStatement !== undefined && tsutils_1.isBreakStatement(lastStatement)) {
      if (lastStatement.label !== undefined) {
        var parent = node.parent;
        if (!tsutils_1.isLabeledStatement(parent) || parent.label === lastStatement.label) {
          return;
        }
      }
      ctx.addFailureAtNode(lastStatement, Rule.FAILURE_STRING_NEVER);
    }
  }
}
function last(arr) {
  return arr[arr.length - 1];
}
var _a;
