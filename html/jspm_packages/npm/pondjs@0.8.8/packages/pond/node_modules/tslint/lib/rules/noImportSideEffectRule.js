/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../../tslib/tslib');
var utils = require('../../../tsutils/index');
var Lint = require('../index');
var OPTION_IGNORE_MODULE = "ignore-module";
var Rule = (function(_super) {
  tslib_1.__extends(Rule, _super);
  function Rule() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rule.prototype.apply = function(sourceFile) {
    var patternConfig = this.ruleArguments[this.ruleArguments.length - 1];
    var ignorePattern = patternConfig === undefined ? undefined : new RegExp(patternConfig[OPTION_IGNORE_MODULE]);
    return this.applyWithFunction(sourceFile, walk, ignorePattern);
  };
  Rule.metadata = {
    description: "Avoid import statements with side-effect.",
    optionExamples: [true, [true, (_a = {}, _a[OPTION_IGNORE_MODULE] = "(\\.html|\\.css)$", _a)]],
    options: {
      items: {
        properties: {"ignore-module": {type: "string"}},
        type: "object"
      },
      maxLength: 1,
      minLength: 0,
      type: "array"
    },
    optionsDescription: (_b = ["\n            One argument may be optionally provided:\n\n            * `", "` allows to specify a regex and ignore modules which it matches."], _b.raw = ["\n            One argument may be optionally provided:\n\n            * \\`", "\\` allows to specify a regex and ignore modules which it matches."], Lint.Utils.dedent(_b, OPTION_IGNORE_MODULE)),
    rationale: "Imports with side effects may have behavior which is hard for static verification.",
    ruleName: "no-import-side-effect",
    type: "typescript",
    typescriptOnly: false
  };
  Rule.FAILURE_STRING = "import with explicit side-effect";
  return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
function walk(ctx) {
  var ignorePattern = ctx.options,
      sourceFile = ctx.sourceFile;
  for (var _i = 0,
      _a = sourceFile.statements; _i < _a.length; _i++) {
    var statement = _a[_i];
    if (!utils.isImportDeclaration(statement)) {
      continue;
    }
    var importClause = statement.importClause,
        moduleSpecifier = statement.moduleSpecifier;
    if (importClause !== undefined || !utils.isStringLiteral(moduleSpecifier)) {
      continue;
    }
    if (ignorePattern === undefined || !ignorePattern.test(moduleSpecifier.text)) {
      ctx.addFailureAtNode(statement, Rule.FAILURE_STRING);
    }
  }
}
var _a,
    _b;
