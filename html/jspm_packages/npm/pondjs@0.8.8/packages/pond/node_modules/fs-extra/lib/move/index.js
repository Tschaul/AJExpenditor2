/* */ 
'use strict';
const u = require('../../../universalify/index').fromCallback;
const fs = require('../../../graceful-fs/graceful-fs');
const ncp = require('../copy/ncp');
const path = require('path');
const remove = require('../remove/index').remove;
const mkdirp = require('../mkdirs/index').mkdirs;
function move(source, dest, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  const shouldMkdirp = ('mkdirp' in options) ? options.mkdirp : true;
  const overwrite = options.overwrite || options.clobber || false;
  if (shouldMkdirp) {
    mkdirs();
  } else {
    doRename();
  }
  function mkdirs() {
    mkdirp(path.dirname(dest), (err) => {
      if (err)
        return callback(err);
      doRename();
    });
  }
  function doRename() {
    if (path.resolve(source) === path.resolve(dest)) {
      fs.access(source, callback);
    } else if (overwrite) {
      fs.rename(source, dest, (err) => {
        if (!err)
          return callback();
        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
          remove(dest, (err) => {
            if (err)
              return callback(err);
            options.overwrite = false;
            move(source, dest, options, callback);
          });
          return;
        }
        if (err.code === 'EPERM') {
          setTimeout(() => {
            remove(dest, (err) => {
              if (err)
                return callback(err);
              options.overwrite = false;
              move(source, dest, options, callback);
            });
          }, 200);
          return;
        }
        if (err.code !== 'EXDEV')
          return callback(err);
        moveAcrossDevice(source, dest, overwrite, callback);
      });
    } else {
      fs.link(source, dest, (err) => {
        if (err) {
          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
            moveAcrossDevice(source, dest, overwrite, callback);
            return;
          }
          callback(err);
          return;
        }
        fs.unlink(source, callback);
      });
    }
  }
}
function moveAcrossDevice(source, dest, overwrite, callback) {
  fs.stat(source, (err, stat) => {
    if (err) {
      callback(err);
      return;
    }
    if (stat.isDirectory()) {
      moveDirAcrossDevice(source, dest, overwrite, callback);
    } else {
      moveFileAcrossDevice(source, dest, overwrite, callback);
    }
  });
}
function moveFileAcrossDevice(source, dest, overwrite, callback) {
  const flags = overwrite ? 'w' : 'wx';
  const ins = fs.createReadStream(source);
  const outs = fs.createWriteStream(dest, {flags});
  ins.on('error', (err) => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    fs.unlink(dest, () => {
      if (err.code === 'EISDIR' || err.code === 'EPERM') {
        moveDirAcrossDevice(source, dest, overwrite, callback);
      } else {
        callback(err);
      }
    });
  });
  outs.on('error', (err) => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    callback(err);
  });
  outs.once('close', onClose);
  ins.pipe(outs);
  function onClose() {
    fs.unlink(source, callback);
  }
}
function moveDirAcrossDevice(source, dest, overwrite, callback) {
  const options = {overwrite: false};
  if (overwrite) {
    remove(dest, (err) => {
      if (err)
        return callback(err);
      startNcp();
    });
  } else {
    startNcp();
  }
  function startNcp() {
    ncp(source, dest, options, (err) => {
      if (err)
        return callback(err);
      remove(source, callback);
    });
  }
}
module.exports = {move: u(move)};
