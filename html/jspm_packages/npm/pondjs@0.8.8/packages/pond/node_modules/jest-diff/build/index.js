/* */ 
'use strict';
var _require$plugins = require('../../pretty-format/build/index').plugins;
const ReactElement = _require$plugins.ReactElement,
    ReactTestComponent = _require$plugins.ReactTestComponent,
    AsymmetricMatcher = _require$plugins.AsymmetricMatcher,
    HTMLElement = _require$plugins.HTMLElement,
    Immutable = _require$plugins.Immutable;
const chalk = require('../../chalk/index');
var _require = require('../../jest-matcher-utils/build/index');
const getType = _require.getType;
const prettyFormat = require('../../pretty-format/build/index');
const diffStrings = require('./diffStrings');
var _require2 = require('./constants');
const NO_DIFF_MESSAGE = _require2.NO_DIFF_MESSAGE,
    SIMILAR_MESSAGE = _require2.SIMILAR_MESSAGE;
const PLUGINS = [ReactTestComponent, ReactElement, AsymmetricMatcher, HTMLElement].concat(Immutable);
const FORMAT_OPTIONS = {plugins: PLUGINS};
const FALLBACK_FORMAT_OPTIONS = {
  callToJSON: false,
  maxDepth: 10,
  plugins: PLUGINS
};
function diff(a, b, options) {
  if (a === b) {
    return NO_DIFF_MESSAGE;
  }
  const aType = getType(a);
  let expectedType = aType;
  let omitDifference = false;
  if (aType === 'object' && typeof a.asymmetricMatch === 'function') {
    if (a.$$typeof !== Symbol.for('jest.asymmetricMatcher')) {
      return null;
    }
    if (typeof a.getExpectedType !== 'function') {
      return null;
    }
    expectedType = a.getExpectedType();
    omitDifference = expectedType === 'string';
  }
  if (expectedType !== getType(b)) {
    return ('  Comparing two different types of values.' + ` Expected ${chalk.green(expectedType)} but ` + `received ${chalk.red(getType(b))}.`);
  }
  if (omitDifference) {
    return null;
  }
  switch (aType) {
    case 'string':
      const multiline = a.match(/[\r\n]/) !== -1 && b.indexOf('\n') !== -1;
      if (multiline) {
        return diffStrings(String(a), String(b), options);
      }
      return null;
    case 'number':
    case 'boolean':
      return null;
    case 'map':
      return compareObjects(sortMap(a), sortMap(b), options);
    case 'set':
      return compareObjects(sortSet(a), sortSet(b), options);
    default:
      return compareObjects(a, b, options);
  }
}
function sortMap(map) {
  return new Map(Array.from(map.entries()).sort());
}
function sortSet(set) {
  return new Set(Array.from(set.values()).sort());
}
function compareObjects(a, b, options) {
  let diffMessage;
  let hasThrown = false;
  try {
    diffMessage = diffStrings(prettyFormat(a, FORMAT_OPTIONS), prettyFormat(b, FORMAT_OPTIONS), options);
  } catch (e) {
    hasThrown = true;
  }
  if (!diffMessage || diffMessage === NO_DIFF_MESSAGE) {
    diffMessage = diffStrings(prettyFormat(a, FALLBACK_FORMAT_OPTIONS), prettyFormat(b, FALLBACK_FORMAT_OPTIONS), options);
    if (diffMessage !== NO_DIFF_MESSAGE && !hasThrown) {
      diffMessage = SIMILAR_MESSAGE + '\n\n' + diffMessage;
    }
  }
  return diffMessage;
}
module.exports = diff;
