/* */ 
"use strict";
const whatwgEncoding = require('../../whatwg-encoding/lib/whatwg-encoding');
module.exports = function sniffHTMLEncoding(buffer, options) {
  let encoding = whatwgEncoding.getBOMEncoding(buffer);
  if (options === undefined) {
    options = {};
  }
  if (encoding === null && options.transportLayerEncodingLabel !== undefined) {
    encoding = whatwgEncoding.labelToName(options.transportLayerEncodingLabel);
  }
  if (encoding === null) {
    encoding = prescanMetaCharset(buffer);
  }
  if (encoding === null && options.defaultEncoding !== undefined) {
    encoding = options.defaultEncoding;
  }
  if (encoding === null) {
    encoding = "windows-1252";
  }
  return encoding;
};
function prescanMetaCharset(buffer) {
  const l = Math.min(buffer.length, 1024);
  for (let i = 0; i < l; i++) {
    let c = buffer[i];
    if (c === 0x3C) {
      let c1 = buffer[i + 1];
      let c2 = buffer[i + 2];
      const c3 = buffer[i + 3];
      const c4 = buffer[i + 4];
      const c5 = buffer[i + 5];
      if (c1 === 0x21 && c2 === 0x2D && c3 === 0x2D) {
        i += 4;
        for (; i < l; i++) {
          c = buffer[i];
          c1 = buffer[i + 1];
          c2 = buffer[i + 2];
          if (c === 0x2D && c1 === 0x2D && c2 === 0x3E) {
            i += 2;
            break;
          }
        }
      } else if ((c1 === 0x4D || c1 === 0x6D) && (c2 === 0x45 || c2 === 0x65) && (c3 === 0x54 || c3 === 0x74) && (c4 === 0x41 || c4 === 0x61) && (isSpaceCharacter(c5) || c5 === 0x2F)) {
        i += 6;
        let gotPragma = false;
        let needPragma = null;
        let charset = null;
        let attrRes;
        do {
          attrRes = getAttribute(buffer, i, l);
          if (attrRes.attr) {
            if (attrRes.attr.name === "http-equiv") {
              gotPragma = attrRes.attr.value === "content-type";
            } else if (attrRes.attr.name === "content" && !charset) {
              charset = extractCharacterEncodingFromMeta(attrRes.attr.value);
              if (charset !== null) {
                needPragma = true;
              }
            } else if (attrRes.attr.name === "charset") {
              charset = whatwgEncoding.labelToName(attrRes.attr.value);
              needPragma = false;
            }
          }
          i = attrRes.i;
        } while (attrRes.attr);
        if (needPragma === null) {
          continue;
        }
        if (needPragma === true && gotPragma === false) {
          continue;
        }
        if (charset === null) {
          continue;
        }
        if (charset === "UTF-16LE" || charset === "UTF-16BE") {
          charset = "UTF-8";
        }
        if (charset === "x-user-defined") {
          charset = "windows-1252";
        }
        return charset;
      } else if ((c1 >= 0x41 && c1 <= 0x5A) || (c1 >= 0x61 && c1 <= 0x7A)) {
        for (i += 2; i < l; i++) {
          c = buffer[i];
          if (isSpaceCharacter(c) || c === 0x3E) {
            break;
          }
        }
        let attrRes;
        do {
          attrRes = getAttribute(buffer, i, l);
          i = attrRes.i;
        } while (attrRes.attr);
      } else if (c1 === 0x21 || c1 === 0x2F || c1 === 0x3F) {
        for (i += 2; i < l; i++) {
          c = buffer[i];
          if (c === 0x3E) {
            break;
          }
        }
      }
    }
  }
  return null;
}
function getAttribute(buffer, i, l) {
  for (; i < l; i++) {
    let c = buffer[i];
    if (isSpaceCharacter(c) || c === 0x2F) {
      continue;
    }
    if (c === 0x3E) {
      i++;
      break;
    }
    let name = "";
    let value = "";
    nameLoop: for (; i < l; i++) {
      c = buffer[i];
      if (c === 0x3D && name !== "") {
        i++;
        break;
      }
      if (isSpaceCharacter(c)) {
        for (i++; i < l; i++) {
          c = buffer[i];
          if (isSpaceCharacter(c)) {
            continue;
          }
          if (c !== 0x3D) {
            return {
              attr: {
                name,
                value
              },
              i
            };
          }
          i++;
          break nameLoop;
        }
        break;
      }
      if (c === 0x2F || c === 0x3E) {
        return {
          attr: {
            name,
            value
          },
          i
        };
      }
      if (c >= 0x41 && c <= 0x5A) {
        name += String.fromCharCode(c + 0x20);
      } else {
        name += String.fromCharCode(c);
      }
    }
    c = buffer[i];
    if (isSpaceCharacter(c)) {
      for (i++; i < l; i++) {
        c = buffer[i];
        if (isSpaceCharacter(c)) {
          continue;
        } else {
          break;
        }
      }
    }
    if (c === 0x22 || c === 0x27) {
      const quote = c;
      for (i++; i < l; i++) {
        c = buffer[i];
        if (c === quote) {
          i++;
          return {
            attr: {
              name,
              value
            },
            i
          };
        }
        if (c >= 0x41 && c <= 0x5A) {
          value += String.fromCharCode(c + 0x20);
        } else {
          value += String.fromCharCode(c);
        }
      }
    }
    if (c === 0x3E) {
      return {
        attr: {
          name,
          value
        },
        i
      };
    }
    if (c >= 0x41 && c <= 0x5A) {
      value += String.fromCharCode(c + 0x20);
    } else {
      value += String.fromCharCode(c);
    }
    for (i++; i < l; i++) {
      c = buffer[i];
      if (isSpaceCharacter(c) || c === 0x3E) {
        return {
          attr: {
            name,
            value
          },
          i
        };
      }
      if (c >= 0x41 && c <= 0x5A) {
        value += String.fromCharCode(c + 0x20);
      } else {
        value += String.fromCharCode(c);
      }
    }
  }
  return {i};
}
function extractCharacterEncodingFromMeta(string) {
  let position = 0;
  while (true) {
    let subPosition = string.substring(position).search(/charset/i);
    if (subPosition === -1) {
      return null;
    }
    subPosition += "charset".length;
    while (isSpaceCharacter(string[subPosition].charCodeAt(0))) {
      ++subPosition;
    }
    if (string[subPosition] !== "=") {
      position = subPosition - 1;
      continue;
    }
    ++subPosition;
    while (isSpaceCharacter(string[subPosition].charCodeAt(0))) {
      ++subPosition;
    }
    position = subPosition;
    break;
  }
  if (string[position] === "\"" || string[position] === "'") {
    const nextIndex = string.indexOf(string[position], position + 1);
    if (nextIndex !== -1) {
      return whatwgEncoding.labelToName(string.substring(position + 1, nextIndex));
    }
    return null;
  }
  if (string.length === position + 1) {
    return null;
  }
  let end = string.substring(position + 1).search(/\x09|\x0A|\x0C|\x0D|\x20|;/);
  if (end === -1) {
    end = string.length;
  }
  return whatwgEncoding.labelToName(string.substring(position, end));
}
function isSpaceCharacter(c) {
  return c === 0x09 || c === 0x0A || c === 0x0C || c === 0x0D || c === 0x20;
}
