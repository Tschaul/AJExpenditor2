/* */ 
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
  for (var s,
      i = 1,
      n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", {value: true});
var babel = require('../../babel-core/index');
var babel_plugin_istanbul_1 = require('../../babel-plugin-istanbul/lib/index');
var jestPreset = require('../../babel-preset-jest/index');
function createBabelTransformer(options) {
  options = __assign({}, options, {
    plugins: (options && options.plugins) || [],
    presets: ((options && options.presets) || []).concat([jestPreset]),
    retainLines: true,
    sourceMaps: 'inline'
  });
  delete options.cacheDirectory;
  delete options.filename;
  return function(src, filename, config, transformOptions) {
    var theseOptions = Object.assign({filename: filename}, options);
    if (transformOptions && transformOptions.instrument) {
      theseOptions.auxiliaryCommentBefore = ' istanbul ignore next ';
      theseOptions.plugins = theseOptions.plugins.concat([[babel_plugin_istanbul_1.default, {
        cwd: config.rootDir,
        exclude: []
      }]]);
    }
    return babel.transform(src, theseOptions).code;
  };
}
exports.getPostProcessHook = function(tsCompilerOptions, jestConfig, tsJestConfig) {
  if (tsJestConfig.skipBabel) {
    return function(src) {
      return src;
    };
  }
  var plugins = [];
  if (tsCompilerOptions.allowSyntheticDefaultImports) {
    plugins.push('transform-es2015-modules-commonjs');
  }
  return createBabelTransformer({
    babelrc: tsJestConfig.useBabelrc || false,
    plugins: plugins,
    presets: []
  });
};
