/* */ 
(function(process) {
  var path = require('path'),
      fs = require('fs'),
      mkdirp = require('../../mkdirp/index'),
      matcherFor = require('./file-matcher').matcherFor,
      libInstrument = require('../../istanbul-lib-instrument/dist/index'),
      libCoverage = require('../../istanbul-lib-coverage/index'),
      libSourceMaps = require('../../istanbul-lib-source-maps/index'),
      hook = require('../../istanbul-lib-hook/index'),
      Reporter = require('./reporter');
  function getCoverFunctions(config, includes, callback) {
    if (!callback && typeof includes === 'function') {
      callback = includes;
      includes = null;
    }
    var includePid = config.instrumentation.includePid(),
        reportingDir = path.resolve(config.reporting.dir()),
        reporter = new Reporter(config),
        excludes = config.instrumentation.excludes(true),
        coverageVar = '$$cov_' + new Date().getTime() + '$$',
        instOpts = config.instrumentation.getInstrumenterOpts(),
        sourceMapStore = libSourceMaps.createSourceMapStore({}),
        instrumenter,
        transformer,
        fakeRequire,
        requireTransformer,
        reportInitFn,
        hookFn,
        unhookFn,
        coverageFinderFn,
        coverageSetterFn,
        beforeReportFn,
        exitFn;
    instOpts.coverageVariable = coverageVar;
    instOpts.sourceMapUrlCallback = function(file, url) {
      sourceMapStore.registerURL(file, url);
    };
    coverageFinderFn = function() {
      return global[coverageVar];
    };
    instrumenter = libInstrument.createInstrumenter(instOpts);
    transformer = function(code, file) {
      return instrumenter.instrumentSync(code, file);
    };
    requireTransformer = function(code, file) {
      var cov,
          ret = transformer(code, file);
      if (fakeRequire) {
        cov = coverageFinderFn();
        cov[file] = instrumenter.lastFileCoverage();
        return 'function x() {}';
      }
      return ret;
    };
    coverageSetterFn = function(cov) {
      global[coverageVar] = cov;
    };
    reportInitFn = function() {
      mkdirp.sync(reportingDir);
      reporter.addAll(config.reporting.reports());
      if (config.reporting.print() !== 'none') {
        switch (config.reporting.print()) {
          case 'detail':
            reporter.add('text');
            break;
          case 'both':
            reporter.add('text');
            reporter.add('text-summary');
            break;
          default:
            reporter.add('text-summary');
            break;
        }
      }
    };
    var disabler;
    hookFn = function(matchFn) {
      var hookOpts = {
        verbose: config.verbose,
        extensions: config.instrumentation.extensions()
      };
      coverageSetterFn({});
      reportInitFn();
      if (config.hooks.hookRunInContext()) {
        hook.hookRunInThisContext(matchFn, transformer, hookOpts);
      }
      disabler = hook.hookRequire(matchFn, requireTransformer, hookOpts);
    };
    unhookFn = function(matchFn) {
      if (disabler) {
        disabler();
      }
      hook.unhookRunInThisContext();
      hook.unloadRequireCache(matchFn);
    };
    beforeReportFn = function(matchFn, cov) {
      var pidExt = includePid ? ('-' + process.pid) : '',
          file = path.resolve(reportingDir, 'coverage' + pidExt + '.raw.json'),
          missingFiles,
          finalCoverage = cov;
      if (config.instrumentation.includeAllSources()) {
        if (config.verbose) {
          console.error("Including all sources not require'd by tests");
        }
        missingFiles = [];
        matchFn.files.forEach(function(file) {
          if (!cov[file]) {
            missingFiles.push(file);
          }
        });
        fakeRequire = true;
        missingFiles.forEach(function(file) {
          try {
            require(file);
          } catch (ex) {
            console.error('Unable to post-instrument: ' + file);
          }
        });
      }
      if (Object.keys(finalCoverage).length > 0) {
        if (config.verbose) {
          console.error('=============================================================================');
          console.error('Writing coverage object [' + file + ']');
          console.error('Writing coverage reports at [' + reportingDir + ']');
          console.error('=============================================================================');
        }
        fs.writeFileSync(file, JSON.stringify(finalCoverage), 'utf8');
      }
      return finalCoverage;
    };
    exitFn = function(matchFn, reporterOpts) {
      var cov,
          coverageMap,
          transformed;
      cov = coverageFinderFn() || {};
      cov = beforeReportFn(matchFn, cov);
      coverageSetterFn(cov);
      if (!(cov && typeof cov === 'object') || Object.keys(cov).length === 0) {
        console.error('No coverage information was collected, exit without writing coverage information');
        return;
      }
      coverageMap = libCoverage.createCoverageMap(cov);
      transformed = sourceMapStore.transformCoverage(coverageMap);
      reporterOpts.sourceFinder = transformed.sourceFinder;
      reporter.write(transformed.map, reporterOpts);
      sourceMapStore.dispose();
    };
    excludes.push(path.relative(process.cwd(), path.join(reportingDir, '**', '*')));
    includes = includes || config.instrumentation.extensions().map(function(ext) {
      return '**/*' + ext;
    });
    var matchConfig = {
      root: config.instrumentation.root() || process.cwd(),
      includes: includes,
      excludes: excludes
    };
    matcherFor(matchConfig, function(err, matchFn) {
      if (err) {
        return callback(err);
      }
      return callback(null, {
        coverageFn: coverageFinderFn,
        hookFn: hookFn.bind(null, matchFn),
        exitFn: exitFn.bind(null, matchFn, {}),
        unhookFn: unhookFn.bind(null, matchFn)
      });
    });
  }
  module.exports = {getCoverFunctions: getCoverFunctions};
})(require('process'));
