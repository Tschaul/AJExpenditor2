/* */ 
(function(Buffer, process) {
  'use strict';
  function _interopDefault(ex) {
    return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;
  }
  var os = _interopDefault(require('os'));
  var require$$0 = _interopDefault(require('fs'));
  var stream = _interopDefault(require('stream'));
  var require$$0$1 = _interopDefault(require('path'));
  var util = _interopDefault(require('util'));
  var events = _interopDefault(require('events'));
  var assert = _interopDefault(require('assert'));
  var readline = _interopDefault(require('readline'));
  var module$1 = _interopDefault(require('module'));
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  var index$2 = function(str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }
    return str.replace(matchOperatorsRe, '\\$&');
  };
  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  function commonjsRequire() {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }
  function createCommonjsModule(fn, module) {
    return module = {exports: {}}, fn(module, module.exports), module.exports;
  }
  var index$8 = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  var conversions$1 = createCommonjsModule(function(module) {
    var cssKeywords = index$8;
    var reverseKeywords = {};
    for (var key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var convert = module.exports = {
      rgb: {
        channels: 3,
        labels: 'rgb'
      },
      hsl: {
        channels: 3,
        labels: 'hsl'
      },
      hsv: {
        channels: 3,
        labels: 'hsv'
      },
      hwb: {
        channels: 3,
        labels: 'hwb'
      },
      cmyk: {
        channels: 4,
        labels: 'cmyk'
      },
      xyz: {
        channels: 3,
        labels: 'xyz'
      },
      lab: {
        channels: 3,
        labels: 'lab'
      },
      lch: {
        channels: 3,
        labels: 'lch'
      },
      hex: {
        channels: 1,
        labels: ['hex']
      },
      keyword: {
        channels: 1,
        labels: ['keyword']
      },
      ansi16: {
        channels: 1,
        labels: ['ansi16']
      },
      ansi256: {
        channels: 1,
        labels: ['ansi256']
      },
      hcg: {
        channels: 3,
        labels: ['h', 'c', 'g']
      },
      apple: {
        channels: 3,
        labels: ['r16', 'g16', 'b16']
      },
      gray: {
        channels: 1,
        labels: ['gray']
      }
    };
    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!('channels' in convert[model])) {
          throw new Error('missing channels property: ' + model);
        }
        if (!('labels' in convert[model])) {
          throw new Error('missing channel labels property: ' + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error('channel and label counts mismatch: ' + model);
        }
        var channels = convert[model].channels;
        var labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], 'channels', {value: channels});
        Object.defineProperty(convert[model], 'labels', {value: labels});
      }
    }
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var v;
      if (max === 0) {
        s = 0;
      } else {
        s = (delta / max * 1000) / 10;
      }
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      v = ((max / 255) * 1000) / 10;
      return [h, s, v];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2));
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
      g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
      b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
      var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
      var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
      var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
      l = (116 * y) - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= (l <= 1) ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - (s * f));
      var t = 255 * v * (1 - (s * (1 - f)));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= (lmin <= 1) ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 0x01) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
      g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
      b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
      r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055) : r * 12.92;
      g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055) : g * 12.92;
      b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055) : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
      l = (116 * y) - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + ((Math.round(b / 255) << 2) | (Math.round(g / 255) << 1) | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round(((r - 8) / 247) * 24) + 232;
      }
      var ansi = 16 + (36 * Math.round(r / 255 * 5)) + (6 * Math.round(g / 255 * 5)) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = ((color & 1) * mult) * 255;
      var g = (((color >> 1) & 1) * mult) * 255;
      var b = (((color >> 2) & 1) * mult) * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = (rem % 6) / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split('').map(function(char) {
          return char + char;
        }).join('');
      }
      var integer = parseInt(colorString, 16);
      var r = (integer >> 16) & 0xFF;
      var g = (integer >> 8) & 0xFF;
      var b = integer & 0xFF;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = (max - min);
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = ((g - b) / chroma) % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2.0 * s * l;
      } else {
        c = 2.0 * s * (1.0 - l);
      }
      if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1.0) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0.0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = (h % 1) * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1.0 - c) * g;
      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      var f = 0;
      if (v > 0.0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1.0 - c) + 0.5 * c;
      var s = 0;
      if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 0xFF;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  });
  var conversions$3 = conversions$1;
  var models$1 = Object.keys(conversions$3);
  function buildGraph() {
    var graph = {};
    for (var len = models$1.length,
        i = 0; i < len; i++) {
      graph[models$1[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions$3[current]);
      for (var len = adjacents.length,
          i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions$3[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions$3[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  var route$1 = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length,
        i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  var conversions = conversions$1;
  var route = route$1;
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    var wrappedFn = function(args) {
      if (args === undefined || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === 'object') {
        for (var len = result.length,
            i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var index$6 = convert;
  var index$4 = createCommonjsModule(function(module) {
    'use strict';
    const colorConvert = index$6;
    const wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\u001B[${code + offset}m`;
    };
    const wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\u001B[${38 + offset};5;${code}m`;
    };
    const wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      Object.keys(styles).forEach((groupName) => {
        const group = styles[groupName];
        Object.keys(group).forEach((styleName) => {
          const style = group[styleName];
          styles[styleName] = {
            open: `\u001B[${style[0]}m`,
            close: `\u001B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
        });
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      });
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = '\u001B[39m';
      styles.bgColor.close = '\u001B[49m';
      styles.color.ansi = {};
      styles.color.ansi256 = {};
      styles.color.ansi16m = {rgb: wrapAnsi16m(rgb2rgb, 0)};
      styles.bgColor.ansi = {};
      styles.bgColor.ansi256 = {};
      styles.bgColor.ansi16m = {rgb: wrapAnsi16m(rgb2rgb, 10)};
      for (const key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== 'object') {
          continue;
        }
        const suite = colorConvert[key];
        if ('ansi16' in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ('ansi256' in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ('rgb' in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module, 'exports', {
      enumerable: true,
      get: assembleStyles
    });
  });
  var index$12 = function(flag, argv) {
    argv = argv || process.argv;
    var terminatorPos = argv.indexOf('--');
    var prefix = /^-{1,2}/.test(flag) ? '' : '--';
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
  const os$1 = os;
  const hasFlag = index$12;
  const env = process.env;
  const support = (level) => {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  let supportLevel = (() => {
    if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
      return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }
    if (hasFlag('color=256')) {
      return 2;
    }
    if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
      return 1;
    }
    if (process.stdout && !process.stdout.isTTY) {
      return 0;
    }
    if (process.platform === 'win32') {
      const osRelease = os$1.release().split('.');
      if (Number(process.version.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return 2;
      }
      return 1;
    }
    if ('CI' in env) {
      if ('TRAVIS' in env || env.CI === 'Travis' || 'CIRCLECI' in env) {
        return 1;
      }
      return 0;
    }
    if ('TEAMCITY_VERSION' in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ('TERM_PROGRAM' in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
      switch (env.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;
        case 'Hyper':
          return 3;
        case 'Apple_Terminal':
          return 2;
      }
    }
    if (/^(screen|xterm)-256(?:color)?/.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ('COLORTERM' in env) {
      return 1;
    }
    if (env.TERM === 'dumb') {
      return 0;
    }
    return 0;
  })();
  if ('FORCE_COLOR' in env) {
    supportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : (supportLevel || 1);
  }
  var index$10 = process && support(supportLevel);
  function data(parent) {
    return {
      styles: [],
      parent,
      contents: []
    };
  }
  const zeroBound = (n) => n < 0 ? 0 : n;
  const lastIndex = (a) => zeroBound(a.length - 1);
  const last = (a) => a[lastIndex(a)];
  const takeWhileReverse = (array, predicate, start) => {
    const out = [];
    for (let i = start; i >= 0 && i <= start; i--) {
      if (predicate(array[i])) {
        out.unshift(array[i]);
      } else {
        break;
      }
    }
    return out;
  };
  const isNormalCharacter = (string, i) => {
    const char = string[i];
    const backslash = '\\';
    if (!(char === backslash || char === '{' || char === '}')) {
      return true;
    }
    const n = i === 0 ? 0 : takeWhileReverse(string, (x) => x === '\\', zeroBound(i - 1)).length;
    return n % 2 === 1;
  };
  const collectStyles = (data) => data ? collectStyles(data.parent).concat(data.styles) : ['reset'];
  const sumStyles = (data) => {
    const negateRegex = /^~.+/;
    let out = [];
    for (const style of collectStyles(data)) {
      if (negateRegex.test(style)) {
        const exclude = style.slice(1);
        out = out.filter((x) => x !== exclude);
      } else {
        out.push(style);
      }
    }
    return out;
  };
  function parse(string) {
    const root = data(null);
    let pushingStyle = false;
    let current = root;
    for (let i = 0; i < string.length; i++) {
      const char = string[i];
      const addNormalCharacter = () => {
        const lastChunk = last(current.contents);
        if (typeof lastChunk === 'string') {
          current.contents[lastIndex(current.contents)] = lastChunk + char;
        } else {
          current.contents.push(char);
        }
      };
      if (pushingStyle) {
        if (' \t'.indexOf(char) > -1) {
          pushingStyle = false;
        } else if (char === '\n') {
          pushingStyle = false;
          addNormalCharacter();
        } else if (char === '.') {
          current.styles.push('');
        } else {
          current.styles[lastIndex(current.styles)] = (last(current.styles) || '') + char;
        }
      } else if (isNormalCharacter(string, i)) {
        addNormalCharacter();
      } else if (char === '{') {
        pushingStyle = true;
        const nCurrent = data(current);
        current.contents.push(nCurrent);
        current = nCurrent;
      } else if (char === '}') {
        current = current.parent;
      }
    }
    if (current !== root) {
      throw new Error('literal template has an unclosed block');
    }
    return root;
  }
  function flatten(data) {
    let flat = [];
    for (const content of data.contents) {
      if (typeof content === 'string') {
        flat.push({
          styles: sumStyles(data),
          content
        });
      } else {
        flat = flat.concat(flatten(content));
      }
    }
    return flat;
  }
  function assertStyle(chalk, style) {
    if (!chalk[style]) {
      throw new Error(`invalid Chalk style: ${style}`);
    }
  }
  function parseStyle(chalk, style) {
    const fnMatch = style.match(/^\s*(\w+)\s*\(\s*([^)]*)\s*\)\s*/);
    if (!fnMatch) {
      assertStyle(chalk, style);
      return chalk[style];
    }
    const name = fnMatch[1].trim();
    const args = fnMatch[2].split(/,/g).map((s) => s.trim());
    assertStyle(chalk, name);
    return chalk[name].apply(chalk, args);
  }
  function style(chalk, flat) {
    return flat.map((data) => {
      const fn = data.styles.reduce(parseStyle, chalk);
      return fn(data.content.replace(/\n$/, ''));
    }).join('');
  }
  var templates = (chalk, string) => style(chalk, flatten(parse(string)));
  const escapeStringRegexp = index$2;
  const ansiStyles = index$4;
  const supportsColor = index$10;
  const template = templates;
  const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');
  const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
  const skipModels = new Set(['gray']);
  const styles = Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    obj.level = options.level === undefined ? supportsColor.level : options.level;
    obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);
      chalk.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };
      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = '\u001B[94m';
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    styles[key] = {get() {
        const codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], key);
      }};
  }
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], model);
        };
      }};
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], model);
        };
      }};
  }
  const proto = Object.defineProperties(() => {}, styles);
  function build(_styles, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    const self = this;
    Object.defineProperty(builder, 'level', {
      enumerable: true,
      get() {
        return self.level;
      },
      set(level) {
        self.level = level;
      }
    });
    Object.defineProperty(builder, 'enabled', {
      enumerable: true,
      get() {
        return self.enabled;
      },
      set(enabled) {
        self.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args = arguments;
    const argsLen = args.length;
    let str = argsLen !== 0 && String(arguments[0]);
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += ' ' + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = '';
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk, strings) {
    const args = [].slice.call(arguments, 2);
    if (!Array.isArray(strings)) {
      return strings.toString();
    }
    const parts = [strings.raw[0]];
    for (let i = 1; i < strings.length; i++) {
      parts.push(args[i - 1].toString().replace(/[{}]/g, '\\$&'));
      parts.push(strings.raw[i]);
    }
    return template(chalk, parts.join(''));
  }
  Object.defineProperties(Chalk.prototype, styles);
  var index = Chalk();
  var supportsColor_1 = supportsColor;
  index.supportsColor = supportsColor_1;
  var index$14 = function dashify(str) {
    if (typeof str !== 'string') {
      throw new TypeError('expected a string');
    }
    str = str.replace(/([a-z])([A-Z])/g, '$1-$2');
    str = str.replace(/[ \t\W]/g, '-');
    str = str.replace(/^-+|-+$/g, '');
    return str.toLowerCase();
  };
  const PassThrough = stream.PassThrough;
  var bufferStream$1 = (opts) => {
    opts = Object.assign({}, opts);
    const array = opts.array;
    let encoding = opts.encoding;
    const buffer = encoding === 'buffer';
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || buffer);
    } else {
      encoding = encoding || 'utf8';
    }
    if (buffer) {
      encoding = null;
    }
    let len = 0;
    const ret = [];
    const stream$$1 = new PassThrough({objectMode});
    if (encoding) {
      stream$$1.setEncoding(encoding);
    }
    stream$$1.on('data', (chunk) => {
      ret.push(chunk);
      if (objectMode) {
        len = ret.length;
      } else {
        len += chunk.length;
      }
    });
    stream$$1.getBufferedValue = () => {
      if (array) {
        return ret;
      }
      return buffer ? Buffer.concat(ret, len) : ret.join('');
    };
    stream$$1.getBufferedLength = () => len;
    return stream$$1;
  };
  const bufferStream = bufferStream$1;
  function getStream$1(inputStream, opts) {
    if (!inputStream) {
      return Promise.reject(new Error('Expected a stream'));
    }
    opts = Object.assign({maxBuffer: Infinity}, opts);
    const maxBuffer = opts.maxBuffer;
    let stream$$1;
    let clean;
    const p = new Promise((resolve, reject) => {
      const error = (err) => {
        if (err) {
          err.bufferedData = stream$$1.getBufferedValue();
        }
        reject(err);
      };
      stream$$1 = bufferStream(opts);
      inputStream.once('error', error);
      inputStream.pipe(stream$$1);
      stream$$1.on('data', () => {
        if (stream$$1.getBufferedLength() > maxBuffer) {
          reject(new Error('maxBuffer exceeded'));
        }
      });
      stream$$1.once('error', error);
      stream$$1.on('end', resolve);
      clean = () => {
        if (inputStream.unpipe) {
          inputStream.unpipe(stream$$1);
        }
      };
    });
    p.then(clean, clean);
    return p.then(() => stream$$1.getBufferedValue());
  }
  var index$16 = getStream$1;
  var buffer = (stream$$1, opts) => getStream$1(stream$$1, Object.assign({}, opts, {encoding: 'buffer'}));
  var array = (stream$$1, opts) => getStream$1(stream$$1, Object.assign({}, opts, {array: true}));
  index$16.buffer = buffer;
  index$16.array = array;
  var PENDING = 'pending';
  var SETTLED = 'settled';
  var FULFILLED = 'fulfilled';
  var REJECTED = 'rejected';
  var NOOP = function() {};
  var isNode = typeof commonjsGlobal !== 'undefined' && typeof commonjsGlobal.process !== 'undefined' && typeof commonjsGlobal.process.emit === 'function';
  var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
  var asyncQueue = [];
  var asyncTimer;
  function asyncFlush() {
    for (var i = 0; i < asyncQueue.length; i++) {
      asyncQueue[i][0](asyncQueue[i][1]);
    }
    asyncQueue = [];
    asyncTimer = false;
  }
  function asyncCall(callback, arg) {
    asyncQueue.push([callback, arg]);
    if (!asyncTimer) {
      asyncTimer = true;
      asyncSetTimer(asyncFlush, 0);
    }
  }
  function invokeResolver(resolver, promise) {
    function resolvePromise(value) {
      resolve(promise, value);
    }
    function rejectPromise(reason) {
      reject(promise, reason);
    }
    try {
      resolver(resolvePromise, rejectPromise);
    } catch (e) {
      rejectPromise(e);
    }
  }
  function invokeCallback(subscriber) {
    var owner = subscriber.owner;
    var settled = owner._state;
    var value = owner._data;
    var callback = subscriber[settled];
    var promise = subscriber.then;
    if (typeof callback === 'function') {
      settled = FULFILLED;
      try {
        value = callback(value);
      } catch (e) {
        reject(promise, e);
      }
    }
    if (!handleThenable(promise, value)) {
      if (settled === FULFILLED) {
        resolve(promise, value);
      }
      if (settled === REJECTED) {
        reject(promise, value);
      }
    }
  }
  function handleThenable(promise, value) {
    var resolved;
    try {
      if (promise === value) {
        throw new TypeError('A promises callback cannot return that same promise.');
      }
      if (value && (typeof value === 'function' || typeof value === 'object')) {
        var then = value.then;
        if (typeof then === 'function') {
          then.call(value, function(val) {
            if (!resolved) {
              resolved = true;
              if (value === val) {
                fulfill(promise, val);
              } else {
                resolve(promise, val);
              }
            }
          }, function(reason) {
            if (!resolved) {
              resolved = true;
              reject(promise, reason);
            }
          });
          return true;
        }
      }
    } catch (e) {
      if (!resolved) {
        reject(promise, e);
      }
      return true;
    }
    return false;
  }
  function resolve(promise, value) {
    if (promise === value || !handleThenable(promise, value)) {
      fulfill(promise, value);
    }
  }
  function fulfill(promise, value) {
    if (promise._state === PENDING) {
      promise._state = SETTLED;
      promise._data = value;
      asyncCall(publishFulfillment, promise);
    }
  }
  function reject(promise, reason) {
    if (promise._state === PENDING) {
      promise._state = SETTLED;
      promise._data = reason;
      asyncCall(publishRejection, promise);
    }
  }
  function publish(promise) {
    promise._then = promise._then.forEach(invokeCallback);
  }
  function publishFulfillment(promise) {
    promise._state = FULFILLED;
    publish(promise);
  }
  function publishRejection(promise) {
    promise._state = REJECTED;
    publish(promise);
    if (!promise._handled && isNode) {
      commonjsGlobal.process.emit('unhandledRejection', promise._data, promise);
    }
  }
  function notifyRejectionHandled(promise) {
    commonjsGlobal.process.emit('rejectionHandled', promise);
  }
  function Promise$2(resolver) {
    if (typeof resolver !== 'function') {
      throw new TypeError('Promise resolver ' + resolver + ' is not a function');
    }
    if (this instanceof Promise$2 === false) {
      throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
    }
    this._then = [];
    invokeResolver(resolver, this);
  }
  Promise$2.prototype = {
    constructor: Promise$2,
    _state: PENDING,
    _then: null,
    _data: undefined,
    _handled: false,
    then: function(onFulfillment, onRejection) {
      var subscriber = {
        owner: this,
        then: new this.constructor(NOOP),
        fulfilled: onFulfillment,
        rejected: onRejection
      };
      if ((onRejection || onFulfillment) && !this._handled) {
        this._handled = true;
        if (this._state === REJECTED && isNode) {
          asyncCall(notifyRejectionHandled, this);
        }
      }
      if (this._state === FULFILLED || this._state === REJECTED) {
        asyncCall(invokeCallback, subscriber);
      } else {
        this._then.push(subscriber);
      }
      return subscriber.then;
    },
    catch: function(onRejection) {
      return this.then(null, onRejection);
    }
  };
  Promise$2.all = function(promises) {
    if (!Array.isArray(promises)) {
      throw new TypeError('You must pass an array to Promise.all().');
    }
    return new Promise$2(function(resolve, reject) {
      var results = [];
      var remaining = 0;
      function resolver(index) {
        remaining++;
        return function(value) {
          results[index] = value;
          if (!--remaining) {
            resolve(results);
          }
        };
      }
      for (var i = 0,
          promise; i < promises.length; i++) {
        promise = promises[i];
        if (promise && typeof promise.then === 'function') {
          promise.then(resolver(i), reject);
        } else {
          results[i] = promise;
        }
      }
      if (!remaining) {
        resolve(results);
      }
    });
  };
  Promise$2.race = function(promises) {
    if (!Array.isArray(promises)) {
      throw new TypeError('You must pass an array to Promise.race().');
    }
    return new Promise$2(function(resolve, reject) {
      for (var i = 0,
          promise; i < promises.length; i++) {
        promise = promises[i];
        if (promise && typeof promise.then === 'function') {
          promise.then(resolve, reject);
        } else {
          resolve(promise);
        }
      }
    });
  };
  Promise$2.resolve = function(value) {
    if (value && typeof value === 'object' && value.constructor === Promise$2) {
      return value;
    }
    return new Promise$2(function(resolve) {
      resolve(value);
    });
  };
  Promise$2.reject = function(reason) {
    return new Promise$2(function(resolve, reject) {
      reject(reason);
    });
  };
  var index$22 = Promise$2;
  var index$20 = typeof Promise === 'function' ? Promise : index$22;
  var index$26 = createCommonjsModule(function(module) {
    'use strict';
    function uniqNoSet(arr) {
      var ret = [];
      for (var i = 0; i < arr.length; i++) {
        if (ret.indexOf(arr[i]) === -1) {
          ret.push(arr[i]);
        }
      }
      return ret;
    }
    function uniqSet(arr) {
      var seen = new Set();
      return arr.filter(function(el) {
        if (!seen.has(el)) {
          seen.add(el);
          return true;
        }
        return false;
      });
    }
    function uniqSetWithForEach(arr) {
      var ret = [];
      (new Set(arr)).forEach(function(el) {
        ret.push(el);
      });
      return ret;
    }
    function doesForEachActuallyWork() {
      var ret = false;
      (new Set([true])).forEach(function(el) {
        ret = el;
      });
      return ret === true;
    }
    if ('Set' in commonjsGlobal) {
      if (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {
        module.exports = uniqSetWithForEach;
      } else {
        module.exports = uniqSet;
      }
    } else {
      module.exports = uniqNoSet;
    }
  });
  var arrayUniq = index$26;
  var index$24 = function() {
    return arrayUniq([].concat.apply([], arguments));
  };
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String('abc');
      test1[5] = 'de';
      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join('') !== '0123456789') {
        return false;
      }
      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  var index$28 = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  var pathModule = require$$0$1;
  var isWindows = process.platform === 'win32';
  var fs$3 = require$$0;
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error;
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = 'fs: missing callback ' + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === 'function' ? cb : rethrow();
  }
  if (isWindows) {
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  if (isWindows) {
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    var splitRootRe = /^[\/]*/;
  }
  var realpathSync$1 = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p,
        seenLinks = {},
        knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = '';
      if (isWindows && !knownHard[base]) {
        fs$3.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || (cache && cache[base] === base)) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs$3.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs$3.statSync(base);
          linkTarget = fs$3.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  var realpath$1 = function realpath(p, cache, cb) {
    if (typeof cb !== 'function') {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p,
        seenLinks = {},
        knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = '';
      if (isWindows && !knownHard[base]) {
        fs$3.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || (cache && cache[base] === base)) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs$3.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs$3.stat(base, function(err) {
        if (err)
          return cb(err);
        fs$3.readlink(base, function(err, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err, target);
        });
      });
    }
    function gotTarget(err, target, base) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
  var old$1 = {
    realpathSync: realpathSync$1,
    realpath: realpath$1
  };
  var index$30 = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs$2 = require$$0;
  var origRealpath = fs$2.realpath;
  var origRealpathSync = fs$2.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = old$1;
  function newError(er) {
    return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === 'function') {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs$2.realpath = realpath;
    fs$2.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs$2.realpath = origRealpath;
    fs$2.realpathSync = origRealpathSync;
  }
  var index$34 = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  var index$36 = balanced$1;
  function balanced$1(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced$1.range = range;
  function range(a, b, str) {
    var begs,
        beg,
        left,
        right,
        result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  var concatMap = index$34;
  var balanced = index$36;
  var index$32 = expandTop;
  var escSlash = '\0SLASH' + Math.random() + '\0';
  var escOpen = '\0OPEN' + Math.random() + '\0';
  var escClose = '\0CLOSE' + Math.random() + '\0';
  var escComma = '\0COMMA' + Math.random() + '\0';
  var escPeriod = '\0PERIOD' + Math.random() + '\0';
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
  }
  function parseCommaParts(str) {
    if (!str)
      return [''];
    var parts = [];
    var m = balanced('{', '}', str);
    if (!m)
      return str.split(',');
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(',');
    p[p.length - 1] += '{' + body + '}';
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === '{}') {
      str = '\\{\\}' + str.substr(2);
    }
    return expand$1(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return '{' + str + '}';
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand$1(str, isTop) {
    var expansions = [];
    var m = balanced('{', '}', str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand$1(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand$1(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand$1(m.post, false) : [''];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand$1(m.post, false) : [''];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand$1(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  var minimatch_1 = minimatch$1;
  minimatch$1.Minimatch = Minimatch$1;
  var path$2 = {sep: '/'};
  try {
    path$2 = require$$0$1;
  } catch (er) {}
  var GLOBSTAR = minimatch$1.GLOBSTAR = Minimatch$1.GLOBSTAR = {};
  var expand = index$32;
  var plTypes = {
    '!': {
      open: '(?:(?!(?:',
      close: '))[^/]*?)'
    },
    '?': {
      open: '(?:',
      close: ')?'
    },
    '+': {
      open: '(?:',
      close: ')+'
    },
    '*': {
      open: '(?:',
      close: ')*'
    },
    '@': {
      open: '(?:',
      close: ')'
    }
  };
  var qmark = '[^/]';
  var star = qmark + '*?';
  var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';
  var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';
  var reSpecials = charSet('().*{}+?[]^$\\!');
  function charSet(s) {
    return s.split('').reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch$1.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch$1(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch$1.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch$1;
    var orig = minimatch$1;
    var m = function minimatch(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m;
  };
  Minimatch$1.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch$1;
    return minimatch$1.defaults(def).Minimatch;
  };
  function minimatch$1(p, pattern, options) {
    if (typeof pattern !== 'string') {
      throw new TypeError('glob pattern string required');
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === '#') {
      return false;
    }
    if (pattern.trim() === '')
      return p === '';
    return new Minimatch$1(pattern, options).match(p);
  }
  function Minimatch$1(pattern, options) {
    if (!(this instanceof Minimatch$1)) {
      return new Minimatch$1(pattern, options);
    }
    if (typeof pattern !== 'string') {
      throw new TypeError('glob pattern string required');
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path$2.sep !== '/') {
      pattern = pattern.split(path$2.sep).join('/');
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch$1.prototype.debug = function() {};
  Minimatch$1.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === '#') {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch$1.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0,
        l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch$1.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch$1.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch$1) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
    if (typeof pattern === 'undefined') {
      throw new TypeError('undefined pattern');
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch$1.prototype.parse = parse$1;
  var SUBPARSE = {};
  function parse$1(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError('pattern is too long');
    }
    var options = this.options;
    if (!options.noglobstar && pattern === '**')
      return GLOBSTAR;
    if (pattern === '')
      return '';
    var re = '';
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === '.' ? '' : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
    var self = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case '*':
            re += star;
            hasMagic = true;
            break;
          case '?':
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += '\\' + stateChar;
            break;
        }
        self.debug('clearStateChar %j %j', stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0,
        len = pattern.length,
        c; (i < len) && (c = pattern.charAt(i)); i++) {
      this.debug('%s\t%s %s %j', pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += '\\' + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case '/':
          return false;
        case '\\':
          clearStateChar();
          escaping = true;
          continue;
        case '?':
        case '*':
        case '+':
        case '@':
        case '!':
          this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
          if (inClass) {
            this.debug('  in class');
            if (c === '!' && i === classStart + 1)
              c = '^';
            re += c;
            continue;
          }
          self.debug('call clearStateChar %j', stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case '(':
          if (inClass) {
            re += '(';
            continue;
          }
          if (!stateChar) {
            re += '\\(';
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
          this.debug('plType %j %j', stateChar, re);
          stateChar = false;
          continue;
        case ')':
          if (inClass || !patternListStack.length) {
            re += '\\)';
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === '!') {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case '|':
          if (inClass || !patternListStack.length || escaping) {
            re += '\\|';
            escaping = false;
            continue;
          }
          clearStateChar();
          re += '|';
          continue;
        case '[':
          clearStateChar();
          if (inClass) {
            re += '\\' + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case ']':
          if (i === classStart + 1 || !inClass) {
            re += '\\' + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp('[' + cs + ']');
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === '^' && inClass)) {
            re += '\\';
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + '\\[' + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug('setting tail', re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = '\\';
        }
        return $1 + $1 + $2 + '|';
      });
      this.debug('tail=%j\n   %s', tail, tail, pl, re);
      var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + '\\(' + tail;
    }
    clearStateChar();
    if (escaping) {
      re += '\\\\';
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case '.':
      case '[':
      case '(':
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split('(').length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
      }
      nlAfter = cleanAfter;
      var dollar = '';
      if (nlAfter === '' && isSub !== SUBPARSE) {
        dollar = '$';
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== '' && hasMagic) {
      re = '(?=.)' + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? 'i' : '';
    try {
      var regExp = new RegExp('^' + re + '$', flags);
    } catch (er) {
      return new RegExp('$.');
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch$1.makeRe = function(pattern, options) {
    return new Minimatch$1(pattern, options || {}).makeRe();
  };
  Minimatch$1.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? 'i' : '';
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return (p === GLOBSTAR) ? twoStar : (typeof p === 'string') ? regExpEscape(p) : p._src;
      }).join('\\\/');
    }).join('|');
    re = '^(?:' + re + ')$';
    if (this.negate)
      re = '^(?!' + re + ').*$';
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch$1.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch$1(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch$1.prototype.match = match;
  function match(f, partial) {
    this.debug('match', f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === '';
    if (f === '/' && partial)
      return true;
    var options = this.options;
    if (path$2.sep !== '/') {
      f = f.split(path$2.sep).join('/');
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, 'split', f);
    var set = this.set;
    this.debug(this.pattern, 'set', set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch$1.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug('matchOne', {
      'this': this,
      file: file,
      pattern: pattern
    });
    this.debug('matchOne', file.length, pattern.length);
    for (var fi = 0,
        pi = 0,
        fl = file.length,
        pl = pattern.length; (fi < fl) && (pi < pl); fi++, pi++) {
      this.debug('matchOne loop');
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug('GLOBSTAR', [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug('** at the end');
          for (; fi < fl; fi++) {
            if (file[fi] === '.' || file[fi] === '..' || (!options.dot && file[fi].charAt(0) === '.'))
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug('globstar found match!', fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === '.' || swallowee === '..' || (!options.dot && swallowee.charAt(0) === '.')) {
              this.debug('dot detected!', file, fr, pattern, pr);
              break;
            }
            this.debug('globstar swallow a segment, and continue');
            fr++;
          }
        }
        if (partial) {
          this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === 'string') {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug('string match', p, f, hit);
      } else {
        hit = f.match(p);
        this.debug('pattern match', p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');
      return emptyFileEnd;
    }
    throw new Error('wtf?');
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, '$1');
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
  }
  var inherits_browser = createCommonjsModule(function(module) {
    if (typeof Object.create === 'function') {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }});
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  });
  var inherits$1 = createCommonjsModule(function(module) {
    try {
      var util$$1 = util;
      if (typeof util$$1.inherits !== 'function')
        throw '';
      module.exports = util$$1.inherits;
    } catch (e) {
      module.exports = inherits_browser;
    }
  });
  function posix(path) {
    return path.charAt(0) === '/';
  }
  function win32(path) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path);
    var device = result[1] || '';
    var isUnc = Boolean(device && device.charAt(1) !== ':');
    return Boolean(result[2] || isUnc);
  }
  var index$38 = process.platform === 'win32' ? win32 : posix;
  var posix_1 = posix;
  var win32_1 = win32;
  index$38.posix = posix_1;
  index$38.win32 = win32_1;
  var alphasort_1 = alphasort$2;
  var alphasorti_1 = alphasorti$2;
  var setopts_1 = setopts$2;
  var ownProp_1 = ownProp$2;
  var makeAbs_1 = makeAbs;
  var finish_1 = finish;
  var mark_1 = mark;
  var isIgnored_1 = isIgnored$2;
  var childrenIgnored_1 = childrenIgnored$2;
  function ownProp$2(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var path$4 = require$$0$1;
  var minimatch$3 = minimatch_1;
  var isAbsolute$2 = index$38;
  var Minimatch$3 = minimatch$3.Minimatch;
  function alphasorti$2(a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  }
  function alphasort$2(a, b) {
    return a.localeCompare(b);
  }
  function setupIgnores(self, options) {
    self.ignore = options.ignore || [];
    if (!Array.isArray(self.ignore))
      self.ignore = [self.ignore];
    if (self.ignore.length) {
      self.ignore = self.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === '/**') {
      var gpattern = pattern.replace(/(\/\*\*)+$/, '');
      gmatcher = new Minimatch$3(gpattern, {dot: true});
    }
    return {
      matcher: new Minimatch$3(pattern, {dot: true}),
      gmatcher: gmatcher
    };
  }
  function setopts$2(self, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && -1 === pattern.indexOf("/")) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self.silent = !!options.silent;
    self.pattern = pattern;
    self.strict = options.strict !== false;
    self.realpath = !!options.realpath;
    self.realpathCache = options.realpathCache || Object.create(null);
    self.follow = !!options.follow;
    self.dot = !!options.dot;
    self.mark = !!options.mark;
    self.nodir = !!options.nodir;
    if (self.nodir)
      self.mark = true;
    self.sync = !!options.sync;
    self.nounique = !!options.nounique;
    self.nonull = !!options.nonull;
    self.nosort = !!options.nosort;
    self.nocase = !!options.nocase;
    self.stat = !!options.stat;
    self.noprocess = !!options.noprocess;
    self.absolute = !!options.absolute;
    self.maxLength = options.maxLength || Infinity;
    self.cache = options.cache || Object.create(null);
    self.statCache = options.statCache || Object.create(null);
    self.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self, options);
    self.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp$2(options, "cwd"))
      self.cwd = cwd;
    else {
      self.cwd = path$4.resolve(options.cwd);
      self.changedCwd = self.cwd !== cwd;
    }
    self.root = options.root || path$4.resolve(self.cwd, "/");
    self.root = path$4.resolve(self.root);
    if (process.platform === "win32")
      self.root = self.root.replace(/\\/g, "/");
    self.cwdAbs = isAbsolute$2(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
    if (process.platform === "win32")
      self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
    self.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    self.minimatch = new Minimatch$3(pattern, options);
    self.options = self.minimatch.options;
  }
  function finish(self) {
    var nou = self.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0,
        l = self.matches.length; i < l; i++) {
      var matches = self.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self.nonull) {
          var literal = self.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m = Object.keys(matches);
        if (nou)
          all.push.apply(all, m);
        else
          m.forEach(function(m) {
            all[m] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self.nosort)
      all = all.sort(self.nocase ? alphasorti$2 : alphasort$2);
    if (self.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self._mark(all[i]);
      }
      if (self.nodir) {
        all = all.filter(function(e) {
          var notDir = !(/\/$/.test(e));
          var c = self.cache[e] || self.cache[makeAbs(self, e)];
          if (notDir && c)
            notDir = c !== 'DIR' && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self.ignore.length)
      all = all.filter(function(m) {
        return !isIgnored$2(self, m);
      });
    self.found = all;
  }
  function mark(self, p) {
    var abs = makeAbs(self, p);
    var c = self.cache[abs];
    var m = p;
    if (c) {
      var isDir = c === 'DIR' || Array.isArray(c);
      var slash = p.slice(-1) === '/';
      if (isDir && !slash)
        m += '/';
      else if (!isDir && slash)
        m = m.slice(0, -1);
      if (m !== p) {
        var mabs = makeAbs(self, m);
        self.statCache[mabs] = self.statCache[abs];
        self.cache[mabs] = self.cache[abs];
      }
    }
    return m;
  }
  function makeAbs(self, f) {
    var abs = f;
    if (f.charAt(0) === '/') {
      abs = path$4.join(self.root, f);
    } else if (isAbsolute$2(f) || f === '') {
      abs = f;
    } else if (self.changedCwd) {
      abs = path$4.resolve(self.cwd, f);
    } else {
      abs = path$4.resolve(f);
    }
    if (process.platform === 'win32')
      abs = abs.replace(/\\/g, '/');
    return abs;
  }
  function isIgnored$2(self, path) {
    if (!self.ignore.length)
      return false;
    return self.ignore.some(function(item) {
      return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
    });
  }
  function childrenIgnored$2(self, path) {
    if (!self.ignore.length)
      return false;
    return self.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path));
    });
  }
  var common$2 = {
    alphasort: alphasort_1,
    alphasorti: alphasorti_1,
    setopts: setopts_1,
    ownProp: ownProp_1,
    makeAbs: makeAbs_1,
    finish: finish_1,
    mark: mark_1,
    isIgnored: isIgnored_1,
    childrenIgnored: childrenIgnored_1
  };
  var sync$1 = globSync$1;
  globSync$1.GlobSync = GlobSync$1;
  var fs$4 = require$$0;
  var rp$1 = index$30;
  var minimatch$2 = minimatch_1;
  var path$3 = require$$0$1;
  var assert$2 = assert;
  var isAbsolute$1 = index$38;
  var common$1 = common$2;
  var setopts$1 = common$1.setopts;
  var ownProp$1 = common$1.ownProp;
  var childrenIgnored$1 = common$1.childrenIgnored;
  var isIgnored$1 = common$1.isIgnored;
  function globSync$1(pattern, options) {
    if (typeof options === 'function' || arguments.length === 3)
      throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
    return new GlobSync$1(pattern, options).found;
  }
  function GlobSync$1(pattern, options) {
    if (!pattern)
      throw new Error('must provide pattern');
    if (typeof options === 'function' || arguments.length === 3)
      throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
    if (!(this instanceof GlobSync$1))
      return new GlobSync$1(pattern, options);
    setopts$1(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync$1.prototype._finish = function() {
    assert$2(this instanceof GlobSync$1);
    if (this.realpath) {
      var self = this;
      this.matches.forEach(function(matchset, index) {
        var set = self.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self._makeAbs(p);
            var real = rp$1.realpathSync(p, self.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === 'stat')
              set[self._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common$1.finish(this);
  };
  GlobSync$1.prototype._process = function(pattern, index, inGlobStar) {
    assert$2(this instanceof GlobSync$1);
    var n = 0;
    while (typeof pattern[n] === 'string') {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join('/'), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join('/');
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = '.';
    else if (isAbsolute$1(prefix) || isAbsolute$1(pattern.join('/'))) {
      if (!prefix || !isAbsolute$1(prefix))
        prefix = '/' + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored$1(this, read))
      return;
    var isGlobStar = remain[0] === minimatch$2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync$1.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === '.';
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== '.' || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== '/')
            e = prefix + '/' + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === '/' && !this.nomount) {
          e = path$3.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync$1.prototype._emitMatch = function(index, e) {
    if (isIgnored$1(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === 'DIR' || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync$1.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = fs$4.lstatSync(abs);
    } catch (er) {
      if (er.code === 'ENOENT') {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = 'FILE';
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync$1.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp$1(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp$1(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === 'FILE')
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, fs$4.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync$1.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === '/')
          e = abs + e;
        else
          e = abs + '/' + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync$1.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case 'ENOTSUP':
      case 'ENOTDIR':
        var abs = this._makeAbs(f);
        this.cache[abs] = 'FILE';
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + ' invalid cwd ' + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          throw error;
        }
        break;
      case 'ENOENT':
      case 'ELOOP':
      case 'ENAMETOOLONG':
      case 'UNKNOWN':
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error('glob error', er);
        break;
    }
  };
  GlobSync$1.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === '.' && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync$1.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute$1(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === '/') {
        prefix = path$3.join(this.root, prefix);
      } else {
        prefix = path$3.resolve(this.root, prefix);
        if (trail)
          prefix += '/';
      }
    }
    if (process.platform === 'win32')
      prefix = prefix.replace(/\\/g, '/');
    this._emitMatch(index, prefix);
  };
  GlobSync$1.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === '/';
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp$1(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = 'DIR';
      if (!needDir || c === 'DIR')
        return c;
      if (needDir && c === 'FILE')
        return false;
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = fs$4.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs$4.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? 'DIR' : 'FILE';
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === 'FILE')
      return false;
    return c;
  };
  GlobSync$1.prototype._mark = function(p) {
    return common$1.mark(this, p);
  };
  GlobSync$1.prototype._makeAbs = function(f) {
    return common$1.makeAbs(this, f);
  };
  var wrappy_1 = wrappy$1;
  function wrappy$1(fn, cb) {
    if (fn && cb)
      return wrappy$1(fn)(cb);
    if (typeof fn !== 'function')
      throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb = args[args.length - 1];
      if (typeof ret === 'function' && ret !== cb) {
        Object.keys(cb).forEach(function(k) {
          ret[k] = cb[k];
        });
      }
      return ret;
    }
  }
  var wrappy$2 = wrappy_1;
  var once_1 = wrappy$2(once$2);
  var strict = wrappy$2(onceStrict);
  once$2.proto = once$2(function() {
    Object.defineProperty(Function.prototype, 'once', {
      value: function() {
        return once$2(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once$2(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  once_1.strict = strict;
  var wrappy = wrappy_1;
  var reqs = Object.create(null);
  var once$1 = once_1;
  var inflight_1 = wrappy(inflight$1);
  function inflight$1(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once$1(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array = [];
    for (var i = 0; i < length; i++)
      array[i] = args[i];
    return array;
  }
  var glob_1 = glob$1;
  var fs$1 = require$$0;
  var rp = index$30;
  var minimatch = minimatch_1;
  var inherits = inherits$1;
  var EE = events.EventEmitter;
  var path$1 = require$$0$1;
  var assert$1 = assert;
  var isAbsolute = index$38;
  var globSync = sync$1;
  var common = common$2;
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = inflight_1;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = once_1;
  function glob$1(pattern, options, cb) {
    if (typeof options === 'function')
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError('callback provided to sync glob');
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob$1.sync = globSync;
  var GlobSync = glob$1.GlobSync = globSync.GlobSync;
  glob$1.glob = glob$1;
  function extend(origin, add) {
    if (add === null || typeof add !== 'object') {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob$1.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== 'string')
        return true;
    }
    return false;
  };
  glob$1.Glob = Glob;
  inherits(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === 'function') {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError('callback provided to sync glob');
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === 'function') {
      cb = once(cb);
      this.on('error', cb);
      this.on('end', function(matches) {
        cb(null, matches);
      });
    }
    var self = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
      --self._processing;
      if (self._processing <= 0) {
        if (sync) {
          process.nextTick(function() {
            self._finish();
          });
        } else {
          self._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert$1(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit('end', this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self._makeAbs(p);
      rp.realpath(p, self.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === 'stat')
          set[p] = true;
        else
          self.emit('error', er);
        if (--n === 0) {
          self.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit('abort');
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit('pause');
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit('resume');
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert$1(this instanceof Glob);
    assert$1(typeof cb === 'function');
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === 'string') {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join('/'), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join('/');
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = '.';
    else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = '/' + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === '.';
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== '.' || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === '/' && !this.nomount) {
          e = path$1.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === 'DIR' || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit('stat', e, st);
    this.emit('match', e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = 'lstat\0' + abs;
    var self = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      fs$1.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === 'ENOENT')
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self.cache[abs] = 'FILE';
        cb();
      } else
        self._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight('readdir\0' + abs + '\0' + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === 'FILE')
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self = this;
    fs$1.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self, abs, cb) {
    return function(er, entries) {
      if (er)
        self._readdirError(abs, er, cb);
      else
        self._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === '/')
          e = abs + e;
        else
          e = abs + '/' + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case 'ENOTSUP':
      case 'ENOTDIR':
        var abs = this._makeAbs(f);
        this.cache[abs] = 'FILE';
        if (abs === this.cwdAbs) {
          var error = new Error(er.code + ' invalid cwd ' + this.cwd);
          error.path = this.cwd;
          error.code = er.code;
          this.emit('error', error);
          this.abort();
        }
        break;
      case 'ENOENT':
      case 'ELOOP':
      case 'ENAMETOOLONG':
      case 'UNKNOWN':
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit('error', er);
          this.abort();
        }
        if (!this.silent)
          console.error('glob error', er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === '.' && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self = this;
    this._stat(prefix, function(er, exists) {
      self._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === '/') {
        prefix = path$1.join(this.root, prefix);
      } else {
        prefix = path$1.resolve(this.root, prefix);
        if (trail)
          prefix += '/';
      }
    }
    if (process.platform === 'win32')
      prefix = prefix.replace(/\\/g, '/');
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === '/';
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = 'DIR';
      if (!needDir || c === 'DIR')
        return cb(null, c);
      if (needDir && c === 'FILE')
        return cb();
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== undefined) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type = stat.isDirectory() ? 'DIR' : 'FILE';
        if (needDir && type === 'FILE')
          return cb();
        else
          return cb(null, type, stat);
      }
    }
    var self = this;
    var statcb = inflight('stat\0' + abs, lstatcb_);
    if (statcb)
      fs$1.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return fs$1.stat(abs, function(er, stat) {
          if (er)
            self._stat2(f, abs, null, lstat, cb);
          else
            self._stat2(f, abs, er, stat, cb);
        });
      } else {
        self._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === '/';
    this.statCache[abs] = stat;
    if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? 'DIR' : 'FILE';
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === 'FILE')
      return cb();
    return cb(null, c, stat);
  };
  var index$40 = createCommonjsModule(function(module) {
    'use strict';
    var processFn = function(fn, P, opts) {
      return function() {
        var that = this;
        var args = new Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        return new P(function(resolve, reject) {
          args.push(function(err, result) {
            if (err) {
              reject(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i = 1; i < arguments.length; i++) {
                results[i - 1] = arguments[i];
              }
              resolve(results);
            } else {
              resolve(result);
            }
          });
          fn.apply(that, args);
        });
      };
    };
    var pify = module.exports = function(obj, P, opts) {
      if (typeof P !== 'function') {
        opts = P;
        P = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter = function(key) {
        var match = function(pattern) {
          return typeof pattern === 'string' ? key === pattern : pattern.test(key);
        };
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      var ret = typeof obj === 'function' ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret, key) {
        var x = obj[key];
        ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;
        return ret;
      }, ret);
    };
    pify.all = pify;
  });
  var Promise$1 = index$20;
  var arrayUnion = index$24;
  var objectAssign = index$28;
  var glob = glob_1;
  var pify = index$40;
  var globP = pify(glob, Promise$1).bind(glob);
  function isNegative(pattern) {
    return pattern[0] === '!';
  }
  function isString(value) {
    return typeof value === 'string';
  }
  function assertPatternsInput(patterns) {
    if (!patterns.every(isString)) {
      throw new TypeError('patterns must be a string or an array of strings');
    }
  }
  function generateGlobTasks(patterns, opts) {
    patterns = [].concat(patterns);
    assertPatternsInput(patterns);
    var globTasks = [];
    opts = objectAssign({
      cache: Object.create(null),
      statCache: Object.create(null),
      realpathCache: Object.create(null),
      symlinks: Object.create(null),
      ignore: []
    }, opts);
    patterns.forEach(function(pattern, i) {
      if (isNegative(pattern)) {
        return;
      }
      var ignore = patterns.slice(i).filter(isNegative).map(function(pattern) {
        return pattern.slice(1);
      });
      globTasks.push({
        pattern: pattern,
        opts: objectAssign({}, opts, {ignore: opts.ignore.concat(ignore)})
      });
    });
    return globTasks;
  }
  var index$18 = function(patterns, opts) {
    var globTasks;
    try {
      globTasks = generateGlobTasks(patterns, opts);
    } catch (err) {
      return Promise$1.reject(err);
    }
    return Promise$1.all(globTasks.map(function(task) {
      return globP(task.pattern, task.opts);
    })).then(function(paths) {
      return arrayUnion.apply(null, paths);
    });
  };
  var sync = function(patterns, opts) {
    var globTasks = generateGlobTasks(patterns, opts);
    return globTasks.reduce(function(matches, task) {
      return arrayUnion(matches, glob.sync(task.pattern, task.opts));
    }, []);
  };
  var generateGlobTasks_1 = generateGlobTasks;
  var hasMagic = function(patterns, opts) {
    return [].concat(patterns).some(function(pattern) {
      return glob.hasMagic(pattern, opts);
    });
  };
  index$18.sync = sync;
  index$18.generateGlobTasks = generateGlobTasks_1;
  index$18.hasMagic = hasMagic;
  var index$42 = function(args, opts) {
    if (!opts)
      opts = {};
    var flags = {
      bools: {},
      strings: {},
      unknownFn: null
    };
    if (typeof opts['unknown'] === 'function') {
      flags.unknownFn = opts['unknown'];
    }
    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function(key) {
        flags.bools[key] = true;
      });
    }
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function(key) {
      aliases[key] = [].concat(opts.alias[key]);
      aliases[key].forEach(function(x) {
        aliases[x] = [key].concat(aliases[key].filter(function(y) {
          return x !== y;
        }));
      });
    });
    [].concat(opts.string).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      if (aliases[key]) {
        flags.strings[aliases[key]] = true;
      }
    });
    var defaults = opts['default'] || {};
    var argv = {_: []};
    Object.keys(flags.bools).forEach(function(key) {
      setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    var notFlags = [];
    if (args.indexOf('--') !== -1) {
      notFlags = args.slice(args.indexOf('--') + 1);
      args = args.slice(0, args.indexOf('--'));
    }
    function argDefined(key, arg) {
      return (flags.allBools && /^--[^=]+$/.test(arg)) || flags.strings[key] || flags.bools[key] || aliases[key];
    }
    function setArg(key, val, arg) {
      if (arg && flags.unknownFn && !argDefined(key, arg)) {
        if (flags.unknownFn(arg) === false)
          return;
      }
      var value = !flags.strings[key] && isNumber(val) ? Number(val) : val;
      setKey(argv, key.split('.'), value);
      (aliases[key] || []).forEach(function(x) {
        setKey(argv, x.split('.'), value);
      });
    }
    function setKey(obj, keys, value) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key) {
        if (o[key] === undefined)
          o[key] = {};
        o = o[key];
      });
      var key = keys[keys.length - 1];
      if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
        o[key] = value;
      } else if (Array.isArray(o[key])) {
        o[key].push(value);
      } else {
        o[key] = [o[key], value];
      }
    }
    function aliasIsBoolean(key) {
      return aliases[key].some(function(x) {
        return flags.bools[x];
      });
    }
    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (/^--.+=/.test(arg)) {
        var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
        var key = m[1];
        var value = m[2];
        if (flags.bools[key]) {
          value = value !== 'false';
        }
        setArg(key, value, arg);
      } else if (/^--no-.+/.test(arg)) {
        var key = arg.match(/^--no-(.+)/)[1];
        setArg(key, false, arg);
      } else if (/^--.+/.test(arg)) {
        var key = arg.match(/^--(.+)/)[1];
        var next = args[i + 1];
        if (next !== undefined && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
          setArg(key, next, arg);
          i++;
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next === 'true', arg);
          i++;
        } else {
          setArg(key, flags.strings[key] ? '' : true, arg);
        }
      } else if (/^-[^-]+/.test(arg)) {
        var letters = arg.slice(1, -1).split('');
        var broken = false;
        for (var j = 0; j < letters.length; j++) {
          var next = arg.slice(j + 2);
          if (next === '-') {
            setArg(letters[j], next, arg);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
            setArg(letters[j], next.split('=')[1], arg);
            broken = true;
            break;
          }
          if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next, arg);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], arg.slice(j + 2), arg);
            broken = true;
            break;
          } else {
            setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
          }
        }
        var key = arg.slice(-1)[0];
        if (!broken && key !== '-') {
          if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, args[i + 1], arg);
            i++;
          } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
            setArg(key, args[i + 1] === 'true', arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? '' : true, arg);
          }
        }
      } else {
        if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
          argv._.push(flags.strings['_'] || !isNumber(arg) ? arg : Number(arg));
        }
        if (opts.stopEarly) {
          argv._.push.apply(argv._, args.slice(i + 1));
          break;
        }
      }
    }
    Object.keys(defaults).forEach(function(key) {
      if (!hasKey(argv, key.split('.'))) {
        setKey(argv, key.split('.'), defaults[key]);
        (aliases[key] || []).forEach(function(x) {
          setKey(argv, x.split('.'), defaults[key]);
        });
      }
    });
    if (opts['--']) {
      argv['--'] = new Array();
      notFlags.forEach(function(key) {
        argv['--'].push(key);
      });
    } else {
      notFlags.forEach(function(key) {
        argv._.push(key);
      });
    }
    return argv;
  };
  function hasKey(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key) {
      o = (o[key] || {});
    });
    var key = keys[keys.length - 1];
    return key in o;
  }
  function isNumber(x) {
    if (typeof x === 'number')
      return true;
    if (/^0x[0-9a-f]+$/i.test(x))
      return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var ignore$1 = function() {
    return new IgnoreBase();
  };
  function make_array(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }
  var REGEX_BLANK_LINE = /^\s+$/;
  var REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\!/;
  var REGEX_LEADING_EXCAPED_HASH = /^\\#/;
  var SLASH = '/';
  var IgnoreBase = function() {
    function IgnoreBase() {
      _classCallCheck(this, IgnoreBase);
      this._rules = [];
      this._initCache();
    }
    _createClass(IgnoreBase, [{
      key: '_initCache',
      value: function _initCache() {
        this._cache = {};
      }
    }, {
      key: 'add',
      value: function add(pattern) {
        this._added = false;
        if (typeof pattern === 'string') {
          pattern = pattern.split(/\r?\n/g);
        }
        make_array(pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
    }, {
      key: 'addPattern',
      value: function addPattern(pattern) {
        return this.add(pattern);
      }
    }, {
      key: '_addPattern',
      value: function _addPattern(pattern) {
        if (pattern instanceof IgnoreBase) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (this._checkPattern(pattern)) {
          var rule = this._createRule(pattern);
          this._added = true;
          this._rules.push(rule);
        }
      }
    }, {
      key: '_checkPattern',
      value: function _checkPattern(pattern) {
        return pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern) && pattern.indexOf('#') !== 0;
      }
    }, {
      key: 'filter',
      value: function filter(paths) {
        var _this = this;
        return make_array(paths).filter(function(path) {
          return _this._filter(path);
        });
      }
    }, {
      key: 'createFilter',
      value: function createFilter() {
        var _this2 = this;
        return function(path) {
          return _this2._filter(path);
        };
      }
    }, {
      key: 'ignores',
      value: function ignores(path) {
        return !this._filter(path);
      }
    }, {
      key: '_createRule',
      value: function _createRule(pattern) {
        var origin = pattern;
        var negative = false;
        if (pattern.indexOf('!') === 0) {
          negative = true;
          pattern = pattern.substr(1);
        }
        pattern = pattern.replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!').replace(REGEX_LEADING_EXCAPED_HASH, '#');
        var regex = make_regex(pattern, negative);
        return {
          origin: origin,
          pattern: pattern,
          negative: negative,
          regex: regex
        };
      }
    }, {
      key: '_filter',
      value: function _filter(path, slices) {
        if (!path) {
          return false;
        }
        if (path in this._cache) {
          return this._cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
          if (slices.length && !slices[0]) {
            slices = slices.slice(1);
            slices[0] = SLASH + slices[0];
          }
        }
        slices.pop();
        return this._cache[path] = slices.length ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path) : this._test(path);
      }
    }, {
      key: '_test',
      value: function _test(path) {
        var matched = 0;
        this._rules.forEach(function(rule) {
          if (!(matched ^ rule.negative)) {
            matched = rule.negative ^ rule.regex.test(path);
          }
        });
        return !matched;
      }
    }]);
    return IgnoreBase;
  }();
  var DEFAULT_REPLACER_PREFIX = [[/\\?\s+$/, function(match) {
    return match.indexOf('\\') === 0 ? ' ' : '';
  }], [/\\\s/g, function() {
    return ' ';
  }], [/[\\\^$.|?*+()\[{]/g, function(match) {
    return '\\' + match;
  }], [/^\//, function() {
    return '^';
  }], [/\//g, function() {
    return '\\/';
  }], [/^\^*\\\*\\\*\\\//, function() {
    return '^(?:.*\\/)?';
  }]];
  var DEFAULT_REPLACER_SUFFIX = [[/^(?=[^\^])/, function() {
    return !/\/(?!$)/.test(this) ? '(?:^|\\/)' : '^';
  }], [/\\\/\\\*\\\*(?=\\\/|$)/g, function(match, index, str) {
    return index + 6 < str.length ? '(?:\\/[^\\/]+)*' : '\\/.+';
  }], [/(^|[^\\]+)\\\*(?=.+)/g, function(match, p1) {
    return p1 + '[^\\/]*';
  }], [/(\^|\\\/)?\\\*$/, function(match, p1) {
    return (p1 ? p1 + '[^/]+' : '[^/]*') + '(?=$|\\/$)';
  }], [/\\\\\\/g, function() {
    return '\\';
  }]];
  var POSITIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [[/(?:[^*\/])$/, function(match) {
    return match + '(?=$|\\/)';
  }]], DEFAULT_REPLACER_SUFFIX);
  var NEGATIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [[/(?:[^*\/])$/, function(match) {
    return match + '(?=$|\\/$)';
  }]], DEFAULT_REPLACER_SUFFIX);
  var cache = {};
  function make_regex(pattern, negative) {
    var r = cache[pattern];
    if (r) {
      return r;
    }
    var replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;
    var source = replacers.reduce(function(prev, current) {
      return prev.replace(current[0], current[1].bind(pattern));
    }, pattern);
    return cache[pattern] = new RegExp(source, 'i');
  }
  if (process.env.IGNORE_TEST_WIN32 || process.platform === 'win32') {
    var filter$1 = IgnoreBase.prototype._filter;
    var make_posix = function make_posix(str) {
      return (/^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/'));
    };
    IgnoreBase.prototype._filter = function(path, slices) {
      path = make_posix(path);
      return filter$1.call(this, path, slices);
    };
  }
  function cleanAST$1(ast) {
    return JSON.stringify(massageAST(ast), null, 2);
  }
  function massageAST(ast) {
    if (Array.isArray(ast)) {
      return ast.map((e) => massageAST(e)).filter((e) => e);
    }
    if (ast && typeof ast === "object") {
      if (ast.type === "EmptyStatement") {
        return undefined;
      }
      if (ast.type === "JSXText") {
        return undefined;
      }
      if (ast.type === "JSXExpressionContainer" && ast.expression.type === "Literal" && ast.expression.value === " ") {
        return undefined;
      }
      const newObj = {};
      for (const key in ast) {
        if (typeof ast[key] !== "function") {
          newObj[key] = massageAST(ast[key]);
        }
      }
      ["loc", "range", "raw", "comments", "leadingComments", "trailingComments", "extra", "start", "end", "tokens", "flags", "raws", "sourceIndex", "id", "source", "before", "after", "trailingComma", "parent", "prev"].forEach((name) => {
        delete newObj[name];
      });
      if (ast.type === "media-query" || ast.type === "media-query-list" || ast.type === "media-feature-expression") {
        delete newObj.value;
      }
      if (ast.type === "css-rule") {
        delete newObj.params;
      }
      if (ast.type === "selector-combinator") {
        newObj.value = newObj.value.replace(/\s+/g, " ");
      }
      if (ast.type === "media-feature") {
        newObj.value = newObj.value.replace(/ /g, "");
      }
      if (ast.type === "value-word" && ast.isColor && ast.isHex) {
        newObj.value = newObj.value.toLowerCase();
      }
      if ((ast.type === "media-feature" || ast.type === "media-type" || ast.type === "media-unknown" || ast.type === "media-value" || ast.type === "selector-attribute" || ast.type === "selector-string" || ast.type === "value-string") && newObj.value) {
        newObj.value = cleanCSSStrings(newObj.value);
      }
      if (ast.type === "css-import" && newObj.importPath) {
        newObj.importPath = cleanCSSStrings(newObj.importPath);
      }
      if (ast.type === "selector-attribute" && newObj.value) {
        newObj.value = newObj.value.replace(/^['"]|['"]$/g, "");
        delete newObj.quoted;
      }
      if ((ast.type === "media-value" || ast.type === "value-number") && newObj.value) {
        newObj.value = newObj.value.replace(/[\d.eE+-]+/g, (match) => {
          const num = Number(match);
          return isNaN(num) ? match : num;
        });
      }
      if (ast.type === "TSParameterProperty" && ast.accessibility === null && !ast.readonly) {
        return {
          type: "Identifier",
          name: ast.parameter.name,
          typeAnnotation: newObj.parameter.typeAnnotation,
          decorators: newObj.decorators
        };
      }
      if (ast.type === "TSNamespaceExportDeclaration" && ast.specifiers && ast.specifiers.length === 0) {
        delete newObj.specifiers;
      }
      if (ast.type === "TSParenthesizedType" && ast.typeAnnotation.type === "TypeAnnotation") {
        return newObj.typeAnnotation.typeAnnotation;
      }
      if (ast.type === "JSXOpeningElement") {
        delete newObj.selfClosing;
      }
      if (ast.type === "JSXElement") {
        delete newObj.closingElement;
      }
      if ((ast.type === "Property" || ast.type === "MethodDefinition" || ast.type === "ClassProperty" || ast.type === "TSPropertySignature" || ast.type === "ObjectTypeProperty") && typeof ast.key === "object" && ast.key && (ast.key.type === "Literal" || ast.key.type === "Identifier")) {
        delete newObj.key;
      }
      if (ast.type === "JSXElement" && ast.openingElement.name.name === "style" && ast.openingElement.attributes.some((attr) => attr.name.name === "jsx")) {
        const templateLiterals = newObj.children.filter((child) => child.type === "JSXExpressionContainer" && child.expression.type === "TemplateLiteral").map((container) => container.expression);
        const quasis = templateLiterals.reduce((quasis, templateLiteral) => quasis.concat(templateLiteral.quasis), []);
        quasis.forEach((q) => delete q.value);
      }
      if (ast.type === "TaggedTemplateExpression" && (ast.tag.type === "MemberExpression" || (ast.tag.type === "Identifier" && (ast.tag.name === "gql" || ast.tag.name === "graphql" || ast.tag.name === "css")) || ast.tag.type === "CallExpression")) {
        newObj.quasi.quasis.forEach((quasi) => delete quasi.value);
      }
      return newObj;
    }
    return ast;
  }
  function cleanCSSStrings(value) {
    return value.replace(/'/g, '"').replace(/\\([^a-fA-F\d])/g, "$1");
  }
  var cleanAst = {
    cleanAST: cleanAST$1,
    massageAST
  };
  var os$2 = os;
  function homedir() {
    var env = process.env;
    var home = env.HOME;
    var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
    if (process.platform === 'win32') {
      return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
    }
    if (process.platform === 'darwin') {
      return home || (user ? '/Users/' + user : null);
    }
    if (process.platform === 'linux') {
      return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));
    }
    return home || null;
  }
  var index$46 = typeof os$2.homedir === 'function' ? os$2.homedir : homedir;
  var fs$5 = require$$0;
  function isDirectory$1(filepath, cb) {
    if (typeof cb !== 'function') {
      throw new Error('expected a callback function');
    }
    if (typeof filepath !== 'string') {
      cb(new Error('expected filepath to be a string'));
      return;
    }
    fs$5.stat(filepath, function(err, stats) {
      if (err) {
        if (err.code === 'ENOENT') {
          cb(null, false);
          return;
        }
        cb(err);
        return;
      }
      cb(null, stats.isDirectory());
    });
  }
  isDirectory$1.sync = function isDirectorySync(filepath) {
    if (typeof filepath !== 'string') {
      throw new Error('expected filepath to be a string');
    }
    try {
      var stat = fs$5.statSync(filepath);
      return stat.isDirectory();
    } catch (err) {
      if (err.code === 'ENOENT') {
        return false;
      } else {
        throw err;
      }
    }
    return false;
  };
  var index$48 = isDirectory$1;
  var fs$6 = require$$0;
  var readFile$1 = function(filepath, options) {
    options = options || {};
    options.throwNotFound = options.throwNotFound || false;
    return new Promise(function(resolve, reject) {
      fs$6.readFile(filepath, 'utf8', function(err, content) {
        if (err && err.code === 'ENOENT' && !options.throwNotFound) {
          return resolve(null);
        }
        if (err)
          return reject(err);
        resolve(content);
      });
    });
  };
  var index$54 = function isArrayish(obj) {
    if (!obj) {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || (obj.length >= 0 && obj.splice instanceof Function);
  };
  var util$3 = util;
  var isArrayish = index$54;
  var errorEx$1 = function errorEx(name, properties) {
    if (!name || name.constructor !== String) {
      properties = name || {};
      name = Error.name;
    }
    var errorExError = function ErrorEXError(message) {
      if (!this) {
        return new ErrorEXError(message);
      }
      message = message instanceof Error ? message.message : (message || this.message);
      Error.call(this, message);
      Error.captureStackTrace(this, errorExError);
      this.name = name;
      Object.defineProperty(this, 'message', {
        configurable: true,
        enumerable: false,
        get: function() {
          var newMessage = message.split(/\r?\n/g);
          for (var key in properties) {
            if (!properties.hasOwnProperty(key)) {
              continue;
            }
            var modifier = properties[key];
            if ('message' in modifier) {
              newMessage = modifier.message(this[key], newMessage) || newMessage;
              if (!isArrayish(newMessage)) {
                newMessage = [newMessage];
              }
            }
          }
          return newMessage.join('\n');
        },
        set: function(v) {
          message = v;
        }
      });
      var stackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');
      var stackGetter = stackDescriptor.get;
      var stackValue = stackDescriptor.value;
      delete stackDescriptor.value;
      delete stackDescriptor.writable;
      stackDescriptor.get = function() {
        var stack = (stackGetter) ? stackGetter.call(this).split(/\r?\n+/g) : stackValue.split(/\r?\n+/g);
        stack[0] = this.name + ': ' + this.message;
        var lineCount = 1;
        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) {
            continue;
          }
          var modifier = properties[key];
          if ('line' in modifier) {
            var line = modifier.line(this[key]);
            if (line) {
              stack.splice(lineCount++, 0, '    ' + line);
            }
          }
          if ('stack' in modifier) {
            modifier.stack(this[key], stack);
          }
        }
        return stack.join('\n');
      };
      Object.defineProperty(this, 'stack', stackDescriptor);
    };
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(errorExError.prototype, Error.prototype);
      Object.setPrototypeOf(errorExError, Error);
    } else {
      util$3.inherits(errorExError, Error);
    }
    return errorExError;
  };
  errorEx$1.append = function(str, def) {
    return {message: function(v, message) {
        v = v || def;
        if (v) {
          message[0] += ' ' + str.replace('%s', v.toString());
        }
        return message;
      }};
  };
  errorEx$1.line = function(str, def) {
    return {line: function(v) {
        v = v || def;
        if (v) {
          return str.replace('%s', v.toString());
        }
        return null;
      }};
  };
  var index$52 = errorEx$1;
  var unicode = createCommonjsModule(function(module) {
    var Uni = module.exports;
    module.exports.isWhiteSpace = function isWhiteSpace(x) {
      return x === '\u0020' || x === '\u00A0' || x === '\uFEFF' || (x >= '\u0009' && x <= '\u000D') || x === '\u1680' || x === '\u180E' || (x >= '\u2000' && x <= '\u200A') || x === '\u2028' || x === '\u2029' || x === '\u202F' || x === '\u205F' || x === '\u3000';
    };
    module.exports.isWhiteSpaceJSON = function isWhiteSpaceJSON(x) {
      return x === '\u0020' || x === '\u0009' || x === '\u000A' || x === '\u000D';
    };
    module.exports.isLineTerminator = function isLineTerminator(x) {
      return x === '\u000A' || x === '\u000D' || x === '\u2028' || x === '\u2029';
    };
    module.exports.isLineTerminatorJSON = function isLineTerminatorJSON(x) {
      return x === '\u000A' || x === '\u000D';
    };
    module.exports.isIdentifierStart = function isIdentifierStart(x) {
      return x === '$' || x === '_' || (x >= 'A' && x <= 'Z') || (x >= 'a' && x <= 'z') || (x >= '\u0080' && Uni.NonAsciiIdentifierStart.test(x));
    };
    module.exports.isIdentifierPart = function isIdentifierPart(x) {
      return x === '$' || x === '_' || (x >= 'A' && x <= 'Z') || (x >= 'a' && x <= 'z') || (x >= '0' && x <= '9') || (x >= '\u0080' && Uni.NonAsciiIdentifierPart.test(x));
    };
    module.exports.NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
    module.exports.NonAsciiIdentifierPart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
  });
  var parse_1 = createCommonjsModule(function(module) {
    var Uni = unicode;
    function isHexDigit(x) {
      return (x >= '0' && x <= '9') || (x >= 'A' && x <= 'F') || (x >= 'a' && x <= 'f');
    }
    function isOctDigit(x) {
      return x >= '0' && x <= '7';
    }
    function isDecDigit(x) {
      return x >= '0' && x <= '9';
    }
    var unescapeMap = {
      '\'': '\'',
      '"': '"',
      '\\': '\\',
      'b': '\b',
      'f': '\f',
      'n': '\n',
      'r': '\r',
      't': '\t',
      'v': '\v',
      '/': '/'
    };
    function formatError(input, msg, position, lineno, column, json5) {
      var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1),
          tmppos = position - column - 1,
          srcline = '',
          underline = '';
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      if (tmppos < position - 70) {
        tmppos = position - 70;
      }
      while (1) {
        var chr = input[++tmppos];
        if (isLineTerminator(chr) || tmppos === input.length) {
          if (position >= tmppos) {
            underline += '^';
          }
          break;
        }
        srcline += chr;
        if (position === tmppos) {
          underline += '^';
        } else if (position > tmppos) {
          underline += input[tmppos] === '\t' ? '\t' : ' ';
        }
        if (srcline.length > 78)
          break;
      }
      return result + '\n' + srcline + '\n' + underline;
    }
    function parse(input, options) {
      var json5 = !(options.mode === 'json' || options.legacy);
      var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;
      var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON;
      var length = input.length,
          lineno = 0,
          linestart = 0,
          position = 0,
          stack = [];
      var tokenStart = function() {};
      var tokenEnd = function(v) {
        return v;
      };
      if (options._tokenize) {
        (function() {
          var start = null;
          tokenStart = function() {
            if (start !== null)
              throw Error('internal error, token overlap');
            start = position;
          };
          tokenEnd = function(v, type) {
            if (start != position) {
              var hash = {
                raw: input.substr(start, position - start),
                type: type,
                stack: stack.slice(0)
              };
              if (v !== undefined)
                hash.value = v;
              options._tokenize.call(null, hash);
            }
            start = null;
            return v;
          };
        })();
      }
      function fail(msg) {
        var column = position - linestart;
        if (!msg) {
          if (position < length) {
            var token = '\'' + JSON.stringify(input[position]).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
            if (!msg)
              msg = 'Unexpected token ' + token;
          } else {
            if (!msg)
              msg = 'Unexpected end of input';
          }
        }
        var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));
        error.row = lineno + 1;
        error.column = column + 1;
        throw error;
      }
      function newline(chr) {
        if (chr === '\r' && input[position] === '\n')
          position++;
        linestart = position;
        lineno++;
      }
      function parseGeneric() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || (chr === '\'' && json5)) {
            return tokenEnd(parseString(chr), 'literal');
          } else if (chr === '{') {
            tokenEnd(undefined, 'separator');
            return parseObject();
          } else if (chr === '[') {
            tokenEnd(undefined, 'separator');
            return parseArray();
          } else if (chr === '-' || chr === '.' || isDecDigit(chr) || (json5 && (chr === '+' || chr === 'I' || chr === 'N'))) {
            return tokenEnd(parseNumber(), 'literal');
          } else if (chr === 'n') {
            parseKeyword('null');
            return tokenEnd(null, 'literal');
          } else if (chr === 't') {
            parseKeyword('true');
            return tokenEnd(true, 'literal');
          } else if (chr === 'f') {
            parseKeyword('false');
            return tokenEnd(false, 'literal');
          } else {
            position--;
            return tokenEnd(undefined);
          }
        }
      }
      function parseKey() {
        var result;
        while (position < length) {
          tokenStart();
          var chr = input[position++];
          if (chr === '"' || (chr === '\'' && json5)) {
            return tokenEnd(parseString(chr), 'key');
          } else if (chr === '{') {
            tokenEnd(undefined, 'separator');
            return parseObject();
          } else if (chr === '[') {
            tokenEnd(undefined, 'separator');
            return parseArray();
          } else if (chr === '.' || isDecDigit(chr)) {
            return tokenEnd(parseNumber(true), 'key');
          } else if (json5 && Uni.isIdentifierStart(chr) || (chr === '\\' && input[position] === 'u')) {
            var rollback = position - 1;
            var result = parseIdentifier();
            if (result === undefined) {
              position = rollback;
              return tokenEnd(undefined);
            } else {
              return tokenEnd(result, 'key');
            }
          } else {
            position--;
            return tokenEnd(undefined);
          }
        }
      }
      function skipWhiteSpace() {
        tokenStart();
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            position--;
            tokenEnd(undefined, 'whitespace');
            tokenStart();
            position++;
            newline(chr);
            tokenEnd(undefined, 'newline');
            tokenStart();
          } else if (isWhiteSpace(chr)) {} else if (chr === '/' && json5 && (input[position] === '/' || input[position] === '*')) {
            position--;
            tokenEnd(undefined, 'whitespace');
            tokenStart();
            position++;
            skipComment(input[position++] === '*');
            tokenEnd(undefined, 'comment');
            tokenStart();
          } else {
            position--;
            break;
          }
        }
        return tokenEnd(undefined, 'whitespace');
      }
      function skipComment(multi) {
        while (position < length) {
          var chr = input[position++];
          if (isLineTerminator(chr)) {
            if (!multi) {
              position--;
              return;
            }
            newline(chr);
          } else if (chr === '*' && multi) {
            if (input[position] === '/') {
              position++;
              return;
            }
          } else {}
        }
        if (multi) {
          fail('Unclosed multiline comment');
        }
      }
      function parseKeyword(keyword) {
        var _pos = position;
        var len = keyword.length;
        for (var i = 1; i < len; i++) {
          if (position >= length || keyword[i] != input[position]) {
            position = _pos - 1;
            fail();
          }
          position++;
        }
      }
      function parseObject() {
        var result = options.null_prototype ? Object.create(null) : {},
            empty_object = {},
            is_non_empty = false;
        while (position < length) {
          skipWhiteSpace();
          var item1 = parseKey();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(undefined, 'separator');
          if (chr === '}' && item1 === undefined) {
            if (!json5 && is_non_empty) {
              position--;
              fail('Trailing comma in object');
            }
            return result;
          } else if (chr === ':' && item1 !== undefined) {
            skipWhiteSpace();
            stack.push(item1);
            var item2 = parseGeneric();
            stack.pop();
            if (item2 === undefined)
              fail('No value found for key ' + item1);
            if (typeof(item1) !== 'string') {
              if (!json5 || typeof(item1) !== 'number') {
                fail('Wrong key type: ' + item1);
              }
            }
            if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') {
              if (options.reserved_keys === 'throw') {
                fail('Reserved key: ' + item1);
              } else {}
            } else {
              if (typeof(options.reviver) === 'function') {
                item2 = options.reviver.call(null, item1, item2);
              }
              if (item2 !== undefined) {
                is_non_empty = true;
                Object.defineProperty(result, item1, {
                  value: item2,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              }
            }
            skipWhiteSpace();
            tokenStart();
            var chr = input[position++];
            tokenEnd(undefined, 'separator');
            if (chr === ',') {
              continue;
            } else if (chr === '}') {
              return result;
            } else {
              fail();
            }
          } else {
            position--;
            fail();
          }
        }
        fail();
      }
      function parseArray() {
        var result = [];
        while (position < length) {
          skipWhiteSpace();
          stack.push(result.length);
          var item = parseGeneric();
          stack.pop();
          skipWhiteSpace();
          tokenStart();
          var chr = input[position++];
          tokenEnd(undefined, 'separator');
          if (item !== undefined) {
            if (typeof(options.reviver) === 'function') {
              item = options.reviver.call(null, String(result.length), item);
            }
            if (item === undefined) {
              result.length++;
              item = true;
            } else {
              result.push(item);
            }
          }
          if (chr === ',') {
            if (item === undefined) {
              fail('Elisions are not supported');
            }
          } else if (chr === ']') {
            if (!json5 && item === undefined && result.length) {
              position--;
              fail('Trailing comma in array');
            }
            return result;
          } else {
            position--;
            fail();
          }
        }
      }
      function parseNumber() {
        position--;
        var start = position,
            chr = input[position++],
            t;
        var to_num = function(is_octal) {
          var str = input.substr(start, position - start);
          if (is_octal) {
            var result = parseInt(str.replace(/^0o?/, ''), 8);
          } else {
            var result = Number(str);
          }
          if (Number.isNaN(result)) {
            position--;
            fail('Bad numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {
            position--;
            fail('Non-json numeric literal - "' + input.substr(start, position - start + 1) + '"');
          } else {
            return result;
          }
        };
        if (chr === '-' || (chr === '+' && json5))
          chr = input[position++];
        if (chr === 'N' && json5) {
          parseKeyword('NaN');
          return NaN;
        }
        if (chr === 'I' && json5) {
          parseKeyword('Infinity');
          return to_num();
        }
        if (chr >= '1' && chr <= '9') {
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        if (chr === '0') {
          chr = input[position++];
          var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr);
          var is_hex = chr === 'x' || chr === 'X';
          if (json5 && (is_octal || is_hex)) {
            while (position < length && (is_hex ? isHexDigit : isOctDigit)(input[position]))
              position++;
            var sign = 1;
            if (input[start] === '-') {
              sign = -1;
              start++;
            } else if (input[start] === '+') {
              start++;
            }
            return sign * to_num(is_octal);
          }
        }
        if (chr === '.') {
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        if (chr === 'e' || chr === 'E') {
          chr = input[position++];
          if (chr === '-' || chr === '+')
            position++;
          while (position < length && isDecDigit(input[position]))
            position++;
          chr = input[position++];
        }
        position--;
        return to_num();
      }
      function parseIdentifier() {
        position--;
        var result = '';
        while (position < length) {
          var chr = input[position++];
          if (chr === '\\' && input[position] === 'u' && isHexDigit(input[position + 1]) && isHexDigit(input[position + 2]) && isHexDigit(input[position + 3]) && isHexDigit(input[position + 4])) {
            chr = String.fromCharCode(parseInt(input.substr(position + 1, 4), 16));
            position += 5;
          }
          if (result.length) {
            if (Uni.isIdentifierPart(chr)) {
              result += chr;
            } else {
              position--;
              return result;
            }
          } else {
            if (Uni.isIdentifierStart(chr)) {
              result += chr;
            } else {
              return undefined;
            }
          }
        }
        fail();
      }
      function parseString(endChar) {
        var result = '';
        while (position < length) {
          var chr = input[position++];
          if (chr === endChar) {
            return result;
          } else if (chr === '\\') {
            if (position >= length)
              fail();
            chr = input[position++];
            if (unescapeMap[chr] && (json5 || (chr != 'v' && chr != "'"))) {
              result += unescapeMap[chr];
            } else if (json5 && isLineTerminator(chr)) {
              newline(chr);
            } else if (chr === 'u' || (chr === 'x' && json5)) {
              var off = chr === 'u' ? 4 : 2;
              for (var i = 0; i < off; i++) {
                if (position >= length)
                  fail();
                if (!isHexDigit(input[position]))
                  fail('Bad escape sequence');
                position++;
              }
              result += String.fromCharCode(parseInt(input.substr(position - off, off), 16));
            } else if (json5 && isOctDigit(chr)) {
              if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position + 1])) {
                var digits = 3;
              } else if (isOctDigit(input[position])) {
                var digits = 2;
              } else {
                var digits = 1;
              }
              position += digits - 1;
              result += String.fromCharCode(parseInt(input.substr(position - digits, digits), 8));
            } else if (json5) {
              result += chr;
            } else {
              position--;
              fail();
            }
          } else if (isLineTerminator(chr)) {
            fail();
          } else {
            if (!json5 && chr.charCodeAt(0) < 32) {
              position--;
              fail('Unexpected control character');
            }
            result += chr;
          }
        }
        fail();
      }
      skipWhiteSpace();
      var return_value = parseGeneric();
      if (return_value !== undefined || position < length) {
        skipWhiteSpace();
        if (position >= length) {
          if (typeof(options.reviver) === 'function') {
            return_value = options.reviver.call(null, '', return_value);
          }
          return return_value;
        } else {
          fail();
        }
      } else {
        if (position) {
          fail('No data, only a whitespace');
        } else {
          fail('No data, empty input');
        }
      }
    }
    module.exports.parse = function parseJSON(input, options) {
      if (typeof(options) === 'function') {
        options = {reviver: options};
      }
      if (input === undefined) {
        return undefined;
      }
      if (typeof(input) !== 'string')
        input = String(input);
      if (options == null)
        options = {};
      if (options.reserved_keys == null)
        options.reserved_keys = 'ignore';
      if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') {
        if (options.null_prototype == null) {
          options.null_prototype = true;
        }
      }
      try {
        return parse(input, options);
      } catch (err) {
        if (err instanceof SyntaxError && err.row != null && err.column != null) {
          var old_err = err;
          err = SyntaxError(old_err.message);
          err.column = old_err.column;
          err.row = old_err.row;
        }
        throw err;
      }
    };
    module.exports.tokenize = function tokenizeJSON(input, options) {
      if (options == null)
        options = {};
      options._tokenize = function(smth) {
        if (options._addstack)
          smth.stack.unshift.apply(smth.stack, options._addstack);
        tokens.push(smth);
      };
      var tokens = [];
      tokens.data = module.exports.parse(input, options);
      return tokens;
    };
  });
  var errorEx = index$52;
  var fallback = parse_1;
  var JSONError = errorEx('JSONError', {fileName: errorEx.append('in %s')});
  var index$50 = function(x, reviver, filename) {
    if (typeof reviver === 'string') {
      filename = reviver;
      reviver = null;
    }
    try {
      try {
        return JSON.parse(x, reviver);
      } catch (err) {
        fallback.parse(x, {
          mode: 'json',
          reviver: reviver
        });
        throw err;
      }
    } catch (err) {
      var jsonErr = new JSONError(err);
      if (filename) {
        jsonErr.fileName = filename;
      }
      throw jsonErr;
    }
  };
  var parseJson$1 = index$50;
  var parseJson_1 = function(json, filepath) {
    try {
      return parseJson$1(json);
    } catch (err) {
      err.message = 'JSON Error in ' + filepath + ':\n' + err.message;
      throw err;
    }
  };
  var path$7 = require$$0$1;
  var readFile = readFile$1;
  var parseJson = parseJson_1;
  var loadPackageProp$1 = function(packageDir, options) {
    var packagePath = path$7.join(packageDir, 'package.json');
    return readFile(packagePath).then(function(content) {
      if (!content)
        return null;
      var parsedContent = parseJson(content, packagePath);
      var packagePropValue = parsedContent[options.packageProp];
      if (!packagePropValue)
        return null;
      return {
        config: packagePropValue,
        filepath: packagePath
      };
    });
  };
  function isNothing(subject) {
    return (typeof subject === 'undefined') || (subject === null);
  }
  function isObject(subject) {
    return (typeof subject === 'object') && (subject !== null);
  }
  function toArray(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend$1(target, source) {
    var index,
        length,
        key,
        sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = '',
        cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
  }
  var isNothing_1 = isNothing;
  var isObject_1 = isObject;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend$1;
  var common$5 = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };
  function YAMLException$2(reason, mark) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = (new Error()).stack || '';
    }
    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
  }
  YAMLException$2.prototype = Object.create(Error.prototype);
  YAMLException$2.prototype.constructor = YAMLException$2;
  YAMLException$2.prototype.toString = function toString(compact) {
    var result = this.name + ': ';
    result += this.reason || '(unknown reason)';
    if (!compact && this.mark) {
      result += ' ' + this.mark.toString();
    }
    return result;
  };
  var exception = YAMLException$2;
  var common$7 = common$5;
  function Mark$1(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  Mark$1.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head,
        start,
        tail,
        end,
        snippet;
    if (!this.buffer)
      return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = '';
    start = this.position;
    while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > (maxLength / 2 - 1)) {
        head = ' ... ';
        start += 5;
        break;
      }
    }
    tail = '';
    end = this.position;
    while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > (maxLength / 2 - 1)) {
        tail = ' ... ';
        end -= 5;
        break;
      }
    }
    snippet = this.buffer.slice(start, end);
    return common$7.repeat(' ', indent) + head + snippet + tail + '\n' + common$7.repeat(' ', indent + this.position - start + head.length) + '^';
  };
  Mark$1.prototype.toString = function toString(compact) {
    var snippet,
        where = '';
    if (this.name) {
      where += 'in "' + this.name + '" ';
    }
    where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += ':\n' + snippet;
      }
    }
    return where;
  };
  var mark$1 = Mark$1;
  var YAMLException$4 = exception;
  var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
  var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
  function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
      Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$2(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException$4('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.tag = tag;
    this.kind = options['kind'] || null;
    this.resolve = options['resolve'] || function() {
      return true;
    };
    this.construct = options['construct'] || function(data) {
      return data;
    };
    this.instanceOf = options['instanceOf'] || null;
    this.predicate = options['predicate'] || null;
    this.represent = options['represent'] || null;
    this.defaultStyle = options['defaultStyle'] || null;
    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException$4('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var type = Type$2;
  var common$8 = common$5;
  var YAMLException$3 = exception;
  var Type$1 = type;
  function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });
      result.push(currentType);
    });
    return result.filter(function(type$$1, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    },
        index,
        length;
    function collectType(type$$1) {
      result[type$$1.kind][type$$1.tag] = result['fallback'][type$$1.tag] = type$$1;
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema$2(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type$$1) {
      if (type$$1.loadKind && type$$1.loadKind !== 'scalar') {
        throw new YAMLException$3('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }
    });
    this.compiledImplicit = compileList(this, 'implicit', []);
    this.compiledExplicit = compileList(this, 'explicit', []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  Schema$2.DEFAULT = null;
  Schema$2.create = function createSchema() {
    var schemas,
        types;
    switch (arguments.length) {
      case 1:
        schemas = Schema$2.DEFAULT;
        types = arguments[0];
        break;
      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;
      default:
        throw new YAMLException$3('Wrong number of arguments for Schema.create function');
    }
    schemas = common$8.toArray(schemas);
    types = common$8.toArray(types);
    if (!schemas.every(function(schema) {
      return schema instanceof Schema$2;
    })) {
      throw new YAMLException$3('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
    }
    if (!types.every(function(type$$1) {
      return type$$1 instanceof Type$1;
    })) {
      throw new YAMLException$3('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
    return new Schema$2({
      include: schemas,
      explicit: types
    });
  };
  var schema = Schema$2;
  var Type$3 = type;
  var str = new Type$3('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function(data) {
      return data !== null ? data : '';
    }
  });
  var Type$4 = type;
  var seq = new Type$4('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  var Type$5 = type;
  var map = new Type$5('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  var Schema$5 = schema;
  var failsafe = new Schema$5({explicit: [str, seq, map]});
  var Type$6 = type;
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max = data.length;
    return (max === 1 && data === '~') || (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var _null = new Type$6('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return '~';
      },
      lowercase: function() {
        return 'null';
      },
      uppercase: function() {
        return 'NULL';
      },
      camelcase: function() {
        return 'Null';
      }
    },
    defaultStyle: 'lowercase'
  });
  var Type$7 = type;
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max = data.length;
    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) || (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
  }
  function constructYamlBoolean(data) {
    return data === 'true' || data === 'True' || data === 'TRUE';
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }
  var bool = new Type$7('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? 'true' : 'false';
      },
      uppercase: function(object) {
        return object ? 'TRUE' : 'FALSE';
      },
      camelcase: function(object) {
        return object ? 'True' : 'False';
      }
    },
    defaultStyle: 'lowercase'
  });
  var common$9 = common$5;
  var Type$8 = type;
  function isHexCode(c) {
    return ((0x30 <= c) && (c <= 0x39)) || ((0x41 <= c) && (c <= 0x46)) || ((0x61 <= c) && (c <= 0x66));
  }
  function isOctCode(c) {
    return ((0x30 <= c) && (c <= 0x37));
  }
  function isDecCode(c) {
    return ((0x30 <= c) && (c <= 0x39));
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;
    if (!max)
      return false;
    ch = data[index];
    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }
    if (ch === '0') {
      if (index + 1 === max)
        return true;
      ch = data[++index];
      if (ch === 'b') {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_')
            continue;
          if (ch !== '0' && ch !== '1')
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }
      if (ch === 'x') {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_')
            continue;
          if (!isHexCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }
      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_')
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
    if (ch === '_')
      return false;
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_')
        continue;
      if (ch === ':')
        break;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === '_')
      return false;
    if (ch !== ':')
      return true;
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data,
        sign = 1,
        ch,
        base,
        digits = [];
    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }
    ch = value[0];
    if (ch === '-' || ch === '+') {
      if (ch === '-')
        sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === '0')
      return 0;
    if (ch === '0') {
      if (value[1] === 'b')
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x')
        return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }
    if (value.indexOf(':') !== -1) {
      value.split(':').forEach(function(v) {
        digits.unshift(parseInt(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += (d * base);
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return (Object.prototype.toString.call(object)) === '[object Number]' && (object % 1 === 0 && !common$9.isNegativeZero(object));
  }
  var int_1 = new Type$8('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(object) {
        return '0b' + object.toString(2);
      },
      octal: function(object) {
        return '0' + object.toString(8);
      },
      decimal: function(object) {
        return object.toString(10);
      },
      hexadecimal: function(object) {
        return '0x' + object.toString(16).toUpperCase();
      }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary: [2, 'bin'],
      octal: [8, 'oct'],
      decimal: [10, 'dec'],
      hexadecimal: [16, 'hex']
    }
  });
  var common$10 = common$5;
  var Type$9 = type;
  var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === '_') {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value,
        sign,
        base,
        digits;
    value = data.replace(/_/g, '').toLowerCase();
    sign = value[0] === '-' ? -1 : 1;
    digits = [];
    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === '.inf') {
      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === '.nan') {
      return NaN;
    } else if (value.indexOf(':') >= 0) {
      value.split(':').forEach(function(v) {
        digits.unshift(parseFloat(v, 10));
      });
      value = 0.0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case 'lowercase':
          return '.nan';
        case 'uppercase':
          return '.NAN';
        case 'camelcase':
          return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase':
          return '.inf';
        case 'uppercase':
          return '.INF';
        case 'camelcase':
          return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase':
          return '-.inf';
        case 'uppercase':
          return '-.INF';
        case 'camelcase':
          return '-.Inf';
      }
    } else if (common$10.isNegativeZero(object)) {
      return '-0.0';
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }
  function isFloat(object) {
    return (Object.prototype.toString.call(object) === '[object Number]') && (object % 1 !== 0 || common$10.isNegativeZero(object));
  }
  var float_1 = new Type$9('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });
  var Schema$4 = schema;
  var json = new Schema$4({
    include: [failsafe],
    implicit: [_null, bool, int_1, float_1]
  });
  var Schema$3 = schema;
  var core = new Schema$3({include: [json]});
  var Type$10 = type;
  var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9])' + '-([0-9][0-9])$');
  var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9]?)' + '-([0-9][0-9]?)' + '(?:[Tt]|[ \\t]+)' + '([0-9][0-9]?)' + ':([0-9][0-9])' + ':([0-9][0-9])' + '(?:\\.([0-9]*))?' + '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + '(?::([0-9][0-9]))?))?$');
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match,
        year,
        month,
        day,
        hour,
        minute,
        second,
        fraction = 0,
        delta = null,
        tz_hour,
        tz_minute,
        date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error('Date resolve error');
    year = +(match[1]);
    month = +(match[2]) - 1;
    day = +(match[3]);
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +(match[4]);
    minute = +(match[5]);
    second = +(match[6]);
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += '0';
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +(match[10]);
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000;
      if (match[9] === '-')
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp = new Type$10('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  var Type$11 = type;
  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }
  var merge = new Type$11('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });
  var NodeBuffer;
  try {
    var _require = commonjsRequire;
    NodeBuffer = _require('buffer').Buffer;
  } catch (__) {}
  var Type$12 = type;
  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code,
        idx,
        bitlen = 0,
        max = data.length,
        map = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return (bitlen % 8) === 0;
  }
  function constructYamlBinary(data) {
    var idx,
        tailbits,
        input = data.replace(/[\r\n=]/g, ''),
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];
    for (idx = 0; idx < max; idx++) {
      if ((idx % 4 === 0) && idx) {
        result.push((bits >> 16) & 0xFF);
        result.push((bits >> 8) & 0xFF);
        result.push(bits & 0xFF);
      }
      bits = (bits << 6) | map.indexOf(input.charAt(idx));
    }
    tailbits = (max % 4) * 6;
    if (tailbits === 0) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push((bits >> 10) & 0xFF);
      result.push((bits >> 2) & 0xFF);
    } else if (tailbits === 12) {
      result.push((bits >> 4) & 0xFF);
    }
    if (NodeBuffer) {
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
  }
  function representYamlBinary(object) {
    var result = '',
        bits = 0,
        idx,
        tail,
        max = object.length,
        map = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if ((idx % 3 === 0) && idx) {
        result += map[(bits >> 18) & 0x3F];
        result += map[(bits >> 12) & 0x3F];
        result += map[(bits >> 6) & 0x3F];
        result += map[bits & 0x3F];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[(bits >> 10) & 0x3F];
      result += map[(bits >> 4) & 0x3F];
      result += map[(bits << 2) & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[(bits >> 2) & 0x3F];
      result += map[(bits << 4) & 0x3F];
      result += map[64];
      result += map[64];
    }
    return result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  var binary = new Type$12('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  var Type$13 = type;
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys = [],
        index,
        length,
        pair,
        pairKey,
        pairHasKey,
        object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== '[object Object]')
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty$1.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var omap = new Type$13('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var Type$14 = type;
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index,
        length,
        pair,
        keys,
        result,
        object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString$1.call(pair) !== '[object Object]')
        return false;
      keys = Object.keys(pair);
      if (keys.length !== 1)
        return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index,
        length,
        pair,
        keys,
        result,
        object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  var pairs = new Type$14('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var Type$15 = type;
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key,
        object = data;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var set = new Type$15('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var Schema$1 = schema;
  var default_safe = new Schema$1({
    include: [core],
    implicit: [timestamp, merge],
    explicit: [binary, omap, pairs, set]
  });
  var Type$16 = type;
  function resolveJavascriptUndefined() {
    return true;
  }
  function constructJavascriptUndefined() {
    return undefined;
  }
  function representJavascriptUndefined() {
    return '';
  }
  function isUndefined(object) {
    return typeof object === 'undefined';
  }
  var _undefined = new Type$16('tag:yaml.org,2002:js/undefined', {
    kind: 'scalar',
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });
  var Type$17 = type;
  function resolveJavascriptRegExp(data) {
    if (data === null)
      return false;
    if (data.length === 0)
      return false;
    var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = '';
    if (regexp[0] === '/') {
      if (tail)
        modifiers = tail[1];
      if (modifiers.length > 3)
        return false;
      if (regexp[regexp.length - modifiers.length - 1] !== '/')
        return false;
    }
    return true;
  }
  function constructJavascriptRegExp(data) {
    var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = '';
    if (regexp[0] === '/') {
      if (tail)
        modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = '/' + object.source + '/';
    if (object.global)
      result += 'g';
    if (object.multiline)
      result += 'm';
    if (object.ignoreCase)
      result += 'i';
    return result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === '[object RegExp]';
  }
  var regexp = new Type$17('tag:yaml.org,2002:js/regexp', {
    kind: 'scalar',
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });
  var esprima;
  try {
    var _require$1 = commonjsRequire;
    esprima = _require$1('esprima');
  } catch (_) {
    if (typeof window !== 'undefined')
      esprima = window.esprima;
  }
  var Type$18 = type;
  function resolveJavascriptFunction(data) {
    if (data === null)
      return false;
    try {
      var source = '(' + data + ')',
          ast = esprima.parse(source, {range: true});
      if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  function constructJavascriptFunction(data) {
    var source = '(' + data + ')',
        ast = esprima.parse(source, {range: true}),
        params = [],
        body;
    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
      throw new Error('Failed to resolve function');
    }
    ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction(object) {
    return Object.prototype.toString.call(object) === '[object Function]';
  }
  var _function = new Type$18('tag:yaml.org,2002:js/function', {
    kind: 'scalar',
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });
  var Schema$6 = schema;
  var default_full = Schema$6.DEFAULT = new Schema$6({
    include: [default_safe],
    explicit: [_undefined, regexp, _function]
  });
  var common$4 = common$5;
  var YAMLException$1 = exception;
  var Mark = mark$1;
  var DEFAULT_SAFE_SCHEMA$1 = default_safe;
  var DEFAULT_FULL_SCHEMA$1 = default_full;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function is_EOL(c) {
    return (c === 0x0A) || (c === 0x0D);
  }
  function is_WHITE_SPACE(c) {
    return (c === 0x09) || (c === 0x20);
  }
  function is_WS_OR_EOL(c) {
    return (c === 0x09) || (c === 0x20) || (c === 0x0A) || (c === 0x0D);
  }
  function is_FLOW_INDICATOR(c) {
    return c === 0x2C || c === 0x5B || c === 0x5D || c === 0x7B || c === 0x7D;
  }
  function fromHexCode(c) {
    var lc;
    if ((0x30 <= c) && (c <= 0x39)) {
      return c - 0x30;
    }
    lc = c | 0x20;
    if ((0x61 <= lc) && (lc <= 0x66)) {
      return lc - 0x61 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 0x78) {
      return 2;
    }
    if (c === 0x75) {
      return 4;
    }
    if (c === 0x55) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if ((0x30 <= c) && (c <= 0x39)) {
      return c - 0x30;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return (c === 0x30) ? '\x00' : (c === 0x61) ? '\x07' : (c === 0x62) ? '\x08' : (c === 0x74) ? '\x09' : (c === 0x09) ? '\x09' : (c === 0x6E) ? '\x0A' : (c === 0x76) ? '\x0B' : (c === 0x66) ? '\x0C' : (c === 0x72) ? '\x0D' : (c === 0x65) ? '\x1B' : (c === 0x20) ? ' ' : (c === 0x22) ? '\x22' : (c === 0x2F) ? '/' : (c === 0x5C) ? '\x5C' : (c === 0x4E) ? '\x85' : (c === 0x5F) ? '\xA0' : (c === 0x4C) ? '\u2028' : (c === 0x50) ? '\u2029' : '';
  }
  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800, ((c - 0x010000) & 0x03FF) + 0xDC00);
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  function State(input, options) {
    this.input = input;
    this.filename = options['filename'] || null;
    this.schema = options['schema'] || DEFAULT_FULL_SCHEMA$1;
    this.onWarning = options['onWarning'] || null;
    this.legacy = options['legacy'] || false;
    this.json = options['json'] || false;
    this.listener = options['listener'] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException$1(message, new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match,
          major,
          minor;
      if (state.version !== null) {
        throwError(state, 'duplication of %YAML directive');
      }
      if (args.length !== 1) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, 'unacceptable YAML version of the document');
      }
      state.version = args[0];
      state.checkLineBreaks = (minor < 2);
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle,
          prefix;
      if (args.length !== 2) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position,
        _length,
        _character,
        _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 0x09 || (0x20 <= _character && _character <= 0x10FFFF))) {
            throwError(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, 'the stream contains non-printable characters');
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys,
        key,
        index,
        quantity;
    if (!common$4.isObject(source)) {
      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index,
        quantity;
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, 'duplicated mapping key');
      }
      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x0A) {
      state.position++;
    } else if (ch === 0x0D) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A) {
        state.position++;
      }
    } else {
      throwError(state, 'a line break is expected');
    }
    state.line += 1;
    state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 0x23) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A && ch !== 0x0D && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 0x20) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 0x2D || ch === 0x2E) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common$4.repeat('\n', count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 || ch === 0x26 || ch === 0x2A || ch === 0x21 || ch === 0x7C || ch === 0x3E || ch === 0x27 || ch === 0x22 || ch === 0x25 || ch === 0x40 || ch === 0x60) {
      return false;
    }
    if (ch === 0x3F || ch === 0x2D) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 0x3A) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 0x23) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch,
        captureStart,
        captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x27) {
      return false;
    }
    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x27) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a single quoted scalar');
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, 'unexpected end of the stream within a single quoted scalar');
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexResult,
        tmp,
        ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x22) {
      return false;
    }
    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 0x5C) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, 'unknown escape sequence');
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a double quoted scalar');
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, 'unexpected end of the stream within a double quoted scalar');
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _tag = state.tag,
        _result,
        _anchor = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = {},
        keyNode,
        keyTag,
        valueNode,
        ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5B) {
      terminator = 0x5D;
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B) {
      terminator = 0x7D;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, 'missed comma between flow collection entries');
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 0x3F) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 0x3A) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 0x2C) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, 'unexpected end of the stream within a flow collection');
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent = nodeIndent,
        emptyLines = 0,
        atMoreIndented = false,
        tmp,
        ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7C) {
      folding = false;
    } else if (ch === 0x3E) {
      folding = true;
    } else {
      return false;
    }
    state.kind = 'scalar';
    state.result = '';
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 0x2B || ch === 0x2D) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (ch === 0x2B) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, 'repeat of an indentation width identifier');
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 0x23) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && (ch !== 0));
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && (ch === 0x20)) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common$4.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += '\n';
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common$4.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common$4.repeat('\n', emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += ' ';
          }
        } else {
          state.result += common$4.repeat('\n', emptyLines);
        }
      } else {
        state.result += common$4.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && (ch !== 0)) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = [],
        following,
        detected = false,
        ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (ch !== 0x2D) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _pos,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = {},
        overridableKeys = {},
        keyTag = null,
        keyNode = null,
        valueNode = null,
        atExplicitKey = false,
        detected = false,
        ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      _pos = state.position;
      if ((ch === 0x3F || ch === 0x3A) && is_WS_OR_EOL(following)) {
        if (ch === 0x3F) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, 'incomplete explicit mapping pair; a key node is missed');
        }
        state.position += 1;
        ch = following;
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 0x3A) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, 'can not read an implicit mapping pair; a colon is missed');
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else {
        break;
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if (state.lineIndent > nodeIndent && (ch !== 0)) {
        throwError(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed = false,
        tagHandle,
        tagName,
        ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21)
      return false;
    if (state.tag !== null) {
      throwError(state, 'duplication of a tag property');
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x3C) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = '!';
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 0x3E);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 0x21) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, 'tag suffix cannot contain flow indicator characters');
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;
    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position,
        ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26)
      return false;
    if (state.anchor !== null) {
      throwError(state, 'duplication of an anchor property');
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, 'name of an anchor node must contain at least one character');
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position,
        alias,
        ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A)
      return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, 'name of an alias node must contain at least one character');
    }
    alias = state.input.slice(_position, state.position);
    if (!state.anchorMap.hasOwnProperty(alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1,
        atNewLine = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        type,
        flowIndent,
        blockIndent;
    if (state.listener !== null) {
      state.listener('open', state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, 'alias node should not have any properties');
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = '?';
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag !== null && state.tag !== '!') {
      if (state.tag === '?') {
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result)) {
          throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
        } else {
          state.result = type.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, 'unknown tag !<' + state.tag + '>');
      }
    }
    if (state.listener !== null) {
      state.listener('close', state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 0x25) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, 'directive name must not be less than one character in length');
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 0x23) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0)
        readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D && state.input.charCodeAt(state.position + 1) === 0x2D && state.input.charCodeAt(state.position + 2) === 0x2D) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, 'directives end mark is expected');
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 0x2E) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < (state.length - 1)) {
      throwError(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 0x0A && input.charCodeAt(input.length - 1) !== 0x0D) {
        input += '\n';
      }
      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options);
    state.input += '\0';
    while (state.input.charCodeAt(state.position) === 0x20) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < (state.length - 1)) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll$1(input, iterator, options) {
    var documents = loadDocuments(input, options),
        index,
        length;
    for (index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException$1('expected a single document in the stream, but found more');
  }
  function safeLoadAll$1(input, output, options) {
    loadAll$1(input, output, common$4.extend({schema: DEFAULT_SAFE_SCHEMA$1}, options));
  }
  function safeLoad$1(input, options) {
    return load$1(input, common$4.extend({schema: DEFAULT_SAFE_SCHEMA$1}, options));
  }
  var loadAll_1 = loadAll$1;
  var load_1 = load$1;
  var safeLoadAll_1 = safeLoadAll$1;
  var safeLoad_1 = safeLoad$1;
  var loader$1 = {
    loadAll: loadAll_1,
    load: load_1,
    safeLoadAll: safeLoadAll_1,
    safeLoad: safeLoad_1
  };
  var common$11 = common$5;
  var YAMLException$5 = exception;
  var DEFAULT_FULL_SCHEMA$2 = default_full;
  var DEFAULT_SAFE_SCHEMA$2 = default_safe;
  var _toString$2 = Object.prototype.toString;
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var CHAR_TAB = 0x09;
  var CHAR_LINE_FEED = 0x0A;
  var CHAR_SPACE = 0x20;
  var CHAR_EXCLAMATION = 0x21;
  var CHAR_DOUBLE_QUOTE = 0x22;
  var CHAR_SHARP = 0x23;
  var CHAR_PERCENT = 0x25;
  var CHAR_AMPERSAND = 0x26;
  var CHAR_SINGLE_QUOTE = 0x27;
  var CHAR_ASTERISK = 0x2A;
  var CHAR_COMMA = 0x2C;
  var CHAR_MINUS = 0x2D;
  var CHAR_COLON = 0x3A;
  var CHAR_GREATER_THAN = 0x3E;
  var CHAR_QUESTION = 0x3F;
  var CHAR_COMMERCIAL_AT = 0x40;
  var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
  var CHAR_GRAVE_ACCENT = 0x60;
  var CHAR_LEFT_CURLY_BRACKET = 0x7B;
  var CHAR_VERTICAL_LINE = 0x7C;
  var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0x00] = '\\0';
  ESCAPE_SEQUENCES[0x07] = '\\a';
  ESCAPE_SEQUENCES[0x08] = '\\b';
  ESCAPE_SEQUENCES[0x09] = '\\t';
  ESCAPE_SEQUENCES[0x0A] = '\\n';
  ESCAPE_SEQUENCES[0x0B] = '\\v';
  ESCAPE_SEQUENCES[0x0C] = '\\f';
  ESCAPE_SEQUENCES[0x0D] = '\\r';
  ESCAPE_SEQUENCES[0x1B] = '\\e';
  ESCAPE_SEQUENCES[0x22] = '\\"';
  ESCAPE_SEQUENCES[0x5C] = '\\\\';
  ESCAPE_SEQUENCES[0x85] = '\\N';
  ESCAPE_SEQUENCES[0xA0] = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';
  var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];
  function compileStyleMap(schema, map) {
    var result,
        keys,
        index,
        length,
        tag,
        style,
        type;
    if (map === null)
      return {};
    result = {};
    keys = Object.keys(map);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);
      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }
      type = schema.compiledTypeMap['fallback'][tag];
      if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string,
        handle,
        length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new YAMLException$5('code point within a string may not be greater than 0xFFFFFFFF');
    }
    return '\\' + handle + common$11.repeat('0', length - string.length) + string;
  }
  function State$1(options) {
    this.schema = options['schema'] || DEFAULT_FULL_SCHEMA$2;
    this.indent = Math.max(1, (options['indent'] || 2));
    this.skipInvalid = options['skipInvalid'] || false;
    this.flowLevel = (common$11.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys = options['sortKeys'] || false;
    this.lineWidth = options['lineWidth'] || 80;
    this.noRefs = options['noRefs'] || false;
    this.noCompatMode = options['noCompatMode'] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = '';
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common$11.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;
    while (position < length) {
      next = string.indexOf('\n', position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== '\n')
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return '\n' + common$11.repeat(' ', state.indent * level);
  }
  function testImplicitResolving(state, str) {
    var index,
        length,
        type;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];
      if (type.resolve(str)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return (0x00020 <= c && c <= 0x00007E) || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029) || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF) || (0x10000 <= c && c <= 0x10FFFF);
  }
  function isPlainSafe(c) {
    return isPrintable(c) && c !== 0xFEFF && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) {
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char);
      }
    } else {
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ');
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char);
      }
      hasFoldableLine = hasFoldableLine || (shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' '));
    }
    if (!hasLineBreak && !hasFoldableLine) {
      return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    if (string[0] === ' ' && indentPerLevel > 9) {
      return STYLE_DOUBLE;
    }
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = (function() {
      if (string.length === 0) {
        return "''";
      }
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || (state.flowLevel > -1 && level >= state.flowLevel);
      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string, lineWidth) + '"';
        default:
          throw new YAMLException$5('impossible error: invalid scalar style');
      }
    }());
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = (string[0] === ' ') ? String(indentPerLevel) : '';
    var clip = string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : (clip ? '' : '-');
    return indentIndicator + chomp + '\n';
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = (function() {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }());
    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented;
    var match;
    while ((match = lineRe.exec(string))) {
      var prefix = match[1],
          line = match[2];
      moreIndented = (line[0] === ' ');
      result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === '' || line[0] === ' ')
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0,
        end,
        curr = 0,
        next = 0;
    var result = '';
    while ((match = breakRe.exec(line))) {
      next = match.index;
      if (next - start > width) {
        end = (curr > start) ? curr : next;
        result += '\n' + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += '\n';
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = '';
    var char;
    var escapeSeq;
    for (var i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag = state.tag,
        index,
        length;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (writeNode(state, level, object[index], false, false)) {
        if (index !== 0)
          _result += ', ';
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag = state.tag,
        index,
        length;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || '[]';
  }
  function writeFlowMapping(state, level, object) {
    var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';
      if (index !== 0)
        pairBuffer += ', ';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += '? ';
      pairBuffer += state.dump + ': ';
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException$5('sortKeys must be a boolean or a function');
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';
      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = (state.tag !== null && state.tag !== '?') || (state.dump && state.dump.length > 1024);
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || '{}';
  }
  function detectType(state, object, explicit) {
    var _result,
        typeList,
        index,
        length,
        type,
        style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];
      if ((type.instanceOf || type.predicate) && (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) && (!type.predicate || type.predicate(object))) {
        state.tag = explicit ? type.tag : '?';
        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;
          if (_toString$2.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty$3.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new YAMLException$5('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type = _toString$2.call(state.dump);
    if (block) {
      block = (state.flowLevel < 0 || state.flowLevel > level);
    }
    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === '[object Object]') {
        if (block && (Object.keys(state.dump).length !== 0)) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        if (block && (state.dump.length !== 0)) {
          writeBlockSequence(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException$5('unacceptable kind of an object to dump ' + type);
      }
      if (state.tag !== null && state.tag !== '?') {
        state.dump = '!<' + state.tag + '> ' + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList,
        index,
        length;
    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump$1(input, options) {
    options = options || {};
    var state = new State$1(options);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true))
      return state.dump + '\n';
    return '';
  }
  function safeDump$1(input, options) {
    return dump$1(input, common$11.extend({schema: DEFAULT_SAFE_SCHEMA$2}, options));
  }
  var dump_1 = dump$1;
  var safeDump_1 = safeDump$1;
  var dumper$1 = {
    dump: dump_1,
    safeDump: safeDump_1
  };
  var loader = loader$1;
  var dumper = dumper$1;
  function deprecated(name) {
    return function() {
      throw new Error('Function ' + name + ' is deprecated and cannot be used.');
    };
  }
  var Type = type;
  var Schema = schema;
  var FAILSAFE_SCHEMA = failsafe;
  var JSON_SCHEMA = json;
  var CORE_SCHEMA = core;
  var DEFAULT_SAFE_SCHEMA = default_safe;
  var DEFAULT_FULL_SCHEMA = default_full;
  var load = loader.load;
  var loadAll = loader.loadAll;
  var safeLoad = loader.safeLoad;
  var safeLoadAll = loader.safeLoadAll;
  var dump = dumper.dump;
  var safeDump = dumper.safeDump;
  var YAMLException = exception;
  var MINIMAL_SCHEMA = failsafe;
  var SAFE_SCHEMA = default_safe;
  var DEFAULT_SCHEMA = default_full;
  var scan = deprecated('scan');
  var parse$2 = deprecated('parse');
  var compose = deprecated('compose');
  var addConstructor = deprecated('addConstructor');
  var jsYaml = {
    Type: Type,
    Schema: Schema,
    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
    JSON_SCHEMA: JSON_SCHEMA,
    CORE_SCHEMA: CORE_SCHEMA,
    DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
    DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
    load: load,
    loadAll: loadAll,
    safeLoad: safeLoad,
    safeLoadAll: safeLoadAll,
    dump: dump,
    safeDump: safeDump,
    YAMLException: YAMLException,
    MINIMAL_SCHEMA: MINIMAL_SCHEMA,
    SAFE_SCHEMA: SAFE_SCHEMA,
    DEFAULT_SCHEMA: DEFAULT_SCHEMA,
    scan: scan,
    parse: parse$2,
    compose: compose,
    addConstructor: addConstructor
  };
  var yaml$1 = jsYaml;
  var index$56 = yaml$1;
  var index$58 = createCommonjsModule(function(module) {
    'use strict';
    var Module = module$1;
    var path = require$$0$1;
    module.exports = function requireFromString(code, filename, opts) {
      if (typeof filename === 'object') {
        opts = filename;
        filename = undefined;
      }
      opts = opts || {};
      filename = filename || '';
      opts.appendPaths = opts.appendPaths || [];
      opts.prependPaths = opts.prependPaths || [];
      if (typeof code !== 'string') {
        throw new Error('code must be a string, not ' + typeof code);
      }
      var paths = Module._nodeModulePaths(path.dirname(filename));
      var m = new Module(filename, module.parent);
      m.filename = filename;
      m.paths = [].concat(opts.prependPaths).concat(paths).concat(opts.appendPaths);
      m._compile(code, filename);
      return m.exports;
    };
  });
  var yaml = index$56;
  var requireFromString = index$58;
  var readFile$3 = readFile$1;
  var parseJson$2 = parseJson_1;
  var loadRc$1 = function(filepath, options) {
    return loadExtensionlessRc().then(function(result) {
      if (result)
        return result;
      if (options.rcExtensions)
        return loadRcWithExtensions();
      return null;
    });
    function loadExtensionlessRc() {
      return readRcFile().then(function(content) {
        if (!content)
          return null;
        var pasedConfig = (options.rcStrictJson) ? parseJson$2(content, filepath) : yaml.safeLoad(content, {filename: filepath});
        return {
          config: pasedConfig,
          filepath: filepath
        };
      });
    }
    function loadRcWithExtensions() {
      return readRcFile('json').then(function(content) {
        if (content) {
          var successFilepath = filepath + '.json';
          return {
            config: parseJson$2(content, successFilepath),
            filepath: successFilepath
          };
        }
        return readRcFile('yaml');
      }).then(function(content) {
        if (content) {
          if (content.config)
            return content;
          var successFilepath = filepath + '.yaml';
          return {
            config: yaml.safeLoad(content, {filename: successFilepath}),
            filepath: successFilepath
          };
        }
        return readRcFile('yml');
      }).then(function(content) {
        if (content) {
          if (content.config)
            return content;
          var successFilepath = filepath + '.yml';
          return {
            config: yaml.safeLoad(content, {filename: successFilepath}),
            filepath: successFilepath
          };
        }
        return readRcFile('js');
      }).then(function(content) {
        if (content) {
          if (content.config)
            return content;
          var successFilepath = filepath + '.js';
          return {
            config: requireFromString(content, successFilepath),
            filepath: successFilepath
          };
        }
        return null;
      });
    }
    function readRcFile(extension) {
      var filepathWithExtension = (extension) ? filepath + '.' + extension : filepath;
      return readFile$3(filepathWithExtension);
    }
  };
  var requireFromString$1 = index$58;
  var readFile$4 = readFile$1;
  var loadJs$1 = function(filepath) {
    return readFile$4(filepath).then(function(content) {
      if (!content)
        return null;
      return {
        config: requireFromString$1(content, filepath),
        filepath: filepath
      };
    });
  };
  var yaml$2 = index$56;
  var requireFromString$2 = index$58;
  var readFile$5 = readFile$1;
  var parseJson$3 = parseJson_1;
  var loadDefinedFile$1 = function(filepath, options) {
    return readFile$5(filepath, {throwNotFound: true}).then(function(content) {
      var parsedConfig = (function() {
        switch (options.format) {
          case 'json':
            return parseJson$3(content, filepath);
          case 'yaml':
            return yaml$2.safeLoad(content, {filename: filepath});
          case 'js':
            return requireFromString$2(content, filepath);
          default:
            return tryAllParsing(content, filepath);
        }
      })();
      if (!parsedConfig) {
        throw new Error('Failed to parse "' + filepath + '" as JSON, JS, or YAML.');
      }
      return {
        config: parsedConfig,
        filepath: filepath
      };
    });
  };
  function tryAllParsing(content, filepath) {
    return tryYaml(content, filepath, function() {
      return tryRequire(content, filepath, function() {
        return null;
      });
    });
  }
  function tryYaml(content, filepath, cb) {
    try {
      var result = yaml$2.safeLoad(content, {filename: filepath});
      if (typeof result === 'string') {
        return cb();
      }
      return result;
    } catch (e) {
      return cb();
    }
  }
  function tryRequire(content, filepath, cb) {
    try {
      return requireFromString$2(content, filepath);
    } catch (e) {
      return cb();
    }
  }
  var path$6 = require$$0$1;
  var isDir = index$48;
  var loadPackageProp = loadPackageProp$1;
  var loadRc = loadRc$1;
  var loadJs = loadJs$1;
  var loadDefinedFile = loadDefinedFile$1;
  var createExplorer$1 = function(options) {
    var fileCache = (options.cache) ? new Map() : null;
    var directoryCache = (options.cache) ? new Map() : null;
    var transform = options.transform || identityPromise;
    function clearFileCache() {
      if (fileCache)
        fileCache.clear();
    }
    function clearDirectoryCache() {
      if (directoryCache)
        directoryCache.clear();
    }
    function clearCaches() {
      clearFileCache();
      clearDirectoryCache();
    }
    function load(searchPath, configPath) {
      if (!configPath && options.configPath) {
        configPath = options.configPath;
      }
      if (configPath) {
        var absoluteConfigPath = path$6.resolve(process.cwd(), configPath);
        if (fileCache && fileCache.has(absoluteConfigPath)) {
          return fileCache.get(absoluteConfigPath);
        }
        var result = loadDefinedFile(absoluteConfigPath, options).then(transform);
        if (fileCache)
          fileCache.set(absoluteConfigPath, result);
        return result;
      }
      if (!searchPath)
        return Promise.resolve(null);
      var absoluteSearchPath = path$6.resolve(process.cwd(), searchPath);
      return isDirectory(absoluteSearchPath).then(function(searchPathIsDirectory) {
        var directory = (searchPathIsDirectory) ? absoluteSearchPath : path$6.dirname(absoluteSearchPath);
        return searchDirectory(directory);
      });
    }
    function searchDirectory(directory) {
      if (directoryCache && directoryCache.has(directory)) {
        return directoryCache.get(directory);
      }
      var result = Promise.resolve().then(function() {
        if (!options.packageProp)
          return;
        return loadPackageProp(directory, options);
      }).then(function(result) {
        if (result || !options.rc)
          return result;
        return loadRc(path$6.join(directory, options.rc), options);
      }).then(function(result) {
        if (result || !options.js)
          return result;
        return loadJs(path$6.join(directory, options.js));
      }).then(function(result) {
        if (result)
          return result;
        var splitPath = directory.split(path$6.sep);
        var nextDirectory = (splitPath.length > 1) ? splitPath.slice(0, -1).join(path$6.sep) : null;
        if (!nextDirectory || directory === options.stopDir)
          return null;
        return searchDirectory(nextDirectory);
      }).then(transform);
      if (directoryCache)
        directoryCache.set(directory, result);
      return result;
    }
    return {
      load: load,
      clearFileCache: clearFileCache,
      clearDirectoryCache: clearDirectoryCache,
      clearCaches: clearCaches
    };
  };
  function isDirectory(filepath) {
    return new Promise(function(resolve, reject) {
      return isDir(filepath, function(err, dir) {
        if (err)
          return reject(err);
        return resolve(dir);
      });
    });
  }
  function identityPromise(x) {
    return Promise.resolve(x);
  }
  var path$5 = require$$0$1;
  var oshomedir = index$46;
  var minimist$1 = index$42;
  var assign = index$28;
  var createExplorer = createExplorer$1;
  var parsedCliArgs = minimist$1(process.argv);
  var index$44 = function(moduleName, options) {
    options = assign({
      packageProp: moduleName,
      rc: '.' + moduleName + 'rc',
      js: moduleName + '.config.js',
      argv: 'config',
      rcStrictJson: false,
      stopDir: oshomedir(),
      cache: true
    }, options);
    if (options.argv && parsedCliArgs[options.argv]) {
      options.configPath = path$5.resolve(parsedCliArgs[options.argv]);
    }
    return createExplorer(options);
  };
  const cosmiconfig = index$44;
  const minimatch$4 = minimatch_1;
  const withCache = cosmiconfig("prettier");
  const noCache = cosmiconfig("prettier", {cache: false});
  function resolveConfig$1(filePath, opts) {
    const useCache = !(opts && opts.useCache === false);
    return (useCache ? withCache : noCache).load(filePath).then((result) => {
      if (!result) {
        return null;
      }
      return mergeOverrides(result.config, filePath);
    });
  }
  function clearCache() {
    withCache.clearCaches();
  }
  function resolveConfigFile(filePath) {
    return noCache.load(filePath).then((result) => {
      if (result) {
        return result.filepath;
      }
      return null;
    });
  }
  function mergeOverrides(config, filePath) {
    const options = Object.assign({}, config);
    if (filePath && options.overrides) {
      for (const override of options.overrides) {
        if (pathMatchesGlobs(filePath, override.files, override.excludeFiles)) {
          Object.assign(options, override.options);
        }
      }
    }
    delete options.overrides;
    return options;
  }
  function pathMatchesGlobs(filePath, patterns, excludedPatterns) {
    const patternList = [].concat(patterns);
    const excludedPatternList = [].concat(excludedPatterns || []);
    const opts = {matchBase: true};
    return (patternList.some((pattern) => minimatch$4(filePath, pattern, opts)) && !excludedPatternList.some((excludedPattern) => minimatch$4(filePath, excludedPattern, opts)));
  }
  var resolveConfig_1 = {
    resolveConfig: resolveConfig$1,
    resolveConfigFile,
    clearCache
  };
  var base = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports['default'] = Diff;
    function Diff() {}
    Diff.prototype = {
      diff: function diff(oldString, newString) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
        var callback = options.callback;
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        this.options = options;
        var self = this;
        function done(value) {
          if (callback) {
            setTimeout(function() {
              callback(undefined, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length,
            oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0;
            var addPath = bestPath[diagonalPath - 1],
                removePath = bestPath[diagonalPath + 1],
                _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = undefined;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen,
                canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = undefined;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self.pushComponent(basePath.components, undefined, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self.pushComponent(basePath.components, true, undefined);
            }
            _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added: added,
            removed: removed
          };
        } else {
          components.push({
            count: 1,
            added: added,
            removed: removed
          });
        }
      },
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath,
            commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({count: commonCount});
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      equals: function equals(left, right) {
        return left === right;
      },
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      castInput: function castInput(value) {
        return value;
      },
      tokenize: function tokenize(value) {
        return value.split('');
      },
      join: function join(chars) {
        return chars.join('');
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0,
          componentLen = components.length,
          newPos = 0,
          oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value.length ? oldValue : value;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
  });
  var character = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.characterDiff = undefined;
    exports.diffChars = diffChars;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var characterDiff = exports.characterDiff = new _base2['default']();
    function diffChars(oldStr, newStr, callback) {
      return characterDiff.diff(oldStr, newStr, callback);
    }
  });
  var params = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.generateOptions = generateOptions;
    function generateOptions(options, defaults) {
      if (typeof options === 'function') {
        defaults.callback = options;
      } else if (options) {
        for (var name in options) {
          if (options.hasOwnProperty(name)) {
            defaults[name] = options[name];
          }
        }
      }
      return defaults;
    }
  });
  var word = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.wordDiff = undefined;
    exports.diffWords = diffWords;
    exports.diffWordsWithSpace = diffWordsWithSpace;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    var _params = params;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = exports.wordDiff = new _base2['default']();
    wordDiff.equals = function(left, right) {
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function(value) {
      var tokens = value.split(/(\s+|\b)/);
      for (var i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
    function diffWords(oldStr, newStr, callback) {
      var options = (0, _params.generateOptions)(callback, {ignoreWhitespace: true});
      return wordDiff.diff(oldStr, newStr, options);
    }
    function diffWordsWithSpace(oldStr, newStr, callback) {
      return wordDiff.diff(oldStr, newStr, callback);
    }
  });
  var line = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.lineDiff = undefined;
    exports.diffLines = diffLines;
    exports.diffTrimmedLines = diffTrimmedLines;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    var _params = params;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var lineDiff = exports.lineDiff = new _base2['default']();
    lineDiff.tokenize = function(value) {
      var retLines = [],
          linesAndNewlines = value.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }
      return retLines;
    };
    function diffLines(oldStr, newStr, callback) {
      return lineDiff.diff(oldStr, newStr, callback);
    }
    function diffTrimmedLines(oldStr, newStr, callback) {
      var options = (0, _params.generateOptions)(callback, {ignoreWhitespace: true});
      return lineDiff.diff(oldStr, newStr, options);
    }
  });
  var sentence = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.sentenceDiff = undefined;
    exports.diffSentences = diffSentences;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var sentenceDiff = exports.sentenceDiff = new _base2['default']();
    sentenceDiff.tokenize = function(value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function diffSentences(oldStr, newStr, callback) {
      return sentenceDiff.diff(oldStr, newStr, callback);
    }
  });
  var css = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.cssDiff = undefined;
    exports.diffCss = diffCss;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var cssDiff = exports.cssDiff = new _base2['default']();
    cssDiff.tokenize = function(value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    function diffCss(oldStr, newStr, callback) {
      return cssDiff.diff(oldStr, newStr, callback);
    }
  });
  var json$2 = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.jsonDiff = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    exports.diffJson = diffJson;
    exports.canonicalize = canonicalize;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    var _line = line;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = exports.jsonDiff = new _base2['default']();
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = _line.lineDiff.tokenize;
    jsonDiff.castInput = function(value) {
      var undefinedReplacement = this.options.undefinedReplacement;
      return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function(k, v) {
        if (typeof v === 'undefined') {
          return undefinedReplacement;
        }
        return v;
      }, '  ');
    };
    jsonDiff.equals = function(left, right) {
      return (_base2['default'].prototype.equals(left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1')));
    };
    function diffJson(oldObj, newObj, options) {
      return jsonDiff.diff(oldObj, newObj, options);
    }
    function canonicalize(obj, stack, replacementStack) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      var i = void 0;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj = void 0;
      if ('[object Array]' === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [],
            key = void 0;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            sortedKeys.push(key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          key = sortedKeys[i];
          canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
  });
  var array$1 = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.arrayDiff = undefined;
    exports.diffArrays = diffArrays;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    var arrayDiff = exports.arrayDiff = new _base2['default']();
    arrayDiff.tokenize = arrayDiff.join = function(value) {
      return value.slice();
    };
    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  });
  var parse$3 = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.parsePatch = parsePatch;
    function parsePatch(uniDiff) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
          delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
          list = [],
          i = 0;
      function parseIndex() {
        var index = {};
        list.push(index);
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
            break;
          }
          var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
          if (header) {
            index.index = header[1];
          }
          i++;
        }
        parseFileHeader(index);
        parseFileHeader(index);
        index.hunks = [];
        while (i < diffstr.length) {
          var _line = diffstr[i];
          if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
            break;
          } else if (/^@@/.test(_line)) {
            index.hunks.push(parseHunk());
          } else if (_line && options.strict) {
            throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
          } else {
            i++;
          }
        }
      }
      function parseFileHeader(index) {
        var headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
        var fileHeader = headerPattern.exec(diffstr[i]);
        if (fileHeader) {
          var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
          index[keyPrefix + 'FileName'] = fileHeader[2];
          index[keyPrefix + 'Header'] = fileHeader[3];
          i++;
        }
      }
      function parseHunk() {
        var chunkHeaderIndex = i,
            chunkHeaderLine = diffstr[i++],
            chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
          oldStart: +chunkHeader[1],
          oldLines: +chunkHeader[2] || 1,
          newStart: +chunkHeader[3],
          newLines: +chunkHeader[4] || 1,
          lines: [],
          linedelimiters: []
        };
        var addCount = 0,
            removeCount = 0;
        for (; i < diffstr.length; i++) {
          if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
            break;
          }
          var operation = diffstr[i][0];
          if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
            hunk.lines.push(diffstr[i]);
            hunk.linedelimiters.push(delimiters[i] || '\n');
            if (operation === '+') {
              addCount++;
            } else if (operation === '-') {
              removeCount++;
            } else if (operation === ' ') {
              addCount++;
              removeCount++;
            }
          } else {
            break;
          }
        }
        if (!addCount && hunk.newLines === 1) {
          hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
          hunk.oldLines = 0;
        }
        if (options.strict) {
          if (addCount !== hunk.newLines) {
            throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
          }
          if (removeCount !== hunk.oldLines) {
            throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
          }
        }
        return hunk;
      }
      while (i < diffstr.length) {
        parseIndex();
      }
      return list;
    }
  });
  var distanceIterator = createCommonjsModule(function(module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(start, minLine, maxLine) {
      var wantForward = true,
          backwardExhausted = false,
          forwardExhausted = false,
          localOffset = 1;
      return function iterator() {
        if (wantForward && !forwardExhausted) {
          if (backwardExhausted) {
            localOffset++;
          } else {
            wantForward = false;
          }
          if (start + localOffset <= maxLine) {
            return localOffset;
          }
          forwardExhausted = true;
        }
        if (!backwardExhausted) {
          if (!forwardExhausted) {
            wantForward = true;
          }
          if (minLine <= start - localOffset) {
            return -localOffset++;
          }
          backwardExhausted = true;
          return iterator();
        }
      };
    };
  });
  var apply = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.applyPatch = applyPatch;
    exports.applyPatches = applyPatches;
    var _parse = parse$3;
    var _distanceIterator = distanceIterator;
    var _distanceIterator2 = _interopRequireDefault(_distanceIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    function applyPatch(source, uniDiff) {
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      if (typeof uniDiff === 'string') {
        uniDiff = (0, _parse.parsePatch)(uniDiff);
      }
      if (Array.isArray(uniDiff)) {
        if (uniDiff.length > 1) {
          throw new Error('applyPatch only works with a single input.');
        }
        uniDiff = uniDiff[0];
      }
      var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
          delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
          hunks = uniDiff.hunks,
          compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {
            return (line === patchContent);
          },
          errorCount = 0,
          fuzzFactor = options.fuzzFactor || 0,
          minLine = 0,
          offset = 0,
          removeEOFNL = void 0,
          addEOFNL = void 0;
      function hunkFits(hunk, toPos) {
        for (var j = 0; j < hunk.lines.length; j++) {
          var line = hunk.lines[j],
              operation = line[0],
              content = line.substr(1);
          if (operation === ' ' || operation === '-') {
            if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
              errorCount++;
              if (errorCount > fuzzFactor) {
                return false;
              }
            }
            toPos++;
          }
        }
        return true;
      }
      for (var i = 0; i < hunks.length; i++) {
        var hunk = hunks[i],
            maxLine = lines.length - hunk.oldLines,
            localOffset = 0,
            toPos = offset + hunk.oldStart - 1;
        var iterator = (0, _distanceIterator2['default'])(toPos, minLine, maxLine);
        for (; localOffset !== undefined; localOffset = iterator()) {
          if (hunkFits(hunk, toPos + localOffset)) {
            hunk.offset = offset += localOffset;
            break;
          }
        }
        if (localOffset === undefined) {
          return false;
        }
        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
      }
      for (var _i = 0; _i < hunks.length; _i++) {
        var _hunk = hunks[_i],
            _toPos = _hunk.offset + _hunk.newStart - 1;
        if (_hunk.newLines == 0) {
          _toPos++;
        }
        for (var j = 0; j < _hunk.lines.length; j++) {
          var line = _hunk.lines[j],
              operation = line[0],
              content = line.substr(1),
              delimiter = _hunk.linedelimiters[j];
          if (operation === ' ') {
            _toPos++;
          } else if (operation === '-') {
            lines.splice(_toPos, 1);
            delimiters.splice(_toPos, 1);
          } else if (operation === '+') {
            lines.splice(_toPos, 0, content);
            delimiters.splice(_toPos, 0, delimiter);
            _toPos++;
          } else if (operation === '\\') {
            var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
            if (previousOperation === '+') {
              removeEOFNL = true;
            } else if (previousOperation === '-') {
              addEOFNL = true;
            }
          }
        }
      }
      if (removeEOFNL) {
        while (!lines[lines.length - 1]) {
          lines.pop();
          delimiters.pop();
        }
      } else if (addEOFNL) {
        lines.push('');
        delimiters.push('\n');
      }
      for (var _k = 0; _k < lines.length - 1; _k++) {
        lines[_k] = lines[_k] + delimiters[_k];
      }
      return lines.join('');
    }
    function applyPatches(uniDiff, options) {
      if (typeof uniDiff === 'string') {
        uniDiff = (0, _parse.parsePatch)(uniDiff);
      }
      var currentIndex = 0;
      function processIndex() {
        var index = uniDiff[currentIndex++];
        if (!index) {
          return options.complete();
        }
        options.loadFile(index, function(err, data) {
          if (err) {
            return options.complete(err);
          }
          var updatedContent = applyPatch(data, index, options);
          options.patched(index, updatedContent, function(err) {
            if (err) {
              return options.complete(err);
            }
            processIndex();
          });
        });
      }
      processIndex();
    }
  });
  var create = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.structuredPatch = structuredPatch;
    exports.createTwoFilesPatch = createTwoFilesPatch;
    exports.createPatch = createPatch;
    var _line = line;
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0,
            arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      if (!options) {
        options = {};
      }
      if (typeof options.context === 'undefined') {
        options.context = 4;
      }
      var diff = (0, _line.diffLines)(oldStr, newStr, options);
      diff.push({
        value: '',
        lines: []
      });
      function contextLines(lines) {
        return lines.map(function(entry) {
          return ' ' + entry;
        });
      }
      var hunks = [];
      var oldRangeStart = 0,
          newRangeStart = 0,
          curRange = [],
          oldLine = 1,
          newLine = 1;
      var _loop = function _loop(i) {
        var current = diff[i],
            lines = current.lines || current.value.replace(/\n$/, '').split('\n');
        current.lines = lines;
        if (current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i - 1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;
            if (prev) {
              curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
            return (current.added ? '+' : '-') + entry;
          })));
          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            if (lines.length <= options.context * 2 && i < diff.length - 2) {
              var _curRange2;
              (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
            } else {
              var _curRange3;
              var contextSize = Math.min(lines.length, options.context);
              (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
              var hunk = {
                oldStart: oldRangeStart,
                oldLines: oldLine - oldRangeStart + contextSize,
                newStart: newRangeStart,
                newLines: newLine - newRangeStart + contextSize,
                lines: curRange
              };
              if (i >= diff.length - 2 && lines.length <= options.context) {
                var oldEOFNewline = /\n$/.test(oldStr);
                var newEOFNewline = /\n$/.test(newStr);
                if (lines.length == 0 && !oldEOFNewline) {
                  curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
                } else if (!oldEOFNewline || !newEOFNewline) {
                  curRange.push('\\ No newline at end of file');
                }
              }
              hunks.push(hunk);
              oldRangeStart = 0;
              newRangeStart = 0;
              curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      };
      for (var i = 0; i < diff.length; i++) {
        _loop(i);
      }
      return {
        oldFileName: oldFileName,
        newFileName: newFileName,
        oldHeader: oldHeader,
        newHeader: newHeader,
        hunks: hunks
      };
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
      var ret = [];
      if (oldFileName == newFileName) {
        ret.push('Index: ' + oldFileName);
      }
      ret.push('===================================================================');
      ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
      ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));
      for (var i = 0; i < diff.hunks.length; i++) {
        var hunk = diff.hunks[i];
        ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
        ret.push.apply(ret, hunk.lines);
      }
      return ret.join('\n') + '\n';
    }
    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
    }
  });
  var dmp = createCommonjsModule(function(module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.convertChangesToDMP = convertChangesToDMP;
    function convertChangesToDMP(changes) {
      var ret = [],
          change = void 0,
          operation = void 0;
      for (var i = 0; i < changes.length; i++) {
        change = changes[i];
        if (change.added) {
          operation = 1;
        } else if (change.removed) {
          operation = -1;
        } else {
          operation = 0;
        }
        ret.push([operation, change.value]);
      }
      return ret;
    }
  });
  var xml = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.convertChangesToXML = convertChangesToXML;
    function convertChangesToXML(changes) {
      var ret = [];
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push('<ins>');
        } else if (change.removed) {
          ret.push('<del>');
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
          ret.push('</ins>');
        } else if (change.removed) {
          ret.push('</del>');
        }
      }
      return ret.join('');
    }
    function escapeHTML(s) {
      var n = s;
      n = n.replace(/&/g, '&amp;');
      n = n.replace(/</g, '&lt;');
      n = n.replace(/>/g, '&gt;');
      n = n.replace(/"/g, '&quot;');
      return n;
    }
  });
  var index$60 = createCommonjsModule(function(module, exports) {
    'use strict';
    exports.__esModule = true;
    exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;
    var _base = base;
    var _base2 = _interopRequireDefault(_base);
    var _character = character;
    var _word = word;
    var _line = line;
    var _sentence = sentence;
    var _css = css;
    var _json = json$2;
    var _array = array$1;
    var _apply = apply;
    var _parse = parse$3;
    var _create = create;
    var _dmp = dmp;
    var _xml = xml;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {'default': obj};
    }
    exports.Diff = _base2['default'];
    exports.diffChars = _character.diffChars;
    exports.diffWords = _word.diffWords;
    exports.diffWordsWithSpace = _word.diffWordsWithSpace;
    exports.diffLines = _line.diffLines;
    exports.diffTrimmedLines = _line.diffTrimmedLines;
    exports.diffSentences = _sentence.diffSentences;
    exports.diffCss = _css.diffCss;
    exports.diffJson = _json.diffJson;
    exports.diffArrays = _array.diffArrays;
    exports.structuredPatch = _create.structuredPatch;
    exports.createTwoFilesPatch = _create.createTwoFilesPatch;
    exports.createPatch = _create.createPatch;
    exports.applyPatch = _apply.applyPatch;
    exports.applyPatches = _apply.applyPatches;
    exports.parsePatch = _parse.parsePatch;
    exports.convertChangesToDMP = _dmp.convertChangesToDMP;
    exports.convertChangesToXML = _xml.convertChangesToXML;
    exports.canonicalize = _json.canonicalize;
  });
  const chalk = index;
  const dashify = index$14;
  const fs = require$$0;
  const getStream = index$16;
  const globby = index$18;
  const minimist = index$42;
  const path = require$$0$1;
  const readline$1 = readline;
  const ignore = ignore$1;
  const prettier = require('../index');
  const cleanAST = cleanAst.cleanAST;
  const resolver = resolveConfig_1;
  const args = process.argv.slice(2);
  const booleanOptionNames = ["use-tabs", "semi", "single-quote", "bracket-spacing", "jsx-bracket-same-line", "flow-parser"];
  const stringOptionNames = ["print-width", "tab-width", "parser", "trailing-comma"];
  const argv = minimist(args, {
    boolean: ["write", "stdin", "color", "list-different", "help", "version", "debug-print-doc", "debug-check", "with-node-modules"].concat(booleanOptionNames),
    string: ["cursor-offset", "range-start", "range-end", "stdin-filepath", "config", "find-config-path", "ignore-path"].concat(stringOptionNames),
    default: {
      color: true,
      "ignore-path": ".prettierignore"
    },
    alias: {
      help: "h",
      version: "v",
      "list-different": "l"
    },
    unknown: (param) => {
      if (param.startsWith("-")) {
        console.warn("Ignored unknown option: " + param + "\n");
        return false;
      }
    }
  });
  if (argv["version"]) {
    console.log(prettier.version);
    process.exit(0);
  }
  const filepatterns = argv["_"];
  const write = argv["write"];
  const stdin = argv["stdin"] || (!filepatterns.length && !process.stdin.isTTY);
  const ignoreNodeModules = argv["with-node-modules"] === false;
  const ignoreNodeModulesGlobs = ["!**/node_modules/**", "!./node_modules/**"];
  const ignorePath = argv["ignore-path"];
  const globOptions = {dot: true};
  if (write && argv["debug-check"]) {
    console.error("Cannot use --write and --debug-check together.");
    process.exit(1);
  }
  if (argv["find-config-path"] && filepatterns.length) {
    console.error("Cannot use --find-config-path with multiple files");
    process.exit(1);
  }
  function getOptionsForFile(filePath) {
    const optionsPromise = argv["config"] === false ? Promise.resolve(null) : resolver.resolveConfig(filePath);
    return optionsPromise.then((options) => {
      const parsedArgs = minimist(args, {
        boolean: booleanOptionNames,
        string: stringOptionNames,
        default: Object.assign({
          semi: true,
          "bracket-spacing": true,
          parser: "babylon"
        }, dashifyObject(options))
      });
      return getOptions(Object.assign({}, argv, parsedArgs));
    }).catch((error) => {
      console.error("Invalid configuration file:", error.toString());
      process.exit(2);
    });
  }
  function getOptions(argv) {
    return {
      cursorOffset: getIntOption(argv, "cursor-offset"),
      rangeStart: getIntOption(argv, "range-start"),
      rangeEnd: getIntOption(argv, "range-end"),
      useTabs: argv["use-tabs"],
      semi: argv["semi"],
      printWidth: getIntOption(argv, "print-width"),
      tabWidth: getIntOption(argv, "tab-width"),
      bracketSpacing: argv["bracket-spacing"],
      singleQuote: argv["single-quote"],
      jsxBracketSameLine: argv["jsx-bracket-same-line"],
      filepath: argv["stdin-filepath"],
      trailingComma: getTrailingComma(argv),
      parser: getParserOption(argv)
    };
  }
  function getParserOption(argv) {
    const value = argv.parser;
    if (value === undefined) {
      return value;
    }
    if (argv["flow-parser"]) {
      console.warn("`--flow-parser` is deprecated. Use `--parser flow` instead.");
      return "flow";
    }
    return value;
  }
  function getIntOption(argv, optionName) {
    const value = argv[optionName];
    if (value === undefined) {
      return value;
    }
    if (/^\d+$/.test(value)) {
      return Number(value);
    }
    console.error("Invalid --" + optionName + " value. Expected an integer, but received: " + JSON.stringify(value));
    process.exit(1);
  }
  function getTrailingComma(argv) {
    switch (argv["trailing-comma"]) {
      case undefined:
      case "none":
        return "none";
      case "":
        console.warn("Warning: `--trailing-comma` was used without an argument. This is deprecated. " + 'Specify "none", "es5", or "all".');
        return "es5";
      case "es5":
        return "es5";
      case "all":
        return "all";
      default:
        throw new Error("Invalid option for --trailing-comma");
    }
  }
  function dashifyObject(object) {
    return Object.keys(object || {}).reduce((output, key) => {
      output[dashify(key)] = object[key];
      return output;
    }, {});
  }
  function diff(a, b) {
    return index$60.createTwoFilesPatch("", "", a, b, "", "", {context: 2});
  }
  function format(input, opt) {
    if (argv["debug-print-doc"]) {
      const doc = prettier.__debug.printToDoc(input, opt);
      return {formatted: prettier.__debug.formatDoc(doc)};
    }
    if (argv["debug-check"]) {
      const pp = prettier.format(input, opt);
      const pppp = prettier.format(pp, opt);
      if (pp !== pppp) {
        throw "prettier(input) !== prettier(prettier(input))\n" + diff(pp, pppp);
      } else {
        const ast = cleanAST(prettier.__debug.parse(input, opt));
        const past = cleanAST(prettier.__debug.parse(pp, opt));
        if (ast !== past) {
          const MAX_AST_SIZE = 2097152;
          const astDiff = ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE ? "AST diff too large to render" : diff(ast, past);
          throw "ast(input) !== ast(prettier(input))\n" + astDiff + "\n" + diff(input, pp);
        }
      }
      return {formatted: opt.filepath || "(stdin)\n"};
    }
    return prettier.formatWithCursor(input, opt);
  }
  function handleError(filename, e) {
    const isParseError = Boolean(e && e.loc);
    const isValidationError = /Validation Error/.test(e && e.message);
    if (isParseError) {
      console.error(filename + ": " + String(e));
    } else if (isValidationError) {
      console.error(String(e));
      process.exit(1);
    } else {
      console.error(filename + ":", e.stack || e);
    }
    process.exitCode = 2;
  }
  if (argv["help"] || (!filepatterns.length && !stdin && !argv["find-config-path"])) {
    console.log("Usage: prettier [opts] [filename ...]\n\n" + "Available options:\n" + "  --write                  Edit the file in-place. (Beware!)\n" + "  --list-different or -l   Print filenames of files that are different from Prettier formatting.\n" + "  --config                 Path to a prettier configuration file (.prettierrc, package.json, prettier.config.js).\n" + "  --no-config              Do not look for a configuration file.\n" + "  --find-config-path <path>\n" + "                           Finds and prints the path to a configuration file for a given input file.\n" + "  --ignore-path <path>     Path to a file containing patterns that describe files to ignore.\n" + "                           Defaults to ./.prettierignore.\n" + "  --stdin                  Read input from stdin.\n" + "  --stdin-filepath         Path to the file used to read from stdin.\n" + "  --print-width <int>      Specify the length of line that the printer will wrap on. Defaults to 80.\n" + "  --tab-width <int>        Specify the number of spaces per indentation-level. Defaults to 2.\n" + "  --use-tabs               Indent lines with tabs instead of spaces.\n" + "  --no-semi                Do not print semicolons, except at the beginning of lines which may need them.\n" + "  --single-quote           Use single quotes instead of double quotes.\n" + "  --no-bracket-spacing     Do not print spaces between brackets.\n" + "  --jsx-bracket-same-line  Put > on the last line instead of at a new line.\n" + "  --trailing-comma <none|es5|all>\n" + "                           Print trailing commas wherever possible when multi-line. Defaults to none.\n" + "  --parser <flow|babylon|typescript|postcss|json|graphql>\n" + "                           Specify which parse to use. Defaults to babylon.\n" + "  --cursor-offset <int>    Print (to stderr) where a cursor at the given position would move to after formatting.\n" + "                           This option cannot be used with --range-start and --range-end\n" + "  --range-start <int>      Format code starting at a given character offset.\n" + "                           The range will extend backwards to the start of the first line containing the selected statement.\n" + "                           This option cannot be used with --cursor-offset.\n" + "                           Defaults to 0.\n" + "  --range-end <int>        Format code ending at a given character offset (exclusive).\n" + "                           The range will extend forwards to the end of the selected statement.\n" + "                           This option cannot be used with --cursor-offset.\n" + "                           Defaults to Infinity.\n" + "  --no-color               Do not colorize error messages.\n" + "  --with-node-modules      Process files inside `node_modules` directory.\n" + "  --version or -v          Print Prettier version.\n" + "\n");
    process.exit(argv["help"] ? 0 : 1);
  }
  if (argv["find-config-path"]) {
    resolveConfig(argv["find-config-path"]);
  } else if (stdin) {
    getStream(process.stdin).then((input) => {
      getOptionsForFile(process.cwd()).then((options) => {
        if (listDifferent(input, options, "(stdin)")) {
          return;
        }
        try {
          writeOutput(format(input, options), options);
        } catch (e) {
          handleError("stdin", e);
        }
      });
    });
  } else {
    eachFilename(filepatterns, (filename, options) => {
      if (write) {
        process.stdout.write(filename);
      }
      let input;
      try {
        input = fs.readFileSync(filename, "utf8");
      } catch (e) {
        process.stdout.write("\n");
        console.error("Unable to read file: " + filename + "\n" + e);
        process.exitCode = 2;
        return;
      }
      listDifferent(input, options, filename);
      const start = Date.now();
      let result;
      let output;
      try {
        result = format(input, Object.assign({}, options, {filepath: filename}));
        output = result.formatted;
      } catch (e) {
        process.stdout.write("\n");
        handleError(filename, e);
        return;
      }
      if (write) {
        readline$1.clearLine(process.stdout, 0);
        readline$1.cursorTo(process.stdout, 0, null);
        if (output === input) {
          if (!argv["list-different"]) {
            console.log(chalk.grey("%s %dms"), filename, Date.now() - start);
          }
        } else {
          if (argv["list-different"]) {
            console.log(filename);
          } else {
            console.log("%s %dms", filename, Date.now() - start);
          }
          try {
            fs.writeFileSync(filename, output, "utf8");
          } catch (err) {
            console.error("Unable to write file: " + filename + "\n" + err);
            process.exitCode = 2;
          }
        }
      } else if (argv["debug-check"]) {
        if (output) {
          console.log(output);
        } else {
          process.exitCode = 2;
        }
      } else if (!argv["list-different"]) {
        writeOutput(result, options);
      }
    });
  }
  function listDifferent(input, options, filename) {
    if (!argv["list-different"]) {
      return;
    }
    options = Object.assign({}, options, {filepath: filename});
    if (!prettier.check(input, options)) {
      if (!write) {
        console.log(filename);
      }
      process.exitCode = 1;
    }
    return true;
  }
  function resolveConfig(filePath) {
    resolver.resolveConfigFile(filePath).then((configFile) => {
      if (configFile) {
        console.log(path.relative(process.cwd(), configFile));
      } else {
        process.exitCode = 1;
      }
    });
  }
  function writeOutput(result, options) {
    process.stdout.write(result.formatted);
    if (options.cursorOffset) {
      process.stderr.write(result.cursorOffset + "\n");
    }
  }
  function eachFilename(patterns, callback) {
    const ignoreFilePath = path.resolve(ignorePath);
    let ignoreText = "";
    try {
      ignoreText = fs.readFileSync(ignoreFilePath, "utf8");
    } catch (readError) {
      if (readError.code !== "ENOENT") {
        console.error(`Unable to read ${ignoreFilePath}:`, readError);
        process.exit(2);
      }
    }
    const ignorer = ignore().add(ignoreText);
    if (ignoreNodeModules) {
      patterns = patterns.concat(ignoreNodeModulesGlobs);
    }
    return globby(patterns, globOptions).then((filePaths) => {
      if (filePaths.length === 0) {
        console.error("No matching files. Patterns tried: " + patterns.join(" "));
        process.exitCode = 2;
        return;
      }
      mapSeries(ignorer.filter(filePaths), (filePath) => {
        return getOptionsForFile(filePath).then((options) => callback(filePath, options));
      });
    }).catch((err) => {
      console.error("Unable to expand glob patterns: " + patterns.join(" ") + "\n" + err);
      process.exitCode = 2;
    });
  }
  function mapSeries(array, iteratee) {
    let current = Promise.resolve();
    const promises = array.map((item, i) => {
      current = current.then(() => {
        return iteratee(item, i, array);
      });
      return current;
    });
    return Promise.all(promises);
  }
  var prettier_1 = {};
  module.exports = prettier_1;
})(require('buffer').Buffer, require('process'));
