/* */ 
(function(process) {
  'use strict';
  var fs = require('fs');
  var path = require('path');
  var walker = require('../../walker/lib/walker');
  var common = require('./common');
  var platform = require('os').platform();
  var EventEmitter = require('events').EventEmitter;
  var anymatch = require('../../anymatch/index');
  var DEFAULT_DELAY = common.DEFAULT_DELAY;
  var CHANGE_EVENT = common.CHANGE_EVENT;
  var DELETE_EVENT = common.DELETE_EVENT;
  var ADD_EVENT = common.ADD_EVENT;
  var ALL_EVENT = common.ALL_EVENT;
  module.exports = NodeWatcher;
  function NodeWatcher(dir, opts) {
    opts = common.assignOptions(this, opts);
    this.watched = Object.create(null);
    this.changeTimers = Object.create(null);
    this.dirRegistery = Object.create(null);
    this.root = path.resolve(dir);
    this.watchdir = this.watchdir.bind(this);
    this.register = this.register.bind(this);
    this.watchdir(this.root);
    recReaddir(this.root, this.watchdir, this.register, this.emit.bind(this, 'ready'), this.ignored);
  }
  NodeWatcher.prototype.__proto__ = EventEmitter.prototype;
  NodeWatcher.prototype.register = function(filepath) {
    var relativePath = path.relative(this.root, filepath);
    if (!common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {
      return false;
    }
    var dir = path.dirname(filepath);
    if (!this.dirRegistery[dir]) {
      this.dirRegistery[dir] = Object.create(null);
    }
    var filename = path.basename(filepath);
    this.dirRegistery[dir][filename] = true;
    return true;
  };
  NodeWatcher.prototype.unregister = function(filepath) {
    var dir = path.dirname(filepath);
    if (this.dirRegistery[dir]) {
      var filename = path.basename(filepath);
      delete this.dirRegistery[dir][filename];
    }
  };
  NodeWatcher.prototype.unregisterDir = function(dirpath) {
    if (this.dirRegistery[dirpath]) {
      delete this.dirRegistery[dirpath];
    }
  };
  NodeWatcher.prototype.registered = function(fullpath) {
    var dir = path.dirname(fullpath);
    return this.dirRegistery[fullpath] || this.dirRegistery[dir] && this.dirRegistery[dir][path.basename(fullpath)];
  };
  NodeWatcher.prototype.watchdir = function(dir) {
    if (this.watched[dir]) {
      return;
    }
    var watcher = fs.watch(dir, {persistent: true}, this.normalizeChange.bind(this, dir));
    this.watched[dir] = watcher;
    if (platform === 'win32') {
      watcher.on('error', function(error) {
        if (error.code !== 'EPERM') {
          throw error;
        }
      });
    }
    if (this.root !== dir) {
      this.register(dir);
    }
  };
  NodeWatcher.prototype.stopWatching = function(dir) {
    if (this.watched[dir]) {
      this.watched[dir].close();
      delete this.watched[dir];
    }
  };
  NodeWatcher.prototype.close = function(callback) {
    Object.keys(this.watched).forEach(this.stopWatching, this);
    this.removeAllListeners();
    if (typeof callback === 'function') {
      setImmediate(callback.bind(null, null, true));
    }
  };
  NodeWatcher.prototype.detectChangedFile = function(dir, event, callback) {
    if (!this.dirRegistery[dir]) {
      return;
    }
    var found = false;
    var closest = {mtime: 0};
    var c = 0;
    Object.keys(this.dirRegistery[dir]).forEach(function(file, i, arr) {
      fs.lstat(path.join(dir, file), function(error, stat) {
        if (found) {
          return;
        }
        if (error) {
          if (error.code === 'ENOENT' || (platform === 'win32' && error.code === 'EPERM')) {
            found = true;
            callback(file);
          } else {
            this.emit('error', error);
          }
        } else {
          if (stat.mtime > closest.mtime) {
            stat.file = file;
            closest = stat;
          }
          if (arr.length === ++c) {
            callback(closest.file);
          }
        }
      }.bind(this));
    }, this);
  };
  NodeWatcher.prototype.normalizeChange = function(dir, event, file) {
    if (!file) {
      this.detectChangedFile(dir, event, function(actualFile) {
        if (actualFile) {
          this.processChange(dir, event, actualFile);
        }
      }.bind(this));
    } else {
      this.processChange(dir, event, path.normalize(file));
    }
  };
  NodeWatcher.prototype.processChange = function(dir, event, file) {
    var fullPath = path.join(dir, file);
    var relativePath = path.join(path.relative(this.root, dir), file);
    fs.lstat(fullPath, function(error, stat) {
      if (error && error.code !== 'ENOENT') {
        this.emit('error', error);
      } else if (!error && stat.isDirectory()) {
        if (event !== 'change') {
          this.watchdir(fullPath);
          if (common.isFileIncluded(this.globs, this.dot, this.doIgnore, relativePath)) {
            this.emitEvent(ADD_EVENT, relativePath, stat);
          }
        }
      } else {
        var registered = this.registered(fullPath);
        if (error && error.code === 'ENOENT') {
          this.unregister(fullPath);
          this.stopWatching(fullPath);
          this.unregisterDir(fullPath);
          if (registered) {
            this.emitEvent(DELETE_EVENT, relativePath);
          }
        } else if (registered) {
          this.emitEvent(CHANGE_EVENT, relativePath, stat);
        } else {
          if (this.register(fullPath)) {
            this.emitEvent(ADD_EVENT, relativePath, stat);
          }
        }
      }
    }.bind(this));
  };
  NodeWatcher.prototype.emitEvent = function(type, file, stat) {
    var key = type + '-' + file;
    var addKey = ADD_EVENT + '-' + file;
    if (type === CHANGE_EVENT && this.changeTimers[addKey]) {
      return;
    }
    clearTimeout(this.changeTimers[key]);
    this.changeTimers[key] = setTimeout(function() {
      delete this.changeTimers[key];
      this.emit(type, file, this.root, stat);
      this.emit(ALL_EVENT, type, file, this.root, stat);
    }.bind(this), DEFAULT_DELAY);
  };
  function recReaddir(dir, dirCallback, fileCallback, endCallback, ignored) {
    walker(dir).filterDir(function(currentDir) {
      return !anymatch(ignored, currentDir);
    }).on('dir', normalizeProxy(dirCallback)).on('file', normalizeProxy(fileCallback)).on('end', function() {
      if (platform === 'win32') {
        setTimeout(endCallback, 1000);
      } else {
        endCallback();
      }
    });
  }
  function normalizeProxy(callback) {
    return function(filepath) {
      return callback(path.normalize(filepath));
    };
  }
})(require('process'));
