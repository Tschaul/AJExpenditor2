/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var ts = require('../../typescript/lib/typescript');
var node_1 = require('../typeguard/node');
function getChildOfKind(node, kind, sourceFile) {
  for (var _i = 0,
      _a = node.getChildren(sourceFile); _i < _a.length; _i++) {
    var child = _a[_i];
    if (child.kind === kind)
      return child;
  }
}
exports.getChildOfKind = getChildOfKind;
function isTokenKind(kind) {
  return kind >= ts.SyntaxKind.FirstToken && kind <= ts.SyntaxKind.LastToken;
}
exports.isTokenKind = isTokenKind;
function isNodeKind(kind) {
  return kind >= ts.SyntaxKind.FirstNode;
}
exports.isNodeKind = isNodeKind;
function isAssignmentKind(kind) {
  return kind >= ts.SyntaxKind.FirstAssignment && kind <= ts.SyntaxKind.LastAssignment;
}
exports.isAssignmentKind = isAssignmentKind;
function isTypeNodeKind(kind) {
  return kind >= ts.SyntaxKind.FirstTypeNode && kind <= ts.SyntaxKind.LastTypeNode;
}
exports.isTypeNodeKind = isTypeNodeKind;
function isJsDocKind(kind) {
  return kind >= ts.SyntaxKind.FirstJSDocNode && kind <= ts.SyntaxKind.LastJSDocNode;
}
exports.isJsDocKind = isJsDocKind;
function isThisParameter(parameter) {
  return parameter.name.kind === ts.SyntaxKind.Identifier && parameter.name.originalKeywordKind === ts.SyntaxKind.ThisKeyword;
}
exports.isThisParameter = isThisParameter;
function getModifier(node, kind) {
  if (node.modifiers !== undefined)
    for (var _i = 0,
        _a = node.modifiers; _i < _a.length; _i++) {
      var modifier = _a[_i];
      if (modifier.kind === kind)
        return modifier;
    }
}
exports.getModifier = getModifier;
function hasModifier(modifiers) {
  var kinds = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    kinds[_i - 1] = arguments[_i];
  }
  if (modifiers === undefined)
    return false;
  for (var _a = 0,
      modifiers_1 = modifiers; _a < modifiers_1.length; _a++) {
    var modifier = modifiers_1[_a];
    if (kinds.indexOf(modifier.kind) !== -1)
      return true;
  }
  return false;
}
exports.hasModifier = hasModifier;
function isParameterProperty(node) {
  return hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword, ts.SyntaxKind.ReadonlyKeyword);
}
exports.isParameterProperty = isParameterProperty;
function hasAccessModifier(node) {
  return hasModifier(node.modifiers, ts.SyntaxKind.PublicKeyword, ts.SyntaxKind.ProtectedKeyword, ts.SyntaxKind.PrivateKeyword);
}
exports.hasAccessModifier = hasAccessModifier;
function isFlagSet(obj, flag) {
  return (obj.flags & flag) !== 0;
}
exports.isNodeFlagSet = isFlagSet;
exports.isTypeFlagSet = isFlagSet;
exports.isSymbolFlagSet = isFlagSet;
function isObjectFlagSet(objectType, flag) {
  return (objectType.objectFlags & flag) !== 0;
}
exports.isObjectFlagSet = isObjectFlagSet;
function isModifierFlagSet(node, flag) {
  return (ts.getCombinedModifierFlags(node) & flag) !== 0;
}
exports.isModifierFlagSet = isModifierFlagSet;
function isModfierFlagSet(node, flag) {
  return isModifierFlagSet(node, flag);
}
exports.isModfierFlagSet = isModfierFlagSet;
function getPreviousStatement(statement) {
  var parent = statement.parent;
  if (node_1.isBlockLike(parent)) {
    var index = parent.statements.indexOf(statement);
    if (index > 0)
      return parent.statements[index - 1];
  }
}
exports.getPreviousStatement = getPreviousStatement;
function getNextStatement(statement) {
  var parent = statement.parent;
  if (node_1.isBlockLike(parent)) {
    var index = parent.statements.indexOf(statement);
    if (index < parent.statements.length)
      return parent.statements[index + 1];
  }
}
exports.getNextStatement = getNextStatement;
function getPreviousToken(node, sourceFile) {
  var parent = node.parent;
  while (parent !== undefined && parent.pos === node.pos)
    parent = parent.parent;
  if (parent === undefined)
    return;
  outer: while (true) {
    var children = parent.getChildren(sourceFile);
    for (var i = children.length - 1; i >= 0; --i) {
      var child = children[i];
      if (child.pos < node.pos && child.kind !== ts.SyntaxKind.JSDocComment) {
        if (isTokenKind(child.kind))
          return child;
        parent = child;
        continue outer;
      }
    }
    return;
  }
}
exports.getPreviousToken = getPreviousToken;
function getNextToken(node, sourceFile) {
  if (sourceFile === void 0) {
    sourceFile = node.getSourceFile();
  }
  if (node.kind === ts.SyntaxKind.SourceFile || node.kind === ts.SyntaxKind.EndOfFileToken)
    return;
  var end = node.end;
  node = node.parent;
  while (node.end === end) {
    if (node.parent === undefined)
      return node.endOfFileToken;
    node = node.parent;
  }
  return getTokenAtPositionWorker(node, end, sourceFile);
}
exports.getNextToken = getNextToken;
function getTokenAtPosition(parent, pos, sourceFile) {
  if (pos < parent.pos || pos >= parent.end)
    return;
  if (isTokenKind(parent.kind))
    return parent;
  if (sourceFile === undefined)
    sourceFile = parent.getSourceFile();
  return getTokenAtPositionWorker(parent, pos, sourceFile);
}
exports.getTokenAtPosition = getTokenAtPosition;
function getTokenAtPositionWorker(node, pos, sourceFile) {
  outer: while (true) {
    for (var _i = 0,
        _a = node.getChildren(sourceFile); _i < _a.length; _i++) {
      var child = _a[_i];
      if (child.end > pos && child.kind !== ts.SyntaxKind.JSDocComment) {
        if (isTokenKind(child.kind))
          return child;
        node = child;
        continue outer;
      }
    }
    return;
  }
}
function getCommentAtPosition(sourceFile, pos, parent) {
  if (parent === void 0) {
    parent = sourceFile;
  }
  var token = getTokenAtPosition(parent, pos, sourceFile);
  if (token === undefined || token.kind === ts.SyntaxKind.JsxText || pos >= token.end - (ts.tokenToString(token.kind) || '').length)
    return;
  var cb = function(start, end, kind) {
    return pos >= start && pos < end ? {
      end: end,
      kind: kind,
      pos: start
    } : undefined;
  };
  return token.pos !== 0 && ts.forEachTrailingCommentRange(sourceFile.text, token.pos, cb) || ts.forEachLeadingCommentRange(sourceFile.text, token.pos, cb);
}
exports.getCommentAtPosition = getCommentAtPosition;
function isPositionInComment(sourceFile, pos, parent) {
  return getCommentAtPosition(sourceFile, pos, parent) !== undefined;
}
exports.isPositionInComment = isPositionInComment;
function getPropertyName(propertyName) {
  if (propertyName.kind === ts.SyntaxKind.ComputedPropertyName) {
    if (!node_1.isLiteralExpression(propertyName.expression))
      return;
    return propertyName.expression.text;
  }
  return propertyName.text;
}
exports.getPropertyName = getPropertyName;
function forEachDestructuringIdentifier(pattern, fn) {
  for (var _i = 0,
      _a = pattern.elements; _i < _a.length; _i++) {
    var element = _a[_i];
    if (element.kind !== ts.SyntaxKind.BindingElement)
      continue;
    var result = void 0;
    if (element.name.kind === ts.SyntaxKind.Identifier) {
      result = fn(element);
    } else {
      result = forEachDestructuringIdentifier(element.name, fn);
    }
    if (result)
      return result;
  }
}
exports.forEachDestructuringIdentifier = forEachDestructuringIdentifier;
function forEachDeclaredVariable(declarationList, cb) {
  for (var _i = 0,
      _a = declarationList.declarations; _i < _a.length; _i++) {
    var declaration = _a[_i];
    var result = void 0;
    if (declaration.name.kind === ts.SyntaxKind.Identifier) {
      result = cb(declaration);
    } else {
      result = forEachDestructuringIdentifier(declaration.name, cb);
    }
    if (result)
      return result;
  }
}
exports.forEachDeclaredVariable = forEachDeclaredVariable;
var VariableDeclarationKind;
(function(VariableDeclarationKind) {
  VariableDeclarationKind[VariableDeclarationKind["Var"] = 0] = "Var";
  VariableDeclarationKind[VariableDeclarationKind["Let"] = 1] = "Let";
  VariableDeclarationKind[VariableDeclarationKind["Const"] = 2] = "Const";
})(VariableDeclarationKind = exports.VariableDeclarationKind || (exports.VariableDeclarationKind = {}));
function getVariableDeclarationKind(declarationList) {
  if (declarationList.flags & ts.NodeFlags.Let)
    return 1;
  if (declarationList.flags & ts.NodeFlags.Const)
    return 2;
  return 0;
}
exports.getVariableDeclarationKind = getVariableDeclarationKind;
function isBlockScopedVariableDeclarationList(declarationList) {
  return (declarationList.flags & ts.NodeFlags.BlockScoped) !== 0;
}
exports.isBlockScopedVariableDeclarationList = isBlockScopedVariableDeclarationList;
function isBlockScopedVariableDeclaration(declaration) {
  var parent = declaration.parent;
  return parent.kind === ts.SyntaxKind.CatchClause || isBlockScopedVariableDeclarationList(parent);
}
exports.isBlockScopedVariableDeclaration = isBlockScopedVariableDeclaration;
var ScopeBoundary;
(function(ScopeBoundary) {
  ScopeBoundary[ScopeBoundary["None"] = 0] = "None";
  ScopeBoundary[ScopeBoundary["Function"] = 1] = "Function";
  ScopeBoundary[ScopeBoundary["Block"] = 2] = "Block";
})(ScopeBoundary = exports.ScopeBoundary || (exports.ScopeBoundary = {}));
function isScopeBoundary(node) {
  if (isFunctionScopeBoundary(node))
    return 1;
  if (isBlockScopeBoundary(node))
    return 2;
  return 0;
}
exports.isScopeBoundary = isScopeBoundary;
function isFunctionScopeBoundary(node) {
  switch (node.kind) {
    case ts.SyntaxKind.FunctionExpression:
    case ts.SyntaxKind.ArrowFunction:
    case ts.SyntaxKind.Constructor:
    case ts.SyntaxKind.ModuleDeclaration:
    case ts.SyntaxKind.ClassDeclaration:
    case ts.SyntaxKind.ClassExpression:
    case ts.SyntaxKind.EnumDeclaration:
    case ts.SyntaxKind.MethodDeclaration:
    case ts.SyntaxKind.FunctionDeclaration:
    case ts.SyntaxKind.GetAccessor:
    case ts.SyntaxKind.SetAccessor:
    case ts.SyntaxKind.InterfaceDeclaration:
    case ts.SyntaxKind.TypeAliasDeclaration:
    case ts.SyntaxKind.MethodSignature:
    case ts.SyntaxKind.CallSignature:
    case ts.SyntaxKind.ConstructSignature:
    case ts.SyntaxKind.ConstructorType:
    case ts.SyntaxKind.FunctionType:
    case ts.SyntaxKind.MappedType:
      return true;
    case ts.SyntaxKind.SourceFile:
      return ts.isExternalModule(node);
    default:
      return false;
  }
}
exports.isFunctionScopeBoundary = isFunctionScopeBoundary;
function isBlockScopeBoundary(node) {
  switch (node.kind) {
    case ts.SyntaxKind.Block:
      var parent = node.parent;
      return parent.kind !== ts.SyntaxKind.CatchClause && (parent.kind === ts.SyntaxKind.SourceFile || !isFunctionScopeBoundary(parent));
    case ts.SyntaxKind.ForStatement:
    case ts.SyntaxKind.ForInStatement:
    case ts.SyntaxKind.ForOfStatement:
    case ts.SyntaxKind.CaseBlock:
    case ts.SyntaxKind.CatchClause:
      return true;
    default:
      return false;
  }
}
exports.isBlockScopeBoundary = isBlockScopeBoundary;
function hasOwnThisReference(node) {
  switch (node.kind) {
    case ts.SyntaxKind.ClassDeclaration:
    case ts.SyntaxKind.ClassExpression:
    case ts.SyntaxKind.FunctionExpression:
      return true;
    case ts.SyntaxKind.FunctionDeclaration:
      return node.body !== undefined;
    case ts.SyntaxKind.MethodDeclaration:
    case ts.SyntaxKind.GetAccessor:
    case ts.SyntaxKind.SetAccessor:
      return node.parent.kind === ts.SyntaxKind.ObjectLiteralExpression;
    default:
      return false;
  }
}
exports.hasOwnThisReference = hasOwnThisReference;
function isFunctionWithBody(node) {
  switch (node.kind) {
    case ts.SyntaxKind.GetAccessor:
    case ts.SyntaxKind.SetAccessor:
    case ts.SyntaxKind.FunctionDeclaration:
    case ts.SyntaxKind.MethodDeclaration:
    case ts.SyntaxKind.Constructor:
      return node.body !== undefined;
    case ts.SyntaxKind.FunctionExpression:
    case ts.SyntaxKind.ArrowFunction:
      return true;
    default:
      return false;
  }
}
exports.isFunctionWithBody = isFunctionWithBody;
function forEachToken(node, cb, sourceFile) {
  if (sourceFile === void 0) {
    sourceFile = node.getSourceFile();
  }
  return (function iterate(child) {
    if (isTokenKind(child.kind))
      return cb(child);
    if (child.kind !== ts.SyntaxKind.JSDocComment)
      return child.getChildren(sourceFile).forEach(iterate);
  })(node);
}
exports.forEachToken = forEachToken;
function forEachTokenWithTrivia(node, cb, sourceFile) {
  if (sourceFile === void 0) {
    sourceFile = node.getSourceFile();
  }
  var fullText = sourceFile.text;
  var notJsx = sourceFile.languageVariant !== ts.LanguageVariant.JSX;
  var scanner = ts.createScanner(sourceFile.languageVersion, false, sourceFile.languageVariant, fullText);
  return forEachToken(node, function(token) {
    var tokenStart = token.getStart(sourceFile);
    var end = token.end;
    if (tokenStart !== token.pos && (notJsx || canHaveLeadingTrivia(token))) {
      scanner.setTextPos(token.pos);
      var position = void 0;
      do {
        var kind = scanner.scan();
        position = scanner.getTextPos();
        cb(fullText, kind, {
          pos: scanner.getTokenPos(),
          end: position
        }, token.parent);
      } while (position < tokenStart);
    }
    return cb(fullText, token.kind, {
      end: end,
      pos: tokenStart
    }, token.parent);
  }, sourceFile);
}
exports.forEachTokenWithTrivia = forEachTokenWithTrivia;
function forEachComment(node, cb, sourceFile) {
  if (sourceFile === void 0) {
    sourceFile = node.getSourceFile();
  }
  var fullText = sourceFile.text;
  var notJsx = sourceFile.languageVariant !== ts.LanguageVariant.JSX;
  return forEachToken(node, function(token) {
    if (notJsx || canHaveLeadingTrivia(token))
      ts.forEachLeadingCommentRange(fullText, token.pos, commentCallback);
    if (notJsx || canHaveTrailingTrivia(token))
      return ts.forEachTrailingCommentRange(fullText, token.end, commentCallback);
  }, sourceFile);
  function commentCallback(pos, end, kind) {
    cb(fullText, {
      pos: pos,
      end: end,
      kind: kind
    });
  }
}
exports.forEachComment = forEachComment;
function canHaveLeadingTrivia(_a) {
  var kind = _a.kind,
      parent = _a.parent;
  if (kind === ts.SyntaxKind.OpenBraceToken)
    return parent.kind !== ts.SyntaxKind.JsxExpression || parent.parent.kind !== ts.SyntaxKind.JsxElement;
  if (kind === ts.SyntaxKind.LessThanToken) {
    if (parent.kind === ts.SyntaxKind.JsxClosingElement)
      return false;
    if (parent.kind === ts.SyntaxKind.JsxOpeningElement || parent.kind === ts.SyntaxKind.JsxSelfClosingElement)
      return parent.parent.parent.kind !== ts.SyntaxKind.JsxElement;
  }
  return kind !== ts.SyntaxKind.JsxText;
}
function canHaveTrailingTrivia(_a) {
  var kind = _a.kind,
      parent = _a.parent;
  if (kind === ts.SyntaxKind.CloseBraceToken)
    return parent.kind !== ts.SyntaxKind.JsxExpression || parent.parent.kind !== ts.SyntaxKind.JsxElement;
  if (kind === ts.SyntaxKind.GreaterThanToken) {
    if (parent.kind === ts.SyntaxKind.JsxOpeningElement)
      return false;
    if (parent.kind === ts.SyntaxKind.JsxClosingElement || parent.kind === ts.SyntaxKind.JsxSelfClosingElement)
      return parent.parent.parent.kind !== ts.SyntaxKind.JsxElement;
  }
  return kind !== ts.SyntaxKind.JsxText;
}
function endsControlFlow(statement) {
  return getControlFlowEnd(statement) !== 0;
}
exports.endsControlFlow = endsControlFlow;
var StatementType;
(function(StatementType) {
  StatementType[StatementType["None"] = 0] = "None";
  StatementType[StatementType["Break"] = 1] = "Break";
  StatementType[StatementType["Other"] = 2] = "Other";
})(StatementType || (StatementType = {}));
function getControlFlowEnd(statement) {
  while (node_1.isBlockLike(statement)) {
    if (statement.statements.length === 0)
      return 0;
    statement = statement.statements[statement.statements.length - 1];
  }
  return hasReturnBreakContinueThrow(statement);
}
function hasReturnBreakContinueThrow(statement) {
  switch (statement.kind) {
    case ts.SyntaxKind.ReturnStatement:
    case ts.SyntaxKind.ContinueStatement:
    case ts.SyntaxKind.ThrowStatement:
      return 2;
    case ts.SyntaxKind.BreakStatement:
      return 1;
  }
  if (node_1.isIfStatement(statement)) {
    if (statement.elseStatement === undefined)
      return 0;
    var then = getControlFlowEnd(statement.thenStatement);
    if (!then)
      return then;
    return Math.min(then, getControlFlowEnd(statement.elseStatement));
  }
  if (node_1.isSwitchStatement(statement)) {
    var hasDefault = false;
    var type = 0;
    for (var _i = 0,
        _a = statement.caseBlock.clauses; _i < _a.length; _i++) {
      var clause = _a[_i];
      type = getControlFlowEnd(clause);
      if (type === 1)
        return 0;
      if (clause.kind === ts.SyntaxKind.DefaultClause)
        hasDefault = true;
    }
    return hasDefault && type !== 0 ? 2 : 0;
  }
  return 0;
}
function getLineRanges(sourceFile) {
  var lineStarts = sourceFile.getLineStarts();
  var result = [];
  var length = lineStarts.length;
  var sourceText = sourceFile.text;
  var pos = 0;
  for (var i = 1; i < length; ++i) {
    var end = lineStarts[i];
    var lineEnd = end;
    for (; lineEnd > pos; --lineEnd)
      if (!ts.isLineBreak(sourceText.charCodeAt(lineEnd - 1)))
        break;
    result.push({
      pos: pos,
      end: end,
      contentLength: lineEnd - pos
    });
    pos = end;
  }
  result.push({
    pos: pos,
    end: sourceFile.end,
    contentLength: sourceFile.end - pos
  });
  return result;
}
exports.getLineRanges = getLineRanges;
var cachedScanner;
function scanToken(text) {
  if (cachedScanner === undefined)
    cachedScanner = ts.createScanner(ts.ScriptTarget.Latest, false);
  cachedScanner.setText(text);
  cachedScanner.scan();
  return cachedScanner;
}
function isValidIdentifier(text) {
  var scan = scanToken(text);
  return scan.isIdentifier() && scan.getTextPos() === text.length;
}
exports.isValidIdentifier = isValidIdentifier;
function isValidPropertyAccess(text) {
  if (!ts.isIdentifierStart(text.charCodeAt(0), ts.ScriptTarget.Latest))
    return false;
  for (var i = 1; i < text.length; ++i)
    if (!ts.isIdentifierPart(text.charCodeAt(i), ts.ScriptTarget.Latest))
      return false;
  return true;
}
exports.isValidPropertyAccess = isValidPropertyAccess;
function isValidPropertyName(text) {
  if (isValidPropertyAccess(text))
    return true;
  var scan = scanToken(text);
  return scan.getTextPos() === text.length && scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTokenValue() === text;
}
exports.isValidPropertyName = isValidPropertyName;
function isValidNumericLiteral(text) {
  var scan = scanToken(text);
  return scan.getToken() === ts.SyntaxKind.NumericLiteral && scan.getTextPos() === text.length;
}
exports.isValidNumericLiteral = isValidNumericLiteral;
function isSameLine(sourceFile, pos1, pos2) {
  return ts.getLineAndCharacterOfPosition(sourceFile, pos1).line === ts.getLineAndCharacterOfPosition(sourceFile, pos2).line;
}
exports.isSameLine = isSameLine;
var SideEffectOptions;
(function(SideEffectOptions) {
  SideEffectOptions[SideEffectOptions["None"] = 0] = "None";
  SideEffectOptions[SideEffectOptions["TaggedTemplate"] = 1] = "TaggedTemplate";
  SideEffectOptions[SideEffectOptions["Constructor"] = 2] = "Constructor";
  SideEffectOptions[SideEffectOptions["JsxElement"] = 4] = "JsxElement";
})(SideEffectOptions = exports.SideEffectOptions || (exports.SideEffectOptions = {}));
function hasSideEffects(node, options) {
  switch (node.kind) {
    case ts.SyntaxKind.CallExpression:
    case ts.SyntaxKind.PostfixUnaryExpression:
    case ts.SyntaxKind.AwaitExpression:
    case ts.SyntaxKind.YieldExpression:
    case ts.SyntaxKind.DeleteExpression:
      return true;
    case ts.SyntaxKind.TypeAssertionExpression:
    case ts.SyntaxKind.AsExpression:
    case ts.SyntaxKind.ParenthesizedExpression:
    case ts.SyntaxKind.NonNullExpression:
    case ts.SyntaxKind.VoidExpression:
    case ts.SyntaxKind.TypeOfExpression:
    case ts.SyntaxKind.PropertyAccessExpression:
    case ts.SyntaxKind.SpreadElement:
    case ts.SyntaxKind.PartiallyEmittedExpression:
      return hasSideEffects(node.expression, options);
    case ts.SyntaxKind.BinaryExpression:
      return isAssignmentKind(node.operatorToken.kind) || hasSideEffects(node.left, options) || hasSideEffects(node.right, options);
    case ts.SyntaxKind.PrefixUnaryExpression:
      switch (node.operator) {
        case ts.SyntaxKind.PlusPlusToken:
        case ts.SyntaxKind.MinusMinusToken:
          return true;
        default:
          return hasSideEffects(node.operand, options);
      }
    case ts.SyntaxKind.ElementAccessExpression:
      return hasSideEffects(node.expression, options) || node.argumentExpression !== undefined && hasSideEffects(node.argumentExpression, options);
    case ts.SyntaxKind.ConditionalExpression:
      return hasSideEffects(node.condition, options) || hasSideEffects(node.whenTrue, options) || hasSideEffects(node.whenFalse, options);
    case ts.SyntaxKind.NewExpression:
      if (options & 2 || hasSideEffects(node.expression, options))
        return true;
      if (node.arguments !== undefined)
        for (var _i = 0,
            _a = node.arguments; _i < _a.length; _i++) {
          var child = _a[_i];
          if (hasSideEffects(child, options))
            return true;
        }
      return false;
    case ts.SyntaxKind.TaggedTemplateExpression:
      if (options & 1 || hasSideEffects(node.tag, options))
        return true;
      node = node.template;
    case ts.SyntaxKind.TemplateExpression:
      for (var _b = 0,
          _c = node.templateSpans; _b < _c.length; _b++) {
        var child = _c[_b];
        if (hasSideEffects(child.expression, options))
          return true;
      }
      return false;
    case ts.SyntaxKind.ClassExpression:
      return classExpressionHasSideEffects(node, options);
    case ts.SyntaxKind.ArrayLiteralExpression:
      for (var _d = 0,
          _e = node.elements; _d < _e.length; _d++) {
        var child = _e[_d];
        if (hasSideEffects(child, options))
          return true;
      }
      return false;
    case ts.SyntaxKind.ObjectLiteralExpression:
      for (var _f = 0,
          _g = node.properties; _f < _g.length; _f++) {
        var child = _g[_f];
        if (child.name !== undefined && child.name.kind === ts.SyntaxKind.ComputedPropertyName && hasSideEffects(child.name.expression, options))
          return true;
        switch (child.kind) {
          case ts.SyntaxKind.PropertyAssignment:
            if (hasSideEffects(child.initializer, options))
              return true;
            break;
          case ts.SyntaxKind.SpreadAssignment:
            if (hasSideEffects(child.expression, options))
              return true;
        }
      }
      return false;
    case ts.SyntaxKind.JsxExpression:
      return node.expression !== undefined && hasSideEffects(node.expression, options);
    case ts.SyntaxKind.JsxElement:
      for (var _h = 0,
          _j = node.children; _h < _j.length; _h++) {
        var child = _j[_h];
        if (child.kind !== ts.SyntaxKind.JsxText && hasSideEffects(child, options))
          return true;
      }
      node = node.openingElement;
    case ts.SyntaxKind.JsxSelfClosingElement:
    case ts.SyntaxKind.JsxOpeningElement:
      if (options & 4)
        return true;
      for (var _k = 0,
          _l = getJsxAttributes(node); _k < _l.length; _k++) {
        var child = _l[_k];
        if (child.kind === ts.SyntaxKind.JsxSpreadAttribute) {
          if (hasSideEffects(child.expression, options))
            return true;
        } else if (child.initializer !== undefined && hasSideEffects(child.initializer, options)) {
          return true;
        }
      }
      return false;
    case ts.SyntaxKind.CommaListExpression:
      for (var _m = 0,
          _o = node.elements; _m < _o.length; _m++) {
        var child = _o[_m];
        if (hasSideEffects(child, options))
          return true;
      }
      return false;
    default:
      return false;
  }
}
exports.hasSideEffects = hasSideEffects;
function getJsxAttributes(openElement) {
  var attributes = openElement.attributes;
  return Array.isArray(attributes) ? attributes : attributes.properties;
}
function classExpressionHasSideEffects(node, options) {
  if (node.heritageClauses !== undefined && node.heritageClauses[0].token === ts.SyntaxKind.ExtendsKeyword)
    for (var _i = 0,
        _a = node.heritageClauses[0].types; _i < _a.length; _i++) {
      var base = _a[_i];
      if (hasSideEffects(base.expression, options))
        return true;
    }
  for (var _b = 0,
      _c = node.members; _b < _c.length; _b++) {
    var child = _c[_b];
    if (child.name !== undefined && child.name.kind === ts.SyntaxKind.ComputedPropertyName && hasSideEffects(child.name.expression, options) || node_1.isPropertyDeclaration(child) && child.initializer !== undefined && hasSideEffects(child.initializer, options))
      return true;
  }
  return false;
}
function getDeclarationOfBindingElement(node) {
  var parent = node.parent.parent;
  while (parent.kind === ts.SyntaxKind.BindingElement)
    parent = parent.parent.parent;
  return parent;
}
exports.getDeclarationOfBindingElement = getDeclarationOfBindingElement;
function isExpressionValueUsed(node) {
  while (true) {
    var parent = node.parent;
    switch (parent.kind) {
      case ts.SyntaxKind.CallExpression:
      case ts.SyntaxKind.NewExpression:
      case ts.SyntaxKind.ElementAccessExpression:
      case ts.SyntaxKind.WhileStatement:
      case ts.SyntaxKind.DoStatement:
      case ts.SyntaxKind.WithStatement:
      case ts.SyntaxKind.ThrowStatement:
      case ts.SyntaxKind.ReturnStatement:
      case ts.SyntaxKind.JsxExpression:
      case ts.SyntaxKind.JsxSpreadAttribute:
      case ts.SyntaxKind.JsxElement:
      case ts.SyntaxKind.JsxSelfClosingElement:
      case ts.SyntaxKind.ComputedPropertyName:
      case ts.SyntaxKind.ArrowFunction:
      case ts.SyntaxKind.ExportSpecifier:
      case ts.SyntaxKind.ExportAssignment:
      case ts.SyntaxKind.ImportDeclaration:
      case ts.SyntaxKind.ExternalModuleReference:
      case ts.SyntaxKind.Decorator:
      case ts.SyntaxKind.TaggedTemplateExpression:
      case ts.SyntaxKind.TemplateSpan:
      case ts.SyntaxKind.ExpressionWithTypeArguments:
      case ts.SyntaxKind.TypeOfExpression:
      case ts.SyntaxKind.AwaitExpression:
      case ts.SyntaxKind.YieldExpression:
      case ts.SyntaxKind.LiteralType:
      case ts.SyntaxKind.JsxAttributes:
      case ts.SyntaxKind.JsxOpeningElement:
      case ts.SyntaxKind.JsxClosingElement:
      case ts.SyntaxKind.IfStatement:
      case ts.SyntaxKind.CaseClause:
      case ts.SyntaxKind.SwitchStatement:
        return true;
      case ts.SyntaxKind.PropertyAccessExpression:
        return parent.expression === node;
      case ts.SyntaxKind.QualifiedName:
        return parent.left === node;
      case ts.SyntaxKind.ShorthandPropertyAssignment:
        return parent.objectAssignmentInitializer === node || !isInDestructuringAssignment(parent);
      case ts.SyntaxKind.PropertyAssignment:
        return parent.initializer === node && !isInDestructuringAssignment(parent);
      case ts.SyntaxKind.SpreadAssignment:
      case ts.SyntaxKind.SpreadElement:
      case ts.SyntaxKind.ArrayLiteralExpression:
        return !isInDestructuringAssignment(parent);
      case ts.SyntaxKind.ParenthesizedExpression:
      case ts.SyntaxKind.AsExpression:
      case ts.SyntaxKind.TypeAssertionExpression:
      case ts.SyntaxKind.PostfixUnaryExpression:
      case ts.SyntaxKind.PrefixUnaryExpression:
      case ts.SyntaxKind.NonNullExpression:
        node = parent;
        break;
      case ts.SyntaxKind.ForStatement:
        return parent.condition === node;
      case ts.SyntaxKind.ForInStatement:
      case ts.SyntaxKind.ForOfStatement:
        return parent.expression === node;
      case ts.SyntaxKind.ConditionalExpression:
        if (parent.condition === node)
          return true;
        node = parent;
        break;
      case ts.SyntaxKind.PropertyDeclaration:
      case ts.SyntaxKind.BindingElement:
      case ts.SyntaxKind.VariableDeclaration:
      case ts.SyntaxKind.Parameter:
      case ts.SyntaxKind.EnumMember:
        return parent.initializer === node;
      case ts.SyntaxKind.ImportEqualsDeclaration:
        return parent.moduleReference === node;
      case ts.SyntaxKind.CommaListExpression:
        if (parent.elements[parent.elements.length - 1] !== node)
          return false;
        node = parent;
        break;
      case ts.SyntaxKind.BinaryExpression:
        if (parent.right === node) {
          if (parent.operatorToken.kind === ts.SyntaxKind.CommaToken) {
            node = parent;
            break;
          }
          return true;
        }
        switch (parent.operatorToken.kind) {
          case ts.SyntaxKind.CommaToken:
          case ts.SyntaxKind.EqualsToken:
            return false;
          case ts.SyntaxKind.EqualsEqualsEqualsToken:
          case ts.SyntaxKind.EqualsEqualsToken:
          case ts.SyntaxKind.ExclamationEqualsEqualsToken:
          case ts.SyntaxKind.ExclamationEqualsToken:
          case ts.SyntaxKind.InstanceOfKeyword:
          case ts.SyntaxKind.PlusToken:
          case ts.SyntaxKind.MinusToken:
          case ts.SyntaxKind.AsteriskToken:
          case ts.SyntaxKind.SlashToken:
          case ts.SyntaxKind.PercentToken:
          case ts.SyntaxKind.AsteriskAsteriskToken:
          case ts.SyntaxKind.GreaterThanToken:
          case ts.SyntaxKind.GreaterThanGreaterThanToken:
          case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
          case ts.SyntaxKind.GreaterThanEqualsToken:
          case ts.SyntaxKind.LessThanToken:
          case ts.SyntaxKind.LessThanLessThanToken:
          case ts.SyntaxKind.LessThanEqualsToken:
          case ts.SyntaxKind.AmpersandToken:
          case ts.SyntaxKind.BarToken:
          case ts.SyntaxKind.CaretToken:
          case ts.SyntaxKind.BarBarToken:
          case ts.SyntaxKind.AmpersandAmpersandToken:
          case ts.SyntaxKind.InKeyword:
            return true;
          default:
            node = parent;
        }
        break;
      default:
        return false;
    }
  }
}
exports.isExpressionValueUsed = isExpressionValueUsed;
function isInDestructuringAssignment(node) {
  switch (node.kind) {
    case ts.SyntaxKind.ShorthandPropertyAssignment:
      if (node.objectAssignmentInitializer !== undefined)
        return true;
    case ts.SyntaxKind.PropertyAssignment:
    case ts.SyntaxKind.SpreadAssignment:
      node = node.parent;
      break;
    case ts.SyntaxKind.SpreadElement:
      if (node.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression)
        return false;
      node = node.parent;
  }
  while (true) {
    switch (node.parent.kind) {
      case ts.SyntaxKind.BinaryExpression:
        return node.parent.left === node && node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken;
      case ts.SyntaxKind.ForOfStatement:
        return node.parent.initializer === node;
      case ts.SyntaxKind.ArrayLiteralExpression:
      case ts.SyntaxKind.ObjectLiteralExpression:
        node = node.parent;
        break;
      case ts.SyntaxKind.SpreadAssignment:
      case ts.SyntaxKind.PropertyAssignment:
        node = node.parent.parent;
        break;
      case ts.SyntaxKind.SpreadElement:
        if (node.parent.parent.kind !== ts.SyntaxKind.ArrayLiteralExpression)
          return false;
        node = node.parent.parent;
        break;
      default:
        return false;
    }
  }
}
function isReassignmentTarget(node) {
  var parent = node.parent;
  switch (parent.kind) {
    case ts.SyntaxKind.PostfixUnaryExpression:
    case ts.SyntaxKind.DeleteExpression:
      return true;
    case ts.SyntaxKind.PrefixUnaryExpression:
      return parent.operator === ts.SyntaxKind.PlusPlusToken || parent.operator === ts.SyntaxKind.MinusMinusToken;
    case ts.SyntaxKind.BinaryExpression:
      return parent.left === node && isAssignmentKind(parent.operatorToken.kind);
    case ts.SyntaxKind.ShorthandPropertyAssignment:
      return parent.name === node && isInDestructuringAssignment(parent);
    case ts.SyntaxKind.PropertyAssignment:
      return parent.initializer === node && isInDestructuringAssignment(parent);
    case ts.SyntaxKind.ObjectLiteralExpression:
    case ts.SyntaxKind.ArrayLiteralExpression:
    case ts.SyntaxKind.SpreadElement:
    case ts.SyntaxKind.SpreadAssignment:
      return isInDestructuringAssignment(parent);
    case ts.SyntaxKind.ParenthesizedExpression:
      return isReassignmentTarget(parent);
    case ts.SyntaxKind.ForOfStatement:
    case ts.SyntaxKind.ForInStatement:
      return parent.initializer === node;
  }
  return false;
}
exports.isReassignmentTarget = isReassignmentTarget;
