/* */ 
"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
var tslib_1 = require('../../tslib/tslib');
var util_1 = require('./util');
var ts = require('../../typescript/lib/typescript');
var DeclarationDomain;
(function(DeclarationDomain) {
  DeclarationDomain[DeclarationDomain["Namespace"] = 1] = "Namespace";
  DeclarationDomain[DeclarationDomain["Type"] = 2] = "Type";
  DeclarationDomain[DeclarationDomain["Value"] = 4] = "Value";
  DeclarationDomain[DeclarationDomain["Import"] = 8] = "Import";
  DeclarationDomain[DeclarationDomain["Any"] = 7] = "Any";
})(DeclarationDomain = exports.DeclarationDomain || (exports.DeclarationDomain = {}));
var UsageDomain;
(function(UsageDomain) {
  UsageDomain[UsageDomain["Namespace"] = 1] = "Namespace";
  UsageDomain[UsageDomain["Type"] = 2] = "Type";
  UsageDomain[UsageDomain["Value"] = 4] = "Value";
  UsageDomain[UsageDomain["ValueOrNamespace"] = 5] = "ValueOrNamespace";
  UsageDomain[UsageDomain["Any"] = 7] = "Any";
  UsageDomain[UsageDomain["TypeQuery"] = 8] = "TypeQuery";
})(UsageDomain = exports.UsageDomain || (exports.UsageDomain = {}));
function getUsageDomain(node) {
  var parent = node.parent;
  switch (parent.kind) {
    case ts.SyntaxKind.TypeReference:
    case ts.SyntaxKind.TypeOperator:
      return 2;
    case ts.SyntaxKind.ExpressionWithTypeArguments:
      return parent.parent.token === ts.SyntaxKind.ImplementsKeyword || parent.parent.parent.kind === ts.SyntaxKind.InterfaceDeclaration ? 2 : 4;
    case ts.SyntaxKind.TypeQuery:
      return 5 | 8;
    case ts.SyntaxKind.QualifiedName:
      if (parent.left === node) {
        if (getEntityNameParent(parent).kind === ts.SyntaxKind.TypeQuery)
          return 1 | 8;
        return 1;
      }
      break;
    case ts.SyntaxKind.NamespaceExportDeclaration:
      return 1;
    case ts.SyntaxKind.ExportSpecifier:
      if (parent.propertyName === undefined || parent.propertyName === node)
        return 7;
      break;
    case ts.SyntaxKind.ExportAssignment:
      return 7;
    case ts.SyntaxKind.BindingElement:
      if (parent.initializer === node)
        return 5;
      break;
    case ts.SyntaxKind.Parameter:
    case ts.SyntaxKind.EnumMember:
    case ts.SyntaxKind.PropertyDeclaration:
    case ts.SyntaxKind.VariableDeclaration:
    case ts.SyntaxKind.PropertyAssignment:
    case ts.SyntaxKind.PropertyAccessExpression:
    case ts.SyntaxKind.ImportEqualsDeclaration:
      if (parent.name !== node)
        return 5;
      break;
    case ts.SyntaxKind.JsxAttribute:
    case ts.SyntaxKind.FunctionDeclaration:
    case ts.SyntaxKind.FunctionExpression:
    case ts.SyntaxKind.NamespaceImport:
    case ts.SyntaxKind.ClassDeclaration:
    case ts.SyntaxKind.ClassExpression:
    case ts.SyntaxKind.ModuleDeclaration:
    case ts.SyntaxKind.MethodDeclaration:
    case ts.SyntaxKind.EnumDeclaration:
    case ts.SyntaxKind.GetAccessor:
    case ts.SyntaxKind.SetAccessor:
    case ts.SyntaxKind.LabeledStatement:
    case ts.SyntaxKind.BreakStatement:
    case ts.SyntaxKind.ContinueStatement:
    case ts.SyntaxKind.ImportClause:
    case ts.SyntaxKind.ImportSpecifier:
    case ts.SyntaxKind.TypePredicate:
    case ts.SyntaxKind.MethodSignature:
    case ts.SyntaxKind.PropertySignature:
    case ts.SyntaxKind.NamespaceExportDeclaration:
    case ts.SyntaxKind.QualifiedName:
    case ts.SyntaxKind.TypeReference:
    case ts.SyntaxKind.TypeOperator:
    case ts.SyntaxKind.InterfaceDeclaration:
    case ts.SyntaxKind.TypeAliasDeclaration:
    case ts.SyntaxKind.TypeParameter:
      break;
    default:
      return 5;
  }
}
exports.getUsageDomain = getUsageDomain;
function getDeclarationDomain(node) {
  switch (node.parent.kind) {
    case ts.SyntaxKind.TypeParameter:
    case ts.SyntaxKind.InterfaceDeclaration:
    case ts.SyntaxKind.TypeAliasDeclaration:
      return 2;
    case ts.SyntaxKind.ClassDeclaration:
    case ts.SyntaxKind.ClassExpression:
      return 2 | 4;
    case ts.SyntaxKind.EnumDeclaration:
      return 7;
    case ts.SyntaxKind.NamespaceImport:
    case ts.SyntaxKind.ImportClause:
      return 7 | 8;
    case ts.SyntaxKind.ImportEqualsDeclaration:
    case ts.SyntaxKind.ImportSpecifier:
      return node.parent.name === node ? 7 | 8 : undefined;
    case ts.SyntaxKind.ModuleDeclaration:
      return 1;
    case ts.SyntaxKind.Parameter:
      if (node.parent.parent.kind === ts.SyntaxKind.IndexSignature)
        return;
    case ts.SyntaxKind.BindingElement:
    case ts.SyntaxKind.VariableDeclaration:
      return node.parent.name === node ? 4 : undefined;
    case ts.SyntaxKind.FunctionDeclaration:
    case ts.SyntaxKind.FunctionExpression:
      return 4;
  }
}
exports.getDeclarationDomain = getDeclarationDomain;
function collectVariableUsage(sourceFile) {
  return new UsageWalker().getUsage(sourceFile);
}
exports.collectVariableUsage = collectVariableUsage;
var AbstractScope = (function() {
  function AbstractScope(_global) {
    this._global = _global;
    this._variables = new Map();
    this._uses = [];
    this._namespaceScopes = undefined;
    this._enumScopes = undefined;
  }
  AbstractScope.prototype.addVariable = function(identifier, name, blockScoped, exported, domain) {
    var variables = this._getDestinationScope(blockScoped).getVariables();
    var declaration = {
      domain: domain,
      exported: exported,
      declaration: name
    };
    var variable = variables.get(identifier);
    if (variable === undefined) {
      variables.set(identifier, {
        domain: domain,
        declarations: [declaration],
        uses: []
      });
    } else {
      variable.domain |= domain;
      variable.declarations.push(declaration);
    }
  };
  AbstractScope.prototype.addUse = function(use) {
    this._uses.push(use);
  };
  AbstractScope.prototype.getVariables = function() {
    return this._variables;
  };
  AbstractScope.prototype.getFunctionScope = function() {
    return this;
  };
  AbstractScope.prototype.end = function(cb) {
    var _this = this;
    if (this._namespaceScopes !== undefined)
      this._namespaceScopes.forEach(function(value) {
        return value.finish(cb);
      });
    this._namespaceScopes = this._enumScopes = undefined;
    this._applyUses();
    this._variables.forEach(function(variable) {
      for (var _i = 0,
          _a = variable.declarations; _i < _a.length; _i++) {
        var declaration = _a[_i];
        var result = {
          declarations: [],
          domain: declaration.domain,
          exported: declaration.exported,
          inGlobalScope: _this._global,
          uses: []
        };
        for (var _b = 0,
            _c = variable.declarations; _b < _c.length; _b++) {
          var other = _c[_b];
          if (other.domain & declaration.domain)
            result.declarations.push(other.declaration);
        }
        for (var _d = 0,
            _e = variable.uses; _d < _e.length; _d++) {
          var use = _e[_d];
          if (use.domain & declaration.domain)
            result.uses.push(use);
        }
        cb(result, declaration.declaration, _this);
      }
    });
  };
  AbstractScope.prototype.markExported = function(_name) {};
  AbstractScope.prototype.createOrReuseNamespaceScope = function(name, _exported, ambient, hasExportStatement) {
    var scope;
    if (this._namespaceScopes === undefined) {
      this._namespaceScopes = new Map();
    } else {
      scope = this._namespaceScopes.get(name);
    }
    if (scope === undefined) {
      scope = new NamespaceScope(ambient, hasExportStatement, this);
      this._namespaceScopes.set(name, scope);
    } else {
      scope.refresh(ambient, hasExportStatement);
    }
    return scope;
  };
  AbstractScope.prototype.createOrReuseEnumScope = function(name, _exported) {
    var scope;
    if (this._enumScopes === undefined) {
      this._enumScopes = new Map();
    } else {
      scope = this._enumScopes.get(name);
    }
    if (scope === undefined) {
      scope = new EnumScope(this);
      this._enumScopes.set(name, scope);
    }
    return scope;
  };
  AbstractScope.prototype._applyUses = function() {
    for (var _i = 0,
        _a = this._uses; _i < _a.length; _i++) {
      var use = _a[_i];
      if (!this._applyUse(use))
        this._addUseToParent(use);
    }
  };
  AbstractScope.prototype._applyUse = function(use, variables) {
    if (variables === void 0) {
      variables = this._variables;
    }
    var variable = variables.get(use.location.text);
    if (variable === undefined || (variable.domain & use.domain) === 0)
      return false;
    variable.uses.push(use);
    return true;
  };
  AbstractScope.prototype._getDestinationScope = function(_blockScoped) {
    return this;
  };
  AbstractScope.prototype._addUseToParent = function(_use) {};
  return AbstractScope;
}());
var RootScope = (function(_super) {
  tslib_1.__extends(RootScope, _super);
  function RootScope(_exportAll, global) {
    var _this = _super.call(this, global) || this;
    _this._exportAll = _exportAll;
    _this._exports = undefined;
    _this._innerScope = new NonRootScope(_this);
    return _this;
  }
  RootScope.prototype.addVariable = function(identifier, name, blockScoped, exported, domain) {
    if (domain & 8)
      return _super.prototype.addVariable.call(this, identifier, name, blockScoped, exported, domain);
    return this._innerScope.addVariable(identifier, name, blockScoped, exported, domain);
  };
  RootScope.prototype.addUse = function(use, origin) {
    if (origin === this._innerScope)
      return _super.prototype.addUse.call(this, use);
    return this._innerScope.addUse(use);
  };
  RootScope.prototype.markExported = function(_a) {
    var text = _a.text;
    if (this._exports === undefined) {
      this._exports = [text];
    } else {
      this._exports.push(text);
    }
  };
  RootScope.prototype.end = function(cb) {
    var _this = this;
    this._innerScope.end(function(value, key) {
      value.exported = value.exported || _this._exportAll || _this._exports !== undefined && _this._exports.indexOf(key.text) !== -1;
      value.inGlobalScope = _this._global;
      return cb(value, key, _this);
    });
    return _super.prototype.end.call(this, function(value, key, scope) {
      value.exported = value.exported || scope === _this && _this._exports !== undefined && _this._exports.indexOf(key.text) !== -1;
      return cb(value, key, scope);
    });
  };
  return RootScope;
}(AbstractScope));
var NonRootScope = (function(_super) {
  tslib_1.__extends(NonRootScope, _super);
  function NonRootScope(_parent) {
    var _this = _super.call(this, false) || this;
    _this._parent = _parent;
    return _this;
  }
  NonRootScope.prototype._addUseToParent = function(use) {
    return this._parent.addUse(use, this);
  };
  return NonRootScope;
}(AbstractScope));
var EnumScope = (function(_super) {
  tslib_1.__extends(EnumScope, _super);
  function EnumScope() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  EnumScope.prototype.end = function() {
    this._applyUses();
    this._uses = [];
  };
  return EnumScope;
}(NonRootScope));
var FunctionScopeState;
(function(FunctionScopeState) {
  FunctionScopeState[FunctionScopeState["Initial"] = 0] = "Initial";
  FunctionScopeState[FunctionScopeState["Parameter"] = 1] = "Parameter";
  FunctionScopeState[FunctionScopeState["ReturnType"] = 2] = "ReturnType";
  FunctionScopeState[FunctionScopeState["Body"] = 3] = "Body";
})(FunctionScopeState || (FunctionScopeState = {}));
var FunctionScope = (function(_super) {
  tslib_1.__extends(FunctionScope, _super);
  function FunctionScope() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._innerScope = new NonRootScope(_this);
    _this._state = 0;
    return _this;
  }
  FunctionScope.prototype.end = function(cb) {
    this._innerScope.end(cb);
    _super.prototype.end.call(this, cb);
  };
  FunctionScope.prototype.updateState = function(newState) {
    this._state = newState;
  };
  FunctionScope.prototype.addUse = function(use, source) {
    if (source === this._innerScope)
      return void this._uses.push(use);
    switch (this._state) {
      case 1:
        if ((use.domain & 4) === 0 || use.domain & 8)
          return void this._uses.push(use);
        if (this._applyUse(use) || this._applyUse(use, this._innerScope.getVariables()))
          return;
        break;
      case 2:
        if (this._applyUse(use))
          return;
        break;
      case 3:
        return this._innerScope.addUse(use);
      case 0:
        return void this._uses.push(use);
    }
    return this._parent.addUse(use, this);
  };
  FunctionScope.prototype._getDestinationScope = function(blockScoped) {
    return blockScoped ? this._innerScope : this;
  };
  return FunctionScope;
}(NonRootScope));
var AbstractNamedExpressionScope = (function(_super) {
  tslib_1.__extends(AbstractNamedExpressionScope, _super);
  function AbstractNamedExpressionScope(_name, _domain, parent) {
    var _this = _super.call(this, parent) || this;
    _this._name = _name;
    _this._domain = _domain;
    return _this;
  }
  AbstractNamedExpressionScope.prototype.end = function(cb) {
    this._innerScope.end(cb);
    return cb({
      declarations: [this._name],
      domain: this._domain,
      exported: false,
      uses: this._uses,
      inGlobalScope: false
    }, this._name, this);
  };
  AbstractNamedExpressionScope.prototype.addUse = function(use, source) {
    if (source !== this._innerScope)
      return this._innerScope.addUse(use);
    if (use.domain & this._domain && use.location.text === this._name.text) {
      this._uses.push(use);
    } else {
      return this._parent.addUse(use, this);
    }
  };
  AbstractNamedExpressionScope.prototype.getFunctionScope = function() {
    return this._innerScope;
  };
  AbstractNamedExpressionScope.prototype._getDestinationScope = function() {
    return this._innerScope;
  };
  return AbstractNamedExpressionScope;
}(NonRootScope));
var FunctionExpressionScope = (function(_super) {
  tslib_1.__extends(FunctionExpressionScope, _super);
  function FunctionExpressionScope(name, parent) {
    var _this = _super.call(this, name, 4, parent) || this;
    _this._innerScope = new FunctionScope(_this);
    return _this;
  }
  FunctionExpressionScope.prototype.updateState = function(newState) {
    return this._innerScope.updateState(newState);
  };
  return FunctionExpressionScope;
}(AbstractNamedExpressionScope));
var ClassExpressionScope = (function(_super) {
  tslib_1.__extends(ClassExpressionScope, _super);
  function ClassExpressionScope(name, parent) {
    var _this = _super.call(this, name, 4 | 2, parent) || this;
    _this._innerScope = new NonRootScope(_this);
    return _this;
  }
  return ClassExpressionScope;
}(AbstractNamedExpressionScope));
var BlockScope = (function(_super) {
  tslib_1.__extends(BlockScope, _super);
  function BlockScope(_functionScope, parent) {
    var _this = _super.call(this, parent) || this;
    _this._functionScope = _functionScope;
    return _this;
  }
  BlockScope.prototype.getFunctionScope = function() {
    return this._functionScope;
  };
  BlockScope.prototype._getDestinationScope = function(blockScoped) {
    return blockScoped ? this : this._functionScope;
  };
  return BlockScope;
}(NonRootScope));
function mapDeclaration(declaration) {
  return {
    declaration: declaration,
    exported: true,
    domain: getDeclarationDomain(declaration)
  };
}
var NamespaceScope = (function(_super) {
  tslib_1.__extends(NamespaceScope, _super);
  function NamespaceScope(_ambient, _hasExport, parent) {
    var _this = _super.call(this, parent) || this;
    _this._ambient = _ambient;
    _this._hasExport = _hasExport;
    _this._innerScope = new NonRootScope(_this);
    _this._exports = undefined;
    return _this;
  }
  NamespaceScope.prototype.finish = function(cb) {
    return _super.prototype.end.call(this, cb);
  };
  NamespaceScope.prototype.end = function(cb) {
    var _this = this;
    this._innerScope.end(function(variable, key, scope) {
      if (scope !== _this._innerScope || !variable.exported && (!_this._ambient || _this._exports !== undefined && !_this._exports.has(key.text)))
        return cb(variable, key, scope);
      var namespaceVar = _this._variables.get(key.text);
      if (namespaceVar === undefined) {
        _this._variables.set(key.text, {
          declarations: variable.declarations.map(mapDeclaration),
          domain: variable.domain,
          uses: variable.uses.slice()
        });
      } else {
        outer: for (var _i = 0,
            _a = variable.declarations; _i < _a.length; _i++) {
          var declaration = _a[_i];
          for (var _b = 0,
              _c = namespaceVar.declarations; _b < _c.length; _b++) {
            var existing = _c[_b];
            if (existing.declaration === declaration)
              continue outer;
          }
          namespaceVar.declarations.push(mapDeclaration(declaration));
        }
        namespaceVar.domain |= variable.domain;
        for (var _d = 0,
            _e = variable.uses; _d < _e.length; _d++) {
          var use = _e[_d];
          if (namespaceVar.uses.indexOf(use) !== -1)
            continue;
          namespaceVar.uses.push(use);
        }
      }
    });
    this._applyUses();
    this._innerScope = new NonRootScope(this);
    this._uses = [];
  };
  NamespaceScope.prototype.createOrReuseNamespaceScope = function(name, exported, ambient, hasExportStatement) {
    if (!exported && (!this._ambient || this._hasExport))
      return this._innerScope.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);
    return _super.prototype.createOrReuseNamespaceScope.call(this, name, exported, ambient || this._ambient, hasExportStatement);
  };
  NamespaceScope.prototype.createOrReuseEnumScope = function(name, exported) {
    if (!exported && (!this._ambient || this._hasExport))
      return this._innerScope.createOrReuseEnumScope(name, exported);
    return _super.prototype.createOrReuseEnumScope.call(this, name, exported);
  };
  NamespaceScope.prototype.addUse = function(use, source) {
    if (source !== this._innerScope)
      return this._innerScope.addUse(use);
    this._uses.push(use);
  };
  NamespaceScope.prototype.refresh = function(ambient, hasExport) {
    this._ambient = ambient;
    this._hasExport = hasExport;
  };
  NamespaceScope.prototype.markExported = function(name, _as) {
    if (this._exports === undefined)
      this._exports = new Set();
    this._exports.add(name.text);
  };
  NamespaceScope.prototype._getDestinationScope = function() {
    return this._innerScope;
  };
  return NamespaceScope;
}(NonRootScope));
function getEntityNameParent(name) {
  var parent = name.parent;
  while (parent.kind === ts.SyntaxKind.QualifiedName)
    parent = parent.parent;
  return parent;
}
var UsageWalker = (function() {
  function UsageWalker() {
    this._result = new Map();
  }
  UsageWalker.prototype.getUsage = function(sourceFile) {
    var _this = this;
    var variableCallback = function(variable, key) {
      _this._result.set(key, variable);
    };
    var isModule = ts.isExternalModule(sourceFile);
    this._scope = new RootScope(sourceFile.isDeclarationFile && isModule && !containsExportStatement(sourceFile), !isModule);
    var cb = function(node) {
      if (util_1.isBlockScopeBoundary(node)) {
        if (node.kind === ts.SyntaxKind.CatchClause)
          _this._handleBindingName(node.variableDeclaration.name, true, false);
        return continueWithScope(node, new BlockScope(_this._scope.getFunctionScope(), _this._scope));
      }
      switch (node.kind) {
        case ts.SyntaxKind.ClassExpression:
          return continueWithScope(node, node.name !== undefined ? new ClassExpressionScope(node.name, _this._scope) : new NonRootScope(_this._scope));
        case ts.SyntaxKind.ClassDeclaration:
          _this._handleDeclaration(node, true, 4 | 2);
          return continueWithScope(node, new NonRootScope(_this._scope));
        case ts.SyntaxKind.InterfaceDeclaration:
        case ts.SyntaxKind.TypeAliasDeclaration:
          _this._handleDeclaration(node, true, 2);
          return continueWithScope(node, new NonRootScope(_this._scope));
        case ts.SyntaxKind.EnumDeclaration:
          _this._handleDeclaration(node, true, 7);
          return continueWithScope(node, _this._scope.createOrReuseEnumScope(node.name.text, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)));
        case ts.SyntaxKind.ModuleDeclaration:
          return _this._handleModule(node, continueWithScope);
        case ts.SyntaxKind.MappedType:
          return continueWithScope(node, new NonRootScope(_this._scope));
        case ts.SyntaxKind.FunctionExpression:
        case ts.SyntaxKind.ArrowFunction:
        case ts.SyntaxKind.Constructor:
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.FunctionDeclaration:
        case ts.SyntaxKind.GetAccessor:
        case ts.SyntaxKind.SetAccessor:
        case ts.SyntaxKind.MethodSignature:
        case ts.SyntaxKind.CallSignature:
        case ts.SyntaxKind.ConstructSignature:
        case ts.SyntaxKind.ConstructorType:
        case ts.SyntaxKind.FunctionType:
          return _this._handleFunctionLikeDeclaration(node, cb, variableCallback);
        case ts.SyntaxKind.VariableDeclarationList:
          _this._handleVariableDeclaration(node);
          break;
        case ts.SyntaxKind.Parameter:
          if (node.parent.kind !== ts.SyntaxKind.IndexSignature && (node.name.kind !== ts.SyntaxKind.Identifier || node.name.originalKeywordKind !== ts.SyntaxKind.ThisKeyword))
            _this._handleBindingName(node.name, false, false, true);
          break;
        case ts.SyntaxKind.EnumMember:
          _this._scope.addVariable(util_1.getPropertyName(node.name), node.name, false, true, 4);
          break;
        case ts.SyntaxKind.ImportClause:
        case ts.SyntaxKind.ImportSpecifier:
        case ts.SyntaxKind.NamespaceImport:
        case ts.SyntaxKind.ImportEqualsDeclaration:
          _this._handleDeclaration(node, false, 7 | 8);
          break;
        case ts.SyntaxKind.TypeParameter:
          _this._scope.addVariable(node.name.text, node.name, false, false, 2);
          break;
        case ts.SyntaxKind.ExportSpecifier:
          if (node.propertyName !== undefined)
            return _this._scope.markExported(node.propertyName, node.name);
          return _this._scope.markExported(node.name);
        case ts.SyntaxKind.ExportAssignment:
          if (node.expression.kind === ts.SyntaxKind.Identifier)
            return _this._scope.markExported(node.expression);
          break;
        case ts.SyntaxKind.Identifier:
          var domain = getUsageDomain(node);
          if (domain !== undefined)
            _this._scope.addUse({
              domain: domain,
              location: node
            });
          return;
      }
      return ts.forEachChild(node, cb);
    };
    var continueWithScope = function(node, scope) {
      var savedScope = _this._scope;
      _this._scope = scope;
      ts.forEachChild(node, cb);
      _this._scope.end(variableCallback);
      _this._scope = savedScope;
    };
    ts.forEachChild(sourceFile, cb);
    this._scope.end(variableCallback);
    return this._result;
  };
  UsageWalker.prototype._handleFunctionLikeDeclaration = function(node, cb, varCb) {
    var savedScope = this._scope;
    if (node.kind === ts.SyntaxKind.FunctionDeclaration)
      this._handleDeclaration(node, false, 4);
    var scope = this._scope = node.kind === ts.SyntaxKind.FunctionExpression && node.name !== undefined ? new FunctionExpressionScope(node.name, savedScope) : new FunctionScope(savedScope);
    if (node.decorators !== undefined)
      for (var _i = 0,
          _a = node.decorators; _i < _a.length; _i++) {
        var decorator = _a[_i];
        cb(decorator);
      }
    if (node.name !== undefined)
      cb(node.name);
    if (node.typeParameters !== undefined)
      for (var _b = 0,
          _c = node.typeParameters; _b < _c.length; _b++) {
        var param = _c[_b];
        cb(param);
      }
    scope.updateState(1);
    for (var _d = 0,
        _e = node.parameters; _d < _e.length; _d++) {
      var param = _e[_d];
      cb(param);
    }
    if (node.type !== undefined) {
      scope.updateState(2);
      cb(node.type);
    }
    if (node.body !== undefined) {
      scope.updateState(3);
      cb(node.body);
    }
    scope.end(varCb);
    this._scope = savedScope;
  };
  UsageWalker.prototype._handleModule = function(node, next) {
    if (node.name.kind === ts.SyntaxKind.Identifier) {
      var exported = isNamespaceExported(node);
      this._scope.addVariable(node.name.text, node.name, false, exported, 1 | 4);
      var ambient = util_1.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword);
      return next(node, this._scope.createOrReuseNamespaceScope(node.name.text, exported, ambient, ambient && namespaceHasExportStatement(node)));
    }
    return next(node, this._scope.createOrReuseNamespaceScope("\"" + node.name.text + "\"", false, true, namespaceHasExportStatement(node)));
  };
  UsageWalker.prototype._handleDeclaration = function(node, blockScoped, domain) {
    if (node.name !== undefined)
      this._scope.addVariable(node.name.text, node.name, blockScoped, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword), domain);
  };
  UsageWalker.prototype._handleBindingName = function(name, blockScoped, exported, isParameter) {
    var _this = this;
    if (name.kind === ts.SyntaxKind.Identifier)
      return this._scope.addVariable(name.text, name, blockScoped, exported, 4);
    util_1.forEachDestructuringIdentifier(name, function(declaration) {
      _this._scope.addVariable(declaration.name.text, declaration.name, isParameter || blockScoped, exported, 4);
    });
  };
  UsageWalker.prototype._handleVariableDeclaration = function(declarationList) {
    var blockScoped = util_1.isBlockScopedVariableDeclarationList(declarationList);
    var exported = declarationList.parent.kind === ts.SyntaxKind.VariableStatement && util_1.hasModifier(declarationList.parent.modifiers, ts.SyntaxKind.ExportKeyword);
    for (var _i = 0,
        _a = declarationList.declarations; _i < _a.length; _i++) {
      var declaration = _a[_i];
      this._handleBindingName(declaration.name, blockScoped, exported);
    }
  };
  return UsageWalker;
}());
function isNamespaceExported(node) {
  return node.parent.kind === ts.SyntaxKind.ModuleDeclaration || util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword);
}
function namespaceHasExportStatement(ns) {
  if (ns.body === undefined || ns.body.kind !== ts.SyntaxKind.ModuleBlock)
    return false;
  return containsExportStatement(ns.body);
}
function containsExportStatement(block) {
  for (var _i = 0,
      _a = block.statements; _i < _a.length; _i++) {
    var statement = _a[_i];
    if (statement.kind === ts.SyntaxKind.ExportDeclaration || statement.kind === ts.SyntaxKind.ExportAssignment)
      return true;
  }
  return false;
}
