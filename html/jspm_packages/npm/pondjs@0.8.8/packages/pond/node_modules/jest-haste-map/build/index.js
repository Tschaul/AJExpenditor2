/* */ 
(function(process) {
  'use strict';
  const EventEmitter = require('events');
  const os = require('os');
  const path = require('path');
  const crypto = require('crypto');
  var _require = require('child_process');
  const execSync = _require.execSync;
  const fs = require('../../graceful-fs/graceful-fs');
  const sane = require('../../sane/index');
  const workerFarm = require('../../worker-farm/lib/index');
  const VERSION = require('../package.json!systemjs-json').version;
  const H = require('./constants');
  const HasteFS = require('./HasteFS');
  const HasteModuleMap = require('./ModuleMap');
  const getMockName = require('./getMockName');
  const getPlatformExtension = require('./lib/getPlatformExtension');
  const nodeCrawl = require('./crawlers/node');
  const watchmanCrawl = require('./crawlers/watchman');
  const worker = require('./worker');
  const CHANGE_INTERVAL = 30;
  const MAX_WAIT_TIME = 240000;
  const NODE_MODULES = path.sep + 'node_modules' + path.sep;
  const canUseWatchman = (() => {
    try {
      execSync('watchman --version', {stdio: ['ignore']});
      return true;
    } catch (e) {}
    return false;
  })();
  const escapePathSeparator = (string) => path.sep === '\\' ? string.replace(/(\/|\\)/g, '\\\\') : string;
  const getWhiteList = (list) => {
    if (list && list.length) {
      return new RegExp('(' + escapePathSeparator(NODE_MODULES) + '(?:' + list.join('|') + ')(?=$|' + escapePathSeparator(path.sep) + '))', 'g');
    }
    return null;
  };
  class HasteMap extends EventEmitter {
    constructor(options) {
      super();
      this._options = {
        cacheDirectory: options.cacheDirectory || os.tmpdir(),
        extensions: options.extensions,
        forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,
        hasteImplModulePath: options.hasteImplModulePath,
        ignorePattern: options.ignorePattern,
        maxWorkers: options.maxWorkers,
        mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,
        name: options.name,
        platforms: options.platforms,
        resetCache: options.resetCache,
        retainAllFiles: options.retainAllFiles,
        roots: Array.from(new Set(options.roots)),
        throwOnModuleCollision: !!options.throwOnModuleCollision,
        useWatchman: options.useWatchman == null ? true : options.useWatchman,
        watch: !!options.watch
      };
      this._console = options.console || global.console;
      this._cachePath = HasteMap.getCacheFilePath(this._options.cacheDirectory, `haste-map-${this._options.name}`, VERSION, this._options.roots.join(':'), this._options.extensions.join(':'), this._options.platforms.join(':'), options.mocksPattern || '');
      this._whitelist = getWhiteList(options.providesModuleNodeModules);
      this._buildPromise = null;
      this._workerPromise = null;
      this._workerFarm = null;
      this._watchers = [];
    }
    static getCacheFilePath(tmpdir, name) {
      const hash = crypto.createHash('md5');
      Array.from(arguments).slice(1).forEach((arg) => hash.update(arg));
      return path.join(tmpdir, name.replace(/\W/g, '-') + '-' + hash.digest('hex'));
    }
    build() {
      if (!this._buildPromise) {
        this._buildPromise = this._buildFileMap().then((fileMap) => this._buildHasteMap(fileMap)).then((hasteMap) => {
          this._persist(hasteMap);
          const hasteFS = new HasteFS(hasteMap.files);
          const moduleMap = new HasteModuleMap(hasteMap.map, hasteMap.mocks);
          const __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;
          return this._watch(hasteMap, hasteFS, moduleMap).then(() => ({
            __hasteMapForTest,
            hasteFS,
            moduleMap
          }));
        });
      }
      return this._buildPromise;
    }
    read() {
      return this._parse(fs.readFileSync(this._cachePath, 'utf8'));
    }
    readModuleMap() {
      const data = this.read();
      return new HasteModuleMap(data.map, data.mocks);
    }
    _buildFileMap() {
      const read = this._options.resetCache ? this._createEmptyMap : this.read;
      return Promise.resolve().then(() => read.call(this)).catch(() => this._createEmptyMap()).then((hasteMap) => this._crawl(hasteMap));
    }
    _processFile(hasteMap, map, mocks, filePath, workerOptions) {
      const setModule = (id, module) => {
        if (!map[id]) {
          map[id] = Object.create(null);
        }
        const moduleMap = map[id];
        const platform = getPlatformExtension(module[H.PATH], this._options.platforms) || H.GENERIC_PLATFORM;
        const existingModule = moduleMap[platform];
        if (existingModule && existingModule[H.PATH] !== module[H.PATH]) {
          const message = `jest-haste-map: @providesModule naming collision:\n` + `  Duplicate module name: ${id}\n` + `  Paths: ${module[H.PATH]} collides with ` + `${existingModule[H.PATH]}\n\nThis ` + `${this._options.throwOnModuleCollision ? 'error' : 'warning'} ` + `is caused by a @providesModule declaration ` + `with the same name across two different files.`;
          if (this._options.throwOnModuleCollision) {
            throw new Error(message);
          }
          this._console.warn(message);
          delete moduleMap[platform];
          if (Object.keys(moduleMap).length === 1) {
            delete map[id];
          }
          let dupsByPlatform = hasteMap.duplicates[id];
          if (dupsByPlatform == null) {
            dupsByPlatform = hasteMap.duplicates[id] = Object.create(null);
          }
          const dups = dupsByPlatform[platform] = Object.create(null);
          dups[module[H.PATH]] = module[H.TYPE];
          dups[existingModule[H.PATH]] = existingModule[H.TYPE];
          return;
        }
        const dupsByPlatform = hasteMap.duplicates[id];
        if (dupsByPlatform != null) {
          const dups = dupsByPlatform[platform];
          if (dups != null) {
            dups[module[H.PATH]] = module[H.TYPE];
          }
          return;
        }
        moduleMap[platform] = module;
      };
      if (this._options.retainAllFiles && this._isNodeModulesDir(filePath)) {
        return null;
      }
      if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {
        const mockPath = getMockName(filePath);
        if (mocks[mockPath]) {
          this._console.warn(`jest-haste-map: duplicate manual mock found:\n` + `  Module name: ${mockPath}\n` + `  Duplicate Mock path: ${filePath}\nThis warning ` + `is caused by two manual mock files with the same file name.\n` + `Jest will use the mock file found in: \n` + `${filePath}\n` + ` Please delete one of the following two files: \n ` + `${mocks[mockPath]}\n${filePath}\n\n`);
        }
        mocks[mockPath] = filePath;
      }
      const fileMetadata = hasteMap.files[filePath];
      const moduleMetadata = hasteMap.map[fileMetadata[H.ID]];
      if (fileMetadata[H.VISITED]) {
        if (!fileMetadata[H.ID]) {
          return null;
        } else if (fileMetadata[H.ID] && moduleMetadata) {
          map[fileMetadata[H.ID]] = moduleMetadata;
          return null;
        }
      }
      return this._getWorker(workerOptions)({
        filePath,
        hasteImplModulePath: this._options.hasteImplModulePath
      }).then((metadata) => {
        fileMetadata[H.VISITED] = 1;
        const metadataId = metadata.id;
        const metadataModule = metadata.module;
        if (metadataId && metadataModule) {
          fileMetadata[H.ID] = metadataId;
          setModule(metadataId, metadataModule);
        }
        fileMetadata[H.DEPENDENCIES] = metadata.dependencies || [];
      }, (error) => {
        delete hasteMap.files[filePath];
      });
    }
    _buildHasteMap(hasteMap) {
      const map = Object.create(null);
      const mocks = Object.create(null);
      const promises = [];
      for (const filePath in hasteMap.files) {
        const promise = this._processFile(hasteMap, map, mocks, filePath);
        if (promise) {
          promises.push(promise);
        }
      }
      const cleanup = () => {
        if (this._workerFarm) {
          workerFarm.end(this._workerFarm);
        }
        this._workerFarm = null;
        this._workerPromise = null;
      };
      return Promise.all(promises).then(cleanup).then(() => {
        hasteMap.map = map;
        hasteMap.mocks = mocks;
        return hasteMap;
      }).catch((error) => {
        cleanup();
        return Promise.reject(error);
      });
    }
    _persist(hasteMap) {
      fs.writeFileSync(this._cachePath, JSON.stringify(hasteMap), 'utf8');
    }
    _getWorker(options) {
      if (!this._workerPromise) {
        let workerFn;
        if (options && options.forceInBand || this._options.maxWorkers <= 1) {
          workerFn = worker;
        } else {
          this._workerFarm = workerFarm({maxConcurrentWorkers: this._options.maxWorkers}, require.resolve('./worker'));
          workerFn = this._workerFarm;
        }
        this._workerPromise = (message) => new Promise((resolve, reject) => workerFn(message, (error, metadata) => {
          if (error || !metadata) {
            reject(error);
          } else {
            resolve(metadata);
          }
        }));
      }
      return this._workerPromise;
    }
    _parse(hasteMapPath) {
      const hasteMap = JSON.parse(hasteMapPath);
      for (const key in hasteMap) {
        Object.setPrototypeOf(hasteMap[key], null);
      }
      return hasteMap;
    }
    _crawl(hasteMap) {
      const options = this._options;
      const ignore = this._ignore.bind(this);
      const crawl = canUseWatchman && this._options.useWatchman ? watchmanCrawl : nodeCrawl;
      const retry = (error) => {
        if (crawl === watchmanCrawl) {
          this._console.warn(`jest-haste-map: Watchman crawl failed. Retrying once with node ` + `crawler.\n` + `  Usually this happens when watchman isn't running. Create an ` + `empty \`.watchmanconfig\` file in your project's root folder or ` + `initialize a git or hg repository in your project.\n` + `  ` + error);
          return nodeCrawl({
            data: hasteMap,
            extensions: options.extensions,
            forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
            ignore,
            roots: options.roots
          }).catch((e) => {
            throw new Error(`Crawler retry failed:\n` + `  Original error: ${error.message}\n` + `  Retry error: ${e.message}\n`);
          });
        }
        throw error;
      };
      try {
        return crawl({
          data: hasteMap,
          extensions: options.extensions,
          forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
          ignore,
          roots: options.roots
        }).catch(retry);
      } catch (error) {
        return retry(error);
      }
    }
    _watch(hasteMap, hasteFS, moduleMap) {
      if (!this._options.watch) {
        return Promise.resolve();
      }
      this._options.throwOnModuleCollision = false;
      this._options.retainAllFiles = true;
      const Watcher = canUseWatchman && this._options.useWatchman ? sane.WatchmanWatcher : sane.NodeWatcher;
      const extensions = this._options.extensions;
      const ignorePattern = this._options.ignorePattern;
      let changeQueue = Promise.resolve();
      let eventsQueue = [];
      let mustCopy = true;
      const createWatcher = (root) => {
        const watcher = new Watcher(root, {
          dot: false,
          glob: extensions.map((extension) => '**/*.' + extension),
          ignored: ignorePattern
        });
        return new Promise((resolve, reject) => {
          const rejectTimeout = setTimeout(() => reject(new Error('Failed to start watch mode.')), MAX_WAIT_TIME);
          watcher.once('ready', () => {
            clearTimeout(rejectTimeout);
            watcher.on('all', onChange);
            resolve(watcher);
          });
        });
      };
      const emitChange = () => {
        if (eventsQueue.length) {
          mustCopy = true;
          this.emit('change', {
            eventsQueue,
            hasteFS: new HasteFS(hasteMap.files),
            moduleMap: new HasteModuleMap(hasteMap.map, hasteMap.mocks)
          });
          eventsQueue = [];
        }
      };
      const onChange = (type, filePath, root, stat) => {
        filePath = path.join(root, filePath);
        if (this._ignore(filePath) || !extensions.some((extension) => filePath.endsWith(extension))) {
          return;
        }
        changeQueue = changeQueue.then(() => {
          if (eventsQueue.find((event) => event.type === type && event.filePath === filePath && (!event.stat && !stat || event.stat && stat && event.stat.mtime.getTime() === stat.mtime.getTime()))) {
            return null;
          }
          if (mustCopy) {
            mustCopy = false;
            hasteMap = {
              clocks: copy(hasteMap.clocks),
              duplicates: copy(hasteMap.duplicates),
              files: copy(hasteMap.files),
              map: copy(hasteMap.map),
              mocks: copy(hasteMap.mocks)
            };
          }
          const add = () => eventsQueue.push({
            filePath,
            stat,
            type
          });
          const moduleName = hasteMap.files[filePath] && hasteMap.files[filePath][H.ID];
          delete hasteMap.files[filePath];
          delete hasteMap.map[moduleName];
          if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {
            const mockName = getMockName(filePath);
            delete hasteMap.mocks[mockName];
          }
          this._recoverDuplicates(hasteMap, filePath, moduleName);
          if (type === 'add' || type === 'change') {
            const fileMetadata = ['', stat.mtime.getTime(), 0, []];
            hasteMap.files[filePath] = fileMetadata;
            const promise = this._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {forceInBand: true});
            this._workerPromise = null;
            if (promise) {
              return promise.then(add);
            } else {
              add();
            }
          } else {
            add();
          }
          return null;
        }).catch((error) => {
          this._console.error(`jest-haste-map: watch error:\n  ${error.stack}\n`);
        });
      };
      this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);
      return Promise.all(this._options.roots.map(createWatcher)).then((watchers) => {
        this._watchers = watchers;
      });
    }
    _recoverDuplicates(hasteMap, filePath, moduleName) {
      let dupsByPlatform = hasteMap.duplicates[moduleName];
      if (dupsByPlatform == null) {
        return;
      }
      const platform = getPlatformExtension(filePath, this._options.platforms) || H.GENERIC_PLATFORM;
      let dups = dupsByPlatform[platform];
      if (dups == null) {
        return;
      }
      dupsByPlatform = hasteMap.duplicates[moduleName] = copy(dupsByPlatform);
      dups = dupsByPlatform[platform] = copy(dups);
      const dedupType = dups[filePath];
      delete dups[filePath];
      const filePaths = Object.keys(dups);
      if (filePaths.length > 1) {
        return;
      }
      let dedupMap = hasteMap.map[moduleName];
      if (dedupMap == null) {
        dedupMap = hasteMap.map[moduleName] = Object.create(null);
      }
      dedupMap[platform] = [filePaths[0], dedupType];
      delete dupsByPlatform[platform];
      if (Object.keys(dupsByPlatform).length === 0) {
        delete hasteMap.duplicates[moduleName];
      }
    }
    end() {
      clearInterval(this._changeInterval);
      if (!this._watchers.length) {
        return Promise.resolve();
      }
      return Promise.all(this._watchers.map((watcher) => new Promise((resolve) => watcher.close(resolve)))).then(() => this._watchers = []);
    }
    _ignore(filePath) {
      const ignorePattern = this._options.ignorePattern;
      const ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern(filePath);
      return (ignoreMatched || !this._options.retainAllFiles && this._isNodeModulesDir(filePath));
    }
    _isNodeModulesDir(filePath) {
      if (!filePath.includes(NODE_MODULES)) {
        return false;
      }
      if (this._whitelist) {
        const whitelist = this._whitelist;
        const match = whitelist.exec(filePath);
        const matchEndIndex = whitelist.lastIndex;
        whitelist.lastIndex = 0;
        if (!match) {
          return true;
        }
        const filePathInPackage = filePath.substr(matchEndIndex);
        return filePathInPackage.startsWith(NODE_MODULES);
      }
      return true;
    }
    _createEmptyMap() {
      return {
        clocks: Object.create(null),
        duplicates: Object.create(null),
        files: Object.create(null),
        map: Object.create(null),
        mocks: Object.create(null)
      };
    }
  }
  const copy = (object) => Object.assign(Object.create(null), object);
  HasteMap.H = H;
  HasteMap.ModuleMap = HasteModuleMap;
  module.exports = HasteMap;
})(require('process'));
