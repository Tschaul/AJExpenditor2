/* */ 
"format cjs";
(function(process) {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
      module.exports = factory();
    else if (typeof define === 'function' && define.amd)
      define([], factory);
    else if (typeof exports === 'object')
      exports["JsDiff"] = factory();
    else
      root["JsDiff"] = factory();
  })(this, function() {
    return (function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    })([function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      var _character = __webpack_require__(2);
      var _word = __webpack_require__(3);
      var _line = __webpack_require__(5);
      var _sentence = __webpack_require__(6);
      var _css = __webpack_require__(7);
      var _json = __webpack_require__(8);
      var _array = __webpack_require__(9);
      var _apply = __webpack_require__(10);
      var _parse = __webpack_require__(11);
      var _merge = __webpack_require__(13);
      var _create = __webpack_require__(14);
      var _dmp = __webpack_require__(16);
      var _xml = __webpack_require__(17);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      exports.Diff = _base2['default'];
      exports.diffChars = _character.diffChars;
      exports.diffWords = _word.diffWords;
      exports.diffWordsWithSpace = _word.diffWordsWithSpace;
      exports.diffLines = _line.diffLines;
      exports.diffTrimmedLines = _line.diffTrimmedLines;
      exports.diffSentences = _sentence.diffSentences;
      exports.diffCss = _css.diffCss;
      exports.diffJson = _json.diffJson;
      exports.diffArrays = _array.diffArrays;
      exports.structuredPatch = _create.structuredPatch;
      exports.createTwoFilesPatch = _create.createTwoFilesPatch;
      exports.createPatch = _create.createPatch;
      exports.applyPatch = _apply.applyPatch;
      exports.applyPatches = _apply.applyPatches;
      exports.parsePatch = _parse.parsePatch;
      exports.merge = _merge.merge;
      exports.convertChangesToDMP = _dmp.convertChangesToDMP;
      exports.convertChangesToXML = _xml.convertChangesToXML;
      exports.canonicalize = _json.canonicalize;
    }, function(module, exports) {
      'use strict';
      exports.__esModule = true;
      exports['default'] = Diff;
      function Diff() {}
      Diff.prototype = {
        diff: function diff(oldString, newString) {
          var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
          var callback = options.callback;
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          this.options = options;
          var self = this;
          function done(value) {
            if (callback) {
              setTimeout(function() {
                callback(undefined, value);
              }, 0);
              return true;
            } else {
              return value;
            }
          }
          oldString = this.castInput(oldString);
          newString = this.castInput(newString);
          oldString = this.removeEmpty(this.tokenize(oldString));
          newString = this.removeEmpty(this.tokenize(newString));
          var newLen = newString.length,
              oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{
            newPos: -1,
            components: []
          }];
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            return done([{
              value: this.join(newString),
              count: newString.length
            }]);
          }
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = void 0;
              var addPath = bestPath[diagonalPath - 1],
                  removePath = bestPath[diagonalPath + 1],
                  _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath) {
                bestPath[diagonalPath - 1] = undefined;
              }
              var canAdd = addPath && addPath.newPos + 1 < newLen,
                  canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = undefined;
                continue;
              }
              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self.pushComponent(basePath.components, undefined, true);
              } else {
                basePath = addPath;
                basePath.newPos++;
                self.pushComponent(basePath.components, true, undefined);
              }
              _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
              if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
                return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
              } else {
                bestPath[diagonalPath] = basePath;
              }
            }
            editLength++;
          }
          if (callback) {
            (function exec() {
              setTimeout(function() {
                if (editLength > maxEditLength) {
                  return callback();
                }
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            })();
          } else {
            while (editLength <= maxEditLength) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        },
        pushComponent: function pushComponent(components, added, removed) {
          var last = components[components.length - 1];
          if (last && last.added === added && last.removed === removed) {
            components[components.length - 1] = {
              count: last.count + 1,
              added: added,
              removed: removed
            };
          } else {
            components.push({
              count: 1,
              added: added,
              removed: removed
            });
          }
        },
        extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length,
              oldLen = oldString.length,
              newPos = basePath.newPos,
              oldPos = newPos - diagonalPath,
              commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
          if (commonCount) {
            basePath.components.push({count: commonCount});
          }
          basePath.newPos = newPos;
          return oldPos;
        },
        equals: function equals(left, right) {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        },
        removeEmpty: function removeEmpty(array) {
          var ret = [];
          for (var i = 0; i < array.length; i++) {
            if (array[i]) {
              ret.push(array[i]);
            }
          }
          return ret;
        },
        castInput: function castInput(value) {
          return value;
        },
        tokenize: function tokenize(value) {
          return value.split('');
        },
        join: function join(chars) {
          return chars.join('');
        }
      };
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        var componentPos = 0,
            componentLen = components.length,
            newPos = 0,
            oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value = newString.slice(newPos, newPos + component.count);
              value = value.map(function(value, i) {
                var oldValue = oldString[oldPos + i];
                return oldValue.length > value.length ? oldValue : value;
              });
              component.value = diff.join(value);
            } else {
              component.value = diff.join(newString.slice(newPos, newPos + component.count));
            }
            newPos += component.count;
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
        var lastComponent = components[componentLen - 1];
        if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
          components[componentLen - 2].value += lastComponent.value;
          components.pop();
        }
        return components;
      }
      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.characterDiff = undefined;
      exports.diffChars = diffChars;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var characterDiff = exports.characterDiff = new _base2['default']();
      function diffChars(oldStr, newStr, options) {
        return characterDiff.diff(oldStr, newStr, options);
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.wordDiff = undefined;
      exports.diffWords = diffWords;
      exports.diffWordsWithSpace = diffWordsWithSpace;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      var _params = __webpack_require__(4);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
      var reWhitespace = /\S/;
      var wordDiff = exports.wordDiff = new _base2['default']();
      wordDiff.equals = function(left, right) {
        if (this.options.ignoreCase) {
          left = left.toLowerCase();
          right = right.toLowerCase();
        }
        return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
      };
      wordDiff.tokenize = function(value) {
        var tokens = value.split(/(\s+|\b)/);
        for (var i = 0; i < tokens.length - 1; i++) {
          if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
            tokens[i] += tokens[i + 2];
            tokens.splice(i + 1, 2);
            i--;
          }
        }
        return tokens;
      };
      function diffWords(oldStr, newStr, options) {
        options = (0, _params.generateOptions)(options, {ignoreWhitespace: true});
        return wordDiff.diff(oldStr, newStr, options);
      }
      function diffWordsWithSpace(oldStr, newStr, options) {
        return wordDiff.diff(oldStr, newStr, options);
      }
    }, function(module, exports) {
      'use strict';
      exports.__esModule = true;
      exports.generateOptions = generateOptions;
      function generateOptions(options, defaults) {
        if (typeof options === 'function') {
          defaults.callback = options;
        } else if (options) {
          for (var name in options) {
            if (options.hasOwnProperty(name)) {
              defaults[name] = options[name];
            }
          }
        }
        return defaults;
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.lineDiff = undefined;
      exports.diffLines = diffLines;
      exports.diffTrimmedLines = diffTrimmedLines;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      var _params = __webpack_require__(4);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var lineDiff = exports.lineDiff = new _base2['default']();
      lineDiff.tokenize = function(value) {
        var retLines = [],
            linesAndNewlines = value.split(/(\n|\r\n)/);
        if (!linesAndNewlines[linesAndNewlines.length - 1]) {
          linesAndNewlines.pop();
        }
        for (var i = 0; i < linesAndNewlines.length; i++) {
          var line = linesAndNewlines[i];
          if (i % 2 && !this.options.newlineIsToken) {
            retLines[retLines.length - 1] += line;
          } else {
            if (this.options.ignoreWhitespace) {
              line = line.trim();
            }
            retLines.push(line);
          }
        }
        return retLines;
      };
      function diffLines(oldStr, newStr, callback) {
        return lineDiff.diff(oldStr, newStr, callback);
      }
      function diffTrimmedLines(oldStr, newStr, callback) {
        var options = (0, _params.generateOptions)(callback, {ignoreWhitespace: true});
        return lineDiff.diff(oldStr, newStr, options);
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.sentenceDiff = undefined;
      exports.diffSentences = diffSentences;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var sentenceDiff = exports.sentenceDiff = new _base2['default']();
      sentenceDiff.tokenize = function(value) {
        return value.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      function diffSentences(oldStr, newStr, callback) {
        return sentenceDiff.diff(oldStr, newStr, callback);
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.cssDiff = undefined;
      exports.diffCss = diffCss;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var cssDiff = exports.cssDiff = new _base2['default']();
      cssDiff.tokenize = function(value) {
        return value.split(/([{}:;,]|\s+)/);
      };
      function diffCss(oldStr, newStr, callback) {
        return cssDiff.diff(oldStr, newStr, callback);
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.jsonDiff = undefined;
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
      };
      exports.diffJson = diffJson;
      exports.canonicalize = canonicalize;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      var _line = __webpack_require__(5);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var objectPrototypeToString = Object.prototype.toString;
      var jsonDiff = exports.jsonDiff = new _base2['default']();
      jsonDiff.useLongestToken = true;
      jsonDiff.tokenize = _line.lineDiff.tokenize;
      jsonDiff.castInput = function(value) {
        var undefinedReplacement = this.options.undefinedReplacement;
        return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function(k, v) {
          if (typeof v === 'undefined') {
            return undefinedReplacement;
          }
          return v;
        }, '  ');
      };
      jsonDiff.equals = function(left, right) {
        return (_base2['default'].prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1')));
      };
      function diffJson(oldObj, newObj, options) {
        return jsonDiff.diff(oldObj, newObj, options);
      }
      function canonicalize(obj, stack, replacementStack) {
        stack = stack || [];
        replacementStack = replacementStack || [];
        var i = void 0;
        for (i = 0; i < stack.length; i += 1) {
          if (stack[i] === obj) {
            return replacementStack[i];
          }
        }
        var canonicalizedObj = void 0;
        if ('[object Array]' === objectPrototypeToString.call(obj)) {
          stack.push(obj);
          canonicalizedObj = new Array(obj.length);
          replacementStack.push(canonicalizedObj);
          for (i = 0; i < obj.length; i += 1) {
            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
          }
          stack.pop();
          replacementStack.pop();
          return canonicalizedObj;
        }
        if (obj && obj.toJSON) {
          obj = obj.toJSON();
        }
        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
          stack.push(obj);
          canonicalizedObj = {};
          replacementStack.push(canonicalizedObj);
          var sortedKeys = [],
              key = void 0;
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              sortedKeys.push(key);
            }
          }
          sortedKeys.sort();
          for (i = 0; i < sortedKeys.length; i += 1) {
            key = sortedKeys[i];
            canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
          }
          stack.pop();
          replacementStack.pop();
        } else {
          canonicalizedObj = obj;
        }
        return canonicalizedObj;
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.arrayDiff = undefined;
      exports.diffArrays = diffArrays;
      var _base = __webpack_require__(1);
      var _base2 = _interopRequireDefault(_base);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      var arrayDiff = exports.arrayDiff = new _base2['default']();
      arrayDiff.tokenize = arrayDiff.join = function(value) {
        return value.slice();
      };
      function diffArrays(oldArr, newArr, callback) {
        return arrayDiff.diff(oldArr, newArr, callback);
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.applyPatch = applyPatch;
      exports.applyPatches = applyPatches;
      var _parse = __webpack_require__(11);
      var _distanceIterator = __webpack_require__(12);
      var _distanceIterator2 = _interopRequireDefault(_distanceIterator);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {'default': obj};
      }
      function applyPatch(source, uniDiff) {
        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
        if (typeof uniDiff === 'string') {
          uniDiff = (0, _parse.parsePatch)(uniDiff);
        }
        if (Array.isArray(uniDiff)) {
          if (uniDiff.length > 1) {
            throw new Error('applyPatch only works with a single input.');
          }
          uniDiff = uniDiff[0];
        }
        var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
            delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
            hunks = uniDiff.hunks,
            compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {
              return (line === patchContent);
            },
            errorCount = 0,
            fuzzFactor = options.fuzzFactor || 0,
            minLine = 0,
            offset = 0,
            removeEOFNL = void 0,
            addEOFNL = void 0;
        function hunkFits(hunk, toPos) {
          for (var j = 0; j < hunk.lines.length; j++) {
            var line = hunk.lines[j],
                operation = line[0],
                content = line.substr(1);
            if (operation === ' ' || operation === '-') {
              if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
                errorCount++;
                if (errorCount > fuzzFactor) {
                  return false;
                }
              }
              toPos++;
            }
          }
          return true;
        }
        for (var i = 0; i < hunks.length; i++) {
          var hunk = hunks[i],
              maxLine = lines.length - hunk.oldLines,
              localOffset = 0,
              toPos = offset + hunk.oldStart - 1;
          var iterator = (0, _distanceIterator2['default'])(toPos, minLine, maxLine);
          for (; localOffset !== undefined; localOffset = iterator()) {
            if (hunkFits(hunk, toPos + localOffset)) {
              hunk.offset = offset += localOffset;
              break;
            }
          }
          if (localOffset === undefined) {
            return false;
          }
          minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
        }
        var diffOffset = 0;
        for (var _i = 0; _i < hunks.length; _i++) {
          var _hunk = hunks[_i],
              _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
          diffOffset += _hunk.newLines - _hunk.oldLines;
          for (var j = 0; j < _hunk.lines.length; j++) {
            var line = _hunk.lines[j],
                operation = line[0],
                content = line.substr(1),
                delimiter = _hunk.linedelimiters[j];
            if (operation === ' ') {
              _toPos++;
            } else if (operation === '-') {
              lines.splice(_toPos, 1);
              delimiters.splice(_toPos, 1);
            } else if (operation === '+') {
              lines.splice(_toPos, 0, content);
              delimiters.splice(_toPos, 0, delimiter);
              _toPos++;
            } else if (operation === '\\') {
              var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
              if (previousOperation === '+') {
                removeEOFNL = true;
              } else if (previousOperation === '-') {
                addEOFNL = true;
              }
            }
          }
        }
        if (removeEOFNL) {
          while (!lines[lines.length - 1]) {
            lines.pop();
            delimiters.pop();
          }
        } else if (addEOFNL) {
          lines.push('');
          delimiters.push('\n');
        }
        for (var _k = 0; _k < lines.length - 1; _k++) {
          lines[_k] = lines[_k] + delimiters[_k];
        }
        return lines.join('');
      }
      function applyPatches(uniDiff, options) {
        if (typeof uniDiff === 'string') {
          uniDiff = (0, _parse.parsePatch)(uniDiff);
        }
        var currentIndex = 0;
        function processIndex() {
          var index = uniDiff[currentIndex++];
          if (!index) {
            return options.complete();
          }
          options.loadFile(index, function(err, data) {
            if (err) {
              return options.complete(err);
            }
            var updatedContent = applyPatch(data, index, options);
            options.patched(index, updatedContent, function(err) {
              if (err) {
                return options.complete(err);
              }
              processIndex();
            });
          });
        }
        processIndex();
      }
    }, function(module, exports) {
      'use strict';
      exports.__esModule = true;
      exports.parsePatch = parsePatch;
      function parsePatch(uniDiff) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
        var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
            delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
            list = [],
            i = 0;
        function parseIndex() {
          var index = {};
          list.push(index);
          while (i < diffstr.length) {
            var line = diffstr[i];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
              break;
            }
            var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
            if (header) {
              index.index = header[1];
            }
            i++;
          }
          parseFileHeader(index);
          parseFileHeader(index);
          index.hunks = [];
          while (i < diffstr.length) {
            var _line = diffstr[i];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
              break;
            } else if (/^@@/.test(_line)) {
              index.hunks.push(parseHunk());
            } else if (_line && options.strict) {
              throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
            } else {
              i++;
            }
          }
        }
        function parseFileHeader(index) {
          var headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
          var fileHeader = headerPattern.exec(diffstr[i]);
          if (fileHeader) {
            var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
            var fileName = fileHeader[2].replace(/\\\\/g, '\\');
            if (/^".*"$/.test(fileName)) {
              fileName = fileName.substr(1, fileName.length - 2);
            }
            index[keyPrefix + 'FileName'] = fileName;
            index[keyPrefix + 'Header'] = fileHeader[3];
            i++;
          }
        }
        function parseHunk() {
          var chunkHeaderIndex = i,
              chunkHeaderLine = diffstr[i++],
              chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
          var hunk = {
            oldStart: +chunkHeader[1],
            oldLines: +chunkHeader[2] || 1,
            newStart: +chunkHeader[3],
            newLines: +chunkHeader[4] || 1,
            lines: [],
            linedelimiters: []
          };
          var addCount = 0,
              removeCount = 0;
          for (; i < diffstr.length; i++) {
            if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
              break;
            }
            var operation = diffstr[i][0];
            if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
              hunk.lines.push(diffstr[i]);
              hunk.linedelimiters.push(delimiters[i] || '\n');
              if (operation === '+') {
                addCount++;
              } else if (operation === '-') {
                removeCount++;
              } else if (operation === ' ') {
                addCount++;
                removeCount++;
              }
            } else {
              break;
            }
          }
          if (!addCount && hunk.newLines === 1) {
            hunk.newLines = 0;
          }
          if (!removeCount && hunk.oldLines === 1) {
            hunk.oldLines = 0;
          }
          if (options.strict) {
            if (addCount !== hunk.newLines) {
              throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
            }
            if (removeCount !== hunk.oldLines) {
              throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
            }
          }
          return hunk;
        }
        while (i < diffstr.length) {
          parseIndex();
        }
        return list;
      }
    }, function(module, exports) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(start, minLine, maxLine) {
        var wantForward = true,
            backwardExhausted = false,
            forwardExhausted = false,
            localOffset = 1;
        return function iterator() {
          if (wantForward && !forwardExhausted) {
            if (backwardExhausted) {
              localOffset++;
            } else {
              wantForward = false;
            }
            if (start + localOffset <= maxLine) {
              return localOffset;
            }
            forwardExhausted = true;
          }
          if (!backwardExhausted) {
            if (!forwardExhausted) {
              wantForward = true;
            }
            if (minLine <= start - localOffset) {
              return -localOffset++;
            }
            backwardExhausted = true;
            return iterator();
          }
        };
      };
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.calcLineCount = calcLineCount;
      exports.merge = merge;
      var _create = __webpack_require__(14);
      var _parse = __webpack_require__(11);
      var _array = __webpack_require__(15);
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0,
              arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function calcLineCount(hunk) {
        var conflicted = false;
        hunk.oldLines = 0;
        hunk.newLines = 0;
        hunk.lines.forEach(function(line) {
          if (typeof line !== 'string') {
            conflicted = true;
            return;
          }
          if (line[0] === '+' || line[0] === ' ') {
            hunk.newLines++;
          }
          if (line[0] === '-' || line[0] === ' ') {
            hunk.oldLines++;
          }
        });
        if (conflicted) {
          delete hunk.oldLines;
          delete hunk.newLines;
        }
      }
      function merge(mine, theirs, base) {
        mine = loadPatch(mine, base);
        theirs = loadPatch(theirs, base);
        var ret = {};
        if (mine.index || theirs.index) {
          ret.index = mine.index || theirs.index;
        }
        if (mine.newFileName || theirs.newFileName) {
          if (!fileNameChanged(mine)) {
            ret.oldFileName = theirs.oldFileName || mine.oldFileName;
            ret.newFileName = theirs.newFileName || mine.newFileName;
            ret.oldHeader = theirs.oldHeader || mine.oldHeader;
            ret.newHeader = theirs.newHeader || mine.newHeader;
          } else if (!fileNameChanged(theirs)) {
            ret.oldFileName = mine.oldFileName;
            ret.newFileName = mine.newFileName;
            ret.oldHeader = mine.oldHeader;
            ret.newHeader = mine.newHeader;
          } else {
            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
          }
        }
        ret.hunks = [];
        var mineIndex = 0,
            theirsIndex = 0,
            mineOffset = 0,
            theirsOffset = 0;
        while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
          var mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},
              theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};
          if (hunkBefore(mineCurrent, theirsCurrent)) {
            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
            mineIndex++;
            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
          } else if (hunkBefore(theirsCurrent, mineCurrent)) {
            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
            theirsIndex++;
            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
          } else {
            var mergedHunk = {
              oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
              oldLines: 0,
              newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
              newLines: 0,
              lines: []
            };
            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
            theirsIndex++;
            mineIndex++;
            ret.hunks.push(mergedHunk);
          }
        }
        return ret;
      }
      function loadPatch(param, base) {
        if (typeof param === 'string') {
          if (/^@@/m.test(param) || /^Index:/m.test(param)) {
            return ((0, _parse.parsePatch)(param)[0]);
          }
          if (!base) {
            throw new Error('Must provide a base reference or pass in a patch');
          }
          return ((0, _create.structuredPatch)(undefined, undefined, base, param));
        }
        return param;
      }
      function fileNameChanged(patch) {
        return patch.newFileName && patch.newFileName !== patch.oldFileName;
      }
      function selectField(index, mine, theirs) {
        if (mine === theirs) {
          return mine;
        } else {
          index.conflict = true;
          return {
            mine: mine,
            theirs: theirs
          };
        }
      }
      function hunkBefore(test, check) {
        return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
      }
      function cloneHunk(hunk, offset) {
        return {
          oldStart: hunk.oldStart,
          oldLines: hunk.oldLines,
          newStart: hunk.newStart + offset,
          newLines: hunk.newLines,
          lines: hunk.lines
        };
      }
      function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
        var mine = {
          offset: mineOffset,
          lines: mineLines,
          index: 0
        },
            their = {
              offset: theirOffset,
              lines: theirLines,
              index: 0
            };
        insertLeading(hunk, mine, their);
        insertLeading(hunk, their, mine);
        while (mine.index < mine.lines.length && their.index < their.lines.length) {
          var mineCurrent = mine.lines[mine.index],
              theirCurrent = their.lines[their.index];
          if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
            mutualChange(hunk, mine, their);
          } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
            var _hunk$lines;
            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
          } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
            var _hunk$lines2;
            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
          } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
            removal(hunk, mine, their);
          } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
            removal(hunk, their, mine, true);
          } else if (mineCurrent === theirCurrent) {
            hunk.lines.push(mineCurrent);
            mine.index++;
            their.index++;
          } else {
            conflict(hunk, collectChange(mine), collectChange(their));
          }
        }
        insertTrailing(hunk, mine);
        insertTrailing(hunk, their);
        calcLineCount(hunk);
      }
      function mutualChange(hunk, mine, their) {
        var myChanges = collectChange(mine),
            theirChanges = collectChange(their);
        if (allRemoves(myChanges) && allRemoves(theirChanges)) {
          if ((0, _array.arrayStartsWith)(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
            var _hunk$lines3;
            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
            return;
          } else if ((0, _array.arrayStartsWith)(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
            var _hunk$lines4;
            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
            return;
          }
        } else if ((0, _array.arrayEqual)(myChanges, theirChanges)) {
          var _hunk$lines5;
          (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
          return;
        }
        conflict(hunk, myChanges, theirChanges);
      }
      function removal(hunk, mine, their, swap) {
        var myChanges = collectChange(mine),
            theirChanges = collectContext(their, myChanges);
        if (theirChanges.merged) {
          var _hunk$lines6;
          (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
        } else {
          conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
        }
      }
      function conflict(hunk, mine, their) {
        hunk.conflict = true;
        hunk.lines.push({
          conflict: true,
          mine: mine,
          theirs: their
        });
      }
      function insertLeading(hunk, insert, their) {
        while (insert.offset < their.offset && insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
          insert.offset++;
        }
      }
      function insertTrailing(hunk, insert) {
        while (insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
        }
      }
      function collectChange(state) {
        var ret = [],
            operation = state.lines[state.index][0];
        while (state.index < state.lines.length) {
          var line = state.lines[state.index];
          if (operation === '-' && line[0] === '+') {
            operation = '+';
          }
          if (operation === line[0]) {
            ret.push(line);
            state.index++;
          } else {
            break;
          }
        }
        return ret;
      }
      function collectContext(state, matchChanges) {
        var changes = [],
            merged = [],
            matchIndex = 0,
            contextChanges = false,
            conflicted = false;
        while (matchIndex < matchChanges.length && state.index < state.lines.length) {
          var change = state.lines[state.index],
              match = matchChanges[matchIndex];
          if (match[0] === '+') {
            break;
          }
          contextChanges = contextChanges || change[0] !== ' ';
          merged.push(match);
          matchIndex++;
          if (change[0] === '+') {
            conflicted = true;
            while (change[0] === '+') {
              changes.push(change);
              change = state.lines[++state.index];
            }
          }
          if (match.substr(1) === change.substr(1)) {
            changes.push(change);
            state.index++;
          } else {
            conflicted = true;
          }
        }
        if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
          conflicted = true;
        }
        if (conflicted) {
          return changes;
        }
        while (matchIndex < matchChanges.length) {
          merged.push(matchChanges[matchIndex++]);
        }
        return {
          merged: merged,
          changes: changes
        };
      }
      function allRemoves(changes) {
        return changes.reduce(function(prev, change) {
          return prev && change[0] === '-';
        }, true);
      }
      function skipRemoveSuperset(state, removeChanges, delta) {
        for (var i = 0; i < delta; i++) {
          var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
          if (state.lines[state.index + i] !== ' ' + changeContent) {
            return false;
          }
        }
        state.index += delta;
        return true;
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      exports.__esModule = true;
      exports.structuredPatch = structuredPatch;
      exports.createTwoFilesPatch = createTwoFilesPatch;
      exports.createPatch = createPatch;
      var _line = __webpack_require__(5);
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0,
              arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        if (!options) {
          options = {};
        }
        if (typeof options.context === 'undefined') {
          options.context = 4;
        }
        var diff = (0, _line.diffLines)(oldStr, newStr, options);
        diff.push({
          value: '',
          lines: []
        });
        function contextLines(lines) {
          return lines.map(function(entry) {
            return ' ' + entry;
          });
        }
        var hunks = [];
        var oldRangeStart = 0,
            newRangeStart = 0,
            curRange = [],
            oldLine = 1,
            newLine = 1;
        var _loop = function _loop(i) {
          var current = diff[i],
              lines = current.lines || current.value.replace(/\n$/, '').split('\n');
          current.lines = lines;
          if (current.added || current.removed) {
            var _curRange;
            if (!oldRangeStart) {
              var prev = diff[i - 1];
              oldRangeStart = oldLine;
              newRangeStart = newLine;
              if (prev) {
                curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
                oldRangeStart -= curRange.length;
                newRangeStart -= curRange.length;
              }
            }
            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
              return (current.added ? '+' : '-') + entry;
            })));
            if (current.added) {
              newLine += lines.length;
            } else {
              oldLine += lines.length;
            }
          } else {
            if (oldRangeStart) {
              if (lines.length <= options.context * 2 && i < diff.length - 2) {
                var _curRange2;
                (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
              } else {
                var _curRange3;
                var contextSize = Math.min(lines.length, options.context);
                (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                var hunk = {
                  oldStart: oldRangeStart,
                  oldLines: oldLine - oldRangeStart + contextSize,
                  newStart: newRangeStart,
                  newLines: newLine - newRangeStart + contextSize,
                  lines: curRange
                };
                if (i >= diff.length - 2 && lines.length <= options.context) {
                  var oldEOFNewline = /\n$/.test(oldStr);
                  var newEOFNewline = /\n$/.test(newStr);
                  if (lines.length == 0 && !oldEOFNewline) {
                    curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
                  } else if (!oldEOFNewline || !newEOFNewline) {
                    curRange.push('\\ No newline at end of file');
                  }
                }
                hunks.push(hunk);
                oldRangeStart = 0;
                newRangeStart = 0;
                curRange = [];
              }
            }
            oldLine += lines.length;
            newLine += lines.length;
          }
        };
        for (var i = 0; i < diff.length; i++) {
          _loop(i);
        }
        return {
          oldFileName: oldFileName,
          newFileName: newFileName,
          oldHeader: oldHeader,
          newHeader: newHeader,
          hunks: hunks
        };
      }
      function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
        var ret = [];
        if (oldFileName == newFileName) {
          ret.push('Index: ' + oldFileName);
        }
        ret.push('===================================================================');
        ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
        ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));
        for (var i = 0; i < diff.hunks.length; i++) {
          var hunk = diff.hunks[i];
          ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
          ret.push.apply(ret, hunk.lines);
        }
        return ret.join('\n') + '\n';
      }
      function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
        return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
      }
    }, function(module, exports) {
      "use strict";
      exports.__esModule = true;
      exports.arrayEqual = arrayEqual;
      exports.arrayStartsWith = arrayStartsWith;
      function arrayEqual(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        return arrayStartsWith(a, b);
      }
      function arrayStartsWith(array, start) {
        if (start.length > array.length) {
          return false;
        }
        for (var i = 0; i < start.length; i++) {
          if (start[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
    }, function(module, exports) {
      "use strict";
      exports.__esModule = true;
      exports.convertChangesToDMP = convertChangesToDMP;
      function convertChangesToDMP(changes) {
        var ret = [],
            change = void 0,
            operation = void 0;
        for (var i = 0; i < changes.length; i++) {
          change = changes[i];
          if (change.added) {
            operation = 1;
          } else if (change.removed) {
            operation = -1;
          } else {
            operation = 0;
          }
          ret.push([operation, change.value]);
        }
        return ret;
      }
    }, function(module, exports) {
      'use strict';
      exports.__esModule = true;
      exports.convertChangesToXML = convertChangesToXML;
      function convertChangesToXML(changes) {
        var ret = [];
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          if (change.added) {
            ret.push('<ins>');
          } else if (change.removed) {
            ret.push('<del>');
          }
          ret.push(escapeHTML(change.value));
          if (change.added) {
            ret.push('</ins>');
          } else if (change.removed) {
            ret.push('</del>');
          }
        }
        return ret.join('');
      }
      function escapeHTML(s) {
        var n = s;
        n = n.replace(/&/g, '&amp;');
        n = n.replace(/</g, '&lt;');
        n = n.replace(/>/g, '&gt;');
        n = n.replace(/"/g, '&quot;');
        return n;
      }
    }]);
  });
  ;
})(require('process'));
